<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
	<meta name="generator" content="Hugo 0.26" />
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  

  <title> npf.io </title>

  
  <link rel="stylesheet" href="https://npf.io/css/poole.css">
  <link rel="stylesheet" href="https://npf.io/css/syntax.css">
  <link rel="stylesheet" href="https://npf.io/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/manifest.json">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="theme-color" content="#ffffff">

  
  <link href="https://npf.io/index.xml" rel="alternate" type="application/rss+xml" title="npf.io" />
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">

  <link href='https://fonts.googleapis.com/css?family=Fira+Sans:400,300' rel='stylesheet' type='text/css'>

  <script src="//ajax.googleapis.com/ajax/libs/webfont/1.4.7/webfont.js"></script>
  <script>
    WebFont.load({
      google: {
        families: ['Fira Sans']
      }
    });
  </script>

</head>

<body>

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about" align=center>
      <h1 class="brand"><a href="https://npf.io">npf.io</a></h1>
      <img src="/moose.svg" width=50% />
      <p class="lead">
         code by Nate Finch 
      </p>
    </div>
    <ul class="sidebar-nav">
      <li><a href="https://npf.io/blog">Posts</a></li>
      
      <li><a href="/about/">About </a></li>
      
      <br/> 
      <li>Code:</li>
       
       
       
       
       
       
       
       
       
       
       
       
       
       
      <li><a href="https://github.com/natefinch/deputy">Deputy </a></li>
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
      <li><a href="https://github.com/natefinch/gorram">Gorram </a></li>
       
       
       
       
       
       
       
       
       
       
      <li><a href="https://github.com/natefinch/lumberjack">Lumberjack </a></li>
       
       
       
      <li><a href="https://github.com/natefinch/npipe">NPipe </a></li>
       
       
       
       
      <li><a href="https://github.com/natefinch/pie">Pie </a></li>
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
      
    </ul>
    <a href="https://twitter.com/natethefinch"><i class="fa fa-twitter-square"></i></a>&nbsp;&nbsp; 
    
    
     <a href="https://github.com/natefinch"><i class="fa fa-github-square"></i></a>&nbsp;&nbsp; 
    
    <a href="https://plus.google.com/&#43;NateFinch"><i class="fa fa-google-plus"></i></a> 

    <p class="footnote">powered by <a href="http://gohugo.io">Hugo</a> <br/> &copy; 2017 Nate Finch. All rights reserved.</p>

  </div>
</div>

    <div class="content container">
<div class="posts">

      
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2017/11/comments/">
        Comment Your Code
      </a>
    </h1>

    <span class="post-date">Nov 17, 2017</span>

    


    

<p>There&rsquo;s a disturbing thread that pops up every once in a while where People On
The Internet say that comments are bad and the only reason you need them is
because you and/or your code aren&rsquo;t good enough.  I&rsquo;m here to say that&rsquo;s bullshit.</p>

<h2 id="code-sucks">Code Sucks</h2>

<p>They&rsquo;re not entirely wrong&hellip; your code isn&rsquo;t good enough.  Neither is mine or
anyone else&rsquo;s.  Code sucks.  You know when it sucks the most?  When you haven&rsquo;t
touched it in 6 months.  And you look back at the code and wonder &ldquo;what in the
hell was the author thinking?&rdquo; (and then you git blame and it&rsquo;s you&hellip; because
it&rsquo;s always you).</p>

<p>The premise of the anti-commenters is that the only reason you need comments is
because your code isn&rsquo;t &ldquo;clean&rdquo; enough.  If it were refactored better, named
better, written better, it wouldn&rsquo;t need that comment.</p>

<p>But of course, what is clean and obvious and well-written to you, today, while
the entire project and problem space are fully loaded in your brain&hellip; might not
be obvious to you, six months from now, or to the poor schmuck that has to debug
your code with their manager breathing down their neck because the CTO just ran
into a critical bug in prod.</p>

<p>Learning to look at a piece of code that you understand, and trying to figure out
how someone else might fail to understand it is a difficult skill to master. But
it is incredibly valuable&hellip; one that is nearly as important as the
ability to write good code in the first place.  In industry, almost no one codes
alone.  And even if you <em>do</em> code alone, you&rsquo;re gonna forget why you wrote some
of your code, or what exactly this gnarly piece of late night &ldquo;engineering&rdquo; is
doing.  And someday you&rsquo;re going to leave, and the person they hire to replace
you is going to have to figure out every little quirk that was in your head at
the time.</p>

<p>So, throwing in comments that may seem overly obvious in the moment is not a bad
thing. Sometimes it can be a huge help.</p>

<h2 id="avoiding-comments-often-makes-your-code-worse">Avoiding Comments Often Makes Your Code Worse</h2>

<p>Some people claim that if you remove comments, it makes your code better,
because you have to make your code clearer to compensate.  I call BS on this as
well, because I don&rsquo;t think anyone is realistically writing sub-par code and
then excusing it by slapping a comment on it (aside from <code>// TODO: this is a
temporary hack, I'll fix it later</code>).  We all write the best code we know how,
given the various external constraints (usually time).</p>

<p>The problem with refactoring your code to avoid needing comments is that
it often leads to <em>worse</em> code, not better.  The canonical example is factoring
out a complicated line of code into a function with a descriptive name.  Which
sounds good, except now you&rsquo;ve introduced a context switch for the person reading
the code.. instead of the actual line of code, they have a function call&hellip; they
have to scroll to where the function call is, remember and map the arguments
from the call site to the function declaration, and then map the return value
back to the call site&rsquo;s return.</p>

<p>In addition, the clarity of a function&rsquo;s name is only applicable to very trivial
comments.  Any comment that is more than a couple words cannot (or should not)
be made into a function name.  Thus, you end up with&hellip; a function with a
comment above it.</p>

<p>Indeed, even the existence of a very short function may cause confusion and more
complicated code.  If I see such a function, I may search to see where else that
function is used. If it&rsquo;s only used in one place, I then have to wonder if this
is actually a general piece of code that represents global logic&hellip; (e.g.
<code>NameToUserID</code>) or if this function is bespoke code that relies heavily on the
specific state and implementation of its call site and may well not do the right
thing elsewhere. By breaking it out into a function, you&rsquo;re in essence exposing
this implementation detail to the rest of the codebase, and this is not a
decision that should be taken lightly. Even if you know that this is not
actually a function anyone else should call, someone else <em>will</em> call it at some
point, even where not appropriate.</p>

<p>The problems with small functions are better detailed in Cindy Sridharan&rsquo;s <a href="https://medium.com/@copyconstruct/small-functions-considered-harmful-91035d316c29">medium post</a>.</p>

<p>We could dive into long variable names vs. short, but I&rsquo;ll stop and just
say that you can&rsquo;t save yourself by making variable names longer.  Unless your
variable name is the entire comment that you&rsquo;re avoiding writing, then you&rsquo;re
still losing information that could have been added to the comment.  And I think
we can all agee that <code>usernameStrippedOfSpacesWithDotCSVExtension</code> is a terrible
variable name.</p>

<p>I&rsquo;m not trying to say that you shouldn&rsquo;t strive to make your code clear and
obvious.  You definitely should.  It&rsquo;s the hallmark of a good developer.  But
code clarity is orthogonal to the existence of comments.  And good comments are
<em>also</em> the hallmark of a good developer.</p>

<h2 id="there-are-no-bad-comments">There are no bad comments</h2>

<p>The examples of bad comments often given in these discussions are trivially
bad, and almost never encountered in code written outside of a programming 101
class.</p>

<pre><code>// instantiate an error
var err error
</code></pre>

<p>Yes, clearly, this is not a useful comment.  But at the same time, it&rsquo;s not
really <em>harmful</em>.  It&rsquo;s some noise that is easily ignored when browsing the
code.  I would rather see a hundred of the above comments if it means the dev
leaves in one useful comment that saves me hours of head banging on keyboard.</p>

<p>I&rsquo;m pretty sure I&rsquo;ve never read any code and said &ldquo;man, this code would be so
much easier to understand if it weren&rsquo;t for all these comments.&rdquo;  It&rsquo;s nearly
100% the opposite.</p>

<p>In fact, I&rsquo;ll even call out some code that I think is egregious in its lack of
comments - the Go standard library.  While the code may be very correct and well
structured.. in many cases, if you don&rsquo;t have a deep understanding of what the
code is doing <em>before</em> you look at the it, it can be a challenge to understand
why it&rsquo;s doing what it&rsquo;s doing.  A sprinkling of comments about what the logic
is doing and why would make a lot of the go standard library a lot easier to
read.  In this I am specifically talking about comments inside the
implementation, not doc comments on exported functions in general (those are
generally pretty good).</p>

<h2 id="any-comment-is-better-than-no-comment">Any comment is better than no comment</h2>

<p>Another chestnut the anti-commenters like to bring out is the wisdom can be
illustrated with a pithy image:</p>


<figure >
    
        <img src="/comments.jpg" width="200" />
    
    
</figure>


<p>Ah, hilarious, someone updated the contents and didn&rsquo;t update the comment.</p>

<p>But, that was a problem 20 years ago, when code reviews were not (generally) a
thing.  But they are a thing now.  And if checking that comments match the
implementation isn&rsquo;t part of your code review process, then you should probably
review your code review process.</p>

<p>Which is not to say that mistakes can&rsquo;t be made&hellip; in fact I filed a &ldquo;comment
doesn&rsquo;t match implementation&rdquo; bug just yesterday.  The saying goes something
like &ldquo;no comment is better than an incorrect comment&rdquo; which sounds obviously
true, except when you realize that if there is no comment, then devs will just
<em>guess</em> what the code does, and probably be wrong more often than a comment would
be wrong.</p>

<p>Even if this <em>does</em> happen, and the code has changed, you still have valuable
information about what the code used to do.  Chances are, the code still does
basically the same thing, just slightly differently.  In this world of
versioning and backwards compatbility, how often does the same function get
drastically changed in functionality while maintaining the same name and
signature?  Probably not often.</p>

<p>Take the bug I filed yesterday&hellip; the place where we were using the function was
calling <code>client.SetKeepAlive(60)</code>.  The comment on SetKeepAlive was
&ldquo;SetKeepAlive will set the amount of time (in seconds) that the client should
wait before sending a PING request&rdquo;. Cool, right? Except I noticed that
SetKeepAlive takes a time.Duration.  Without any other units specified for the
value of 60, Go&rsquo;s duration type defaults to&hellip;. nanoseconds.  Oops.  Someone had
updated the function to take a Duration rather than an Int.  Interestingly, it
<em>did</em> still round the duration down to the nearest second, so the comment was
not incorrect per se, it was just misleading.</p>

<h2 id="why">Why?</h2>

<p>The most important comments are the <em>why</em> comments.  Why is the code doing what
it&rsquo;s doing?  Why must the ID be less than 24 characters?  Why are we hiding this
option on Linux?  etc.  The reason these are important is that you can&rsquo;t figure
out the why by looking at the code.  They document lessons learned by the devs,
outside constraints imposed by the business, other systems, etc. These comments
are invaluable, and almost impossible to capture in other ways (e.g. function
names should document what the function does, not why).</p>

<p>Comments that document <em>what</em> the code is doing are less useful, because you can
generally always figure out what the code is doing, given enough time and
effort.  The code tells you what it is doing, by definition.  Which is not to
say that you should never write <em>what</em> comments.  Definitely strive to write the
clearest code you can, but comments are free, so if you think someone might
misunderstand some code or otherwise have difficulty knowing what&rsquo;s going on,
throw in a comment.  At least, it may save them a half hour of puzzling through
your code, at best it may save them from changing it or using it in incorrect
ways that cause bugs.</p>

<h2 id="tests">Tests</h2>

<p>Some people think that tests serve as documentation for functions.  And, in a
way, this is true.  But they&rsquo;re generally very low on my list of effective
documentation.  Why?  Well, because they have to be incredibly precise, and thus
they are verbose, and cover a narrow strip of functionality.  Every test tests
exactly one specific input and one specific output.  For anything other than the
most simple function, you probably need a bunch of code to set up the inputs and
construct the outputs.</p>

<p>For much of programming, it&rsquo;s easier to describe briefly what a function does
than to write code to test what it does.  Often times my tests will be multiple
times as many lines of code as the function itself&hellip; whereas the doc comment on
it may only be a few sentences.</p>

<p>In addition, tests only explain the <em>what</em> of a function. What is it supposed to
do?  They don&rsquo;t explain why, and why is often more important, as stated above.</p>

<p>You should definitely test your code, and tests can be useful in figuring out
the expected behavior of code in some edge cases&hellip; but if I have to read tests
to understand your code in general, then that&rsquo;s red flag that you really need to
write more/better comments.</p>

<h2 id="conclusion">Conclusion</h2>

<p>I feel like the line between what&rsquo;s a useful comment and what&rsquo;s not is difficult
to find (outside of trivial examples), so I&rsquo;d rather people err on the
side of writing too many comments.  You never know who may be reading your code
next, so do them the favor you wish was done for you&hellip; write a bunch of
comments.  Keep writing comments until it feels like too many, then write a few
more.  That&rsquo;s probably about the right amount.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2017/08/lies/">
        Code Must Never Lie
      </a>
    </h1>

    <span class="post-date">Aug 29, 2017</span>

    


    <blockquote>
<p>If you tell the truth, you don’t have to remember anything.</p>

<p>—Mark Twain</p>
</blockquote>

<p>In a code review recently, I asked the author to change some of their asserts to
requires. Functions in testify&rsquo;s assert package allow the test to continue,
whereas those in the require package end the test immediately. Thus, you use
require to avoid trying to continue running a test when we know it&rsquo;ll be in a
bad state.  (side note: don&rsquo;t use an assert package, but that&rsquo;s another post)
Since testify&rsquo;s assert and require packages have the same interface, the
author&rsquo;s solution was to simply change the import thusly:</p>

<pre><code>import (
    assert &quot;github.com/stretchr/testify/require&quot;
)
</code></pre>

<p>Bam, now all the assert.Foo calls would stop the test immediately, and we didn&rsquo;t
need a big changelist changing every use of assert to require.  All good,
right?</p>

<p>No.</p>

<p><strong>Hell No.</strong></p>

<p>Why? Because it makes the code lie.  Anyone familiar with the testify package
understands the difference between assert and require.  But we&rsquo;ve now made code
that <em>looks like</em> an assert, but is actually a require.  People who are 200
lines down in a test file may well not realize that those asserts are actually
requires. They&rsquo;ll assume the test function will continue processing after an
assert fails.  They&rsquo;ll be wrong, and they could accidentally write incorrect
tests because of it - tests that fail with confusing error messages.</p>

<p>This is true in general - <strong>code must never lie</strong>.  This is a cardinal sin
amongst programmers.  This is an extension of the mantra that code should be
written to be read.  If code looks like it&rsquo;s doing one thing when it&rsquo;s actually
doing something else, someone down the road will read that code and
misunderstand it, and use it or alter it in a way that causes bugs. If they&rsquo;re
lucky, the bugs will be immediate and obvious. If they&rsquo;re unlucky, they&rsquo;ll be
subtle and only be figured out after a long debugging session and much head
banging on keyboard. That someone might be you, even if it was your code in
the first place.</p>

<p>If, for some reason, you have to make code that lies (to fulfill an interface or
some such), document the hell out of it.  Giant yelling comments that can&rsquo;t be
missed during a 2am debugging session.  Because chances are, that&rsquo;s when you&rsquo;re
going to look at this code next, and you might forget that saveToMemory()
function actually saves to a database in AWS&rsquo;s Antarctica region.</p>

<p>So, don&rsquo;t lie.  Furthermore, try not to even mislead.  Humans make assumptions
all the time, it&rsquo;s built into how we perceive the world.  As a coder, it&rsquo;s your
job to anticipate what assumptions a reader may have, and ensure that they are
not incorrect, or if they are, do your best to disabuse them of their incorrect
assumptions.</p>

<p>If possible, don&rsquo;t resort to comments to inform the reader, but instead,
structure the code itself in such a way as to indicate it&rsquo;s not going to behave
the way one might expect.  For example, if your type has a <code>Write(b []byte)
(int, error)</code> method that is not compatible with io.Writer, consider calling it
something other than Write&hellip; because everyone seeing <code>foo.Write</code> is going to
assume that function will work like an io.Write.  Instead maybe call it WriteOut
or PrintOut or anything but Write.</p>

<p>Misleading code can be even more subtle than this.  In a recent code review, the
author wrapped a single DB update in a transaction.  This set off
alarm bells for me as a reviewer.  As a reader, I assumed that the code must be
saving related data in multiple tables, and that&rsquo;s why a transaction was needed.
Turned out, the code didn&rsquo;t actually need the transaction, it was just written
that way to be consistent with some other code we had.  Unfortunately, in this
case, being consistent was actually confusing&hellip; because it caused the reader to
make assumptions that were ultimately incorrect.</p>

<p>Do the poor sap that has to maintain your code 6 months or two years down the
road a favor - don&rsquo;t lie. Try not to mislead.  Because even if that poor sap
isn&rsquo;t you, they still don&rsquo;t deserve the 2am headache you&rsquo;ll likely be
inflicting.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2017/07/adapting-funcs/">
        Adapting Functions
      </a>
    </h1>

    <span class="post-date">Jul 15, 2017</span>

    


    <p>A question came up at Gophercon about using functions as arguments, and what to
do when you have a function that you want to use that doesn&rsquo;t quite match the
signature.  Here&rsquo;s an example:</p>

<pre><code>type Translator func(string) string

func RunTwice(translate Translator, input string) string {
    return translate(translate(input))
}
</code></pre>

<p>Now, what if you want to use RunTwice with a function that needs more inputs
than just a string?</p>

<pre><code>func Append(orig, suffix string) string {
    return orig + suffix
}

func do() {
    orig := &quot;awesome&quot;
    bang := &quot;!&quot;
    s := RunTwice(Append(orig, )) // wait, that won't work
    fmt.Println(s)
}

</code></pre>

<p>The answer is the magic of closures. Closures are anonymous functions that
&ldquo;close over&rdquo; or save copies of all local variables so they can be used later.
You can write a closure that captures the bang, and returns a function that&rsquo;ll
have the Translator signature.</p>

<pre><code>func do() string {
    orig := &quot;awesome&quot;
    bang := &quot;!&quot;
    bangit := func(s string) string {
        return Append(s, bang)
    }
    return RunTwice(bangit(orig))
}
</code></pre>

<p>Yay, that works.  But it&rsquo;s not reusable outside the do function.  That may be
fine, it may not. If you want to do it in a reusable way (like, a lot of people
may want to adapt Append to return a Translator, you can make a dedicated
function for it like this:</p>

<pre><code>func AppendTranslator(suffix string) Translator {
    return func(s string) string {
        return Append(s, suffix)
    }
}
</code></pre>

<p>In AppendTranslator, we return a closure that captures the suffix, and returns a
function that, when called, will append that suffix to the string passed to the
Translator.</p>

<p>And now you can use AppendTranslator with RunTwice.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2017/03/3.5yrs-500k-lines-of-go/">
        3.5 Years, 500k Lines of Go (Part 1)
      </a>
    </h1>

    <span class="post-date">Mar 24, 2017</span>

    
      
      <p class="seriesname">Series: <a href="https://npf.io/series/3.5-years-of-go">3.5 Years of Go</a></p>
    


    

<p>January 31st 2017 was my last day at Canonical, after working for 3.5 years on
what is one of the largest open source projects written in Go -
<a href="https://github.com/juju/juju">Juju</a>.</p>

<p>As of this writing, the main repo for Juju, <a href="http://github.com/juju/juju">http://github.com/juju/juju</a>, is 3542
files, with 540,000 lines of Go code (not included in that number is 65,000
lines of comments).  Counting all dependencies except the standard library, Juju
is 9523 files, holding 1,963,000 lines of Go code (not including comments, which
clock in at 331,000 lines).</p>

<p>These are a few of my lessons learned from my roughly 7000 hours working on this
project.</p>

<p>Notably, not everyone on the Juju team would agree with all of these, and the
codebase was so huge that you could work for a year and not see 2/3rds of the
codebase.  So take the following with a grain of salt.</p>

<h2 id="about-juju">About Juju</h2>

<p>Juju is service orchestration tool, akin to Nomad or Kubernetes and similar
tools.  Juju consists (for the most part) of exactly two binaries: a client and
a server.  The server can run in a few different modes (it used to be multiple
binaries, but they were 99% the same code, so it was easier to just make one
binary that can be shipped around).  The server runs on a machine in the cloud
of your choice, and copies of the binary are installed on new machines in the
cloud so they can be controlled by the central server.  The client and the
auxiliary machines talk to the main server via RPC over websockets.</p>

<p>Juju is a monolith.  There are no microservices, everything runs in a single
binary.  This actually works fairly well, since Go is so highly concurrent,
there&rsquo;s no need to worry about any one goroutine blocking anything else.  It
makes it convenient to have everything in the same process.  You avoid
serialization and other interprocess communication overhead.  It does lend
itself to making code more interdependent, and separations of concerns was not
always the highest priority.  However, in the end, I think it was much easier to
develop and test a monolith than it would have been if it were a bunch of
smaller services, and proper layering of code and encapsulation can help a lot
with spaghetti code.</p>

<h2 id="package-management">Package Management</h2>

<p>Juju did not use vendoring.  I think we should have, but the project was started
before any of the major vendoring tools were out there, and switching never felt
like it was worth the investment of time. Now, we did use Roger Peppe&rsquo;s
<a href="https://github.com/rogpeppe/godeps">godeps</a> (not the same as godep btw) to pin
revisions. The problem is that it messes with other repos in your GOPATH,
setting them to a specific commit hash, so if you ever go to build something
else that doesn&rsquo;t use vendoring, you&rsquo;d be building from a non-master branch.
However, the revision pinning gave us repeatable builds (so long as no one did
anything truly heinous to their repo), and it was basically a non-issue <em>except</em>
that the file that holds the commit hashes was continually a point of merge
conflicts.  Since it changed so often, by so many developers, it was bound to
happen that two people change the same or adjacent lines in the file.  It became
such a problem I started working on an automatic resolution tool (since godeps
holds the commit date of the hash you&rsquo;re pinning, you could almost always just
pick the newer hash).  This is still a problem with glide and any similar tool
that stores dependency hashes in a single file.  I&rsquo;m not entirely sure how to
fix it.</p>

<p>Overall, I never felt that package management was a huge issue.  It was a minor
thing in our day to day work&hellip; which is why I always thought it was weird to
read all the stories about people rejecting Go because of lack of package
management solutions.  Because most third party repos maintained stable APIs for
the same repo, and we could pin our code to use a specific commit&hellip; it just was
not an issue.</p>

<h2 id="project-organization">Project Organization</h2>

<p>Juju is 80% monorepo (at github.com/juju/juju, with about 20% code that exists
in separate repos (under github.com/juju).  The monorepo section has pros and
cons&hellip; It is easy to do sweeping changes across the codebase, but it also means
that it doesn&rsquo;t feel like you need to maintain a stable API in
<code>foo/bar/baz/bat/alt/special</code> &hellip; so we didn&rsquo;t.  And that means that it would be
essentially insane for anyone to actually import any package from under the main
monorepo and expect it to continue to exist in any meaningful way at any future
date.  Vendoring would save you, but if you ever needed to update, good luck.</p>

<p>The monorepo also meant that we were less careful about APIs, less careful about
separation of concerns, and the code was more interdependent than it possibly
could have been.  Not to say we were careless, but I feel like things outside
the main Juju repo were held to a higher standard as far as separation of
concerns and the quality and stability of the APIs.  Certainly the documentation
for external repos was better, and that might be enough of a determining factor by
itself.</p>

<p>The problem with external repos was package management and keeping changes
synchronized across repos.  If you updated an external repo, you needed to then
check in changes to the monorepo to take advantage of that.  Of course, there&rsquo;s
no way to make that atomic across two github repos.  And sometimes the change to
the monorepo would get blocked by code reviews or failing tests or whatever,
then you have potentially incompatible changes sitting in an external repo,
ready to trip up anyone who might decide to make their own changes to the
external repo.</p>

<p>The one thing I will say is that utils repos are nefarious.  Many times we&rsquo;d want to
backport a fix in some subpackage of our utils repo to an earlier version of
Juju, only to realize that many many other unrelated changes get pulled along
with that fix, because we have so much stuff in the same repo.  Thus we&rsquo;d have
to do some heinous branching and cherry picking and copypasta, and it&rsquo;s bad and don&rsquo;t do it.
Just say no to utils packages and repos.</p>

<h2 id="overall-simplicity">Overall Simplicity</h2>

<p>Go&rsquo;s simplicity was definitely a major factor in the success of the Juju
project.  Only about one third of the developers we hired had worked with Go
before. The rest were brand new.  After a week, most were perfectly proficient.
The size and complexity of the product were a much bigger problem for developers
than the language itself.  There were still some times when the more experienced
Go developers on the team would get questions about the best way to do X in Go,
but it was fairly rare.  Contrast this to my job before working on C#, where I
was constantly explaining different parts of the language or why something works
one way and not another way.</p>

<p>This was a boon to the project in that we could hire good developers in general,
not just those who had experience in the language.  And it meant that the
language was never a barrier to jumping into a new part of the code.  Juju was
huge enough that no one person could know the fine details of the whole thing.
But just about anyone could jump into a part of the code and figure out what 100
or so lines of code surrounding a bug were supposed to do, and how they were
doing it (more or less).  Most of the problems with learning a new part of the
code were the same as it would have been in any language - what is the architecture, how
is information passed around, what are the expectations.</p>

<p>Because Go has so little magic, I think this was easier than it would have
been in other languages.  You don&rsquo;t have the magic that other languages have
that can make seemingly simple lines of code have unexpected functionality.  You
never have to ask &ldquo;how does this work?&rdquo;, because it&rsquo;s just plain old Go code.
Which is not to say that there isn&rsquo;t still a lot of complex code with a lot of
cognitive overhead and hidden expectations and preconditions&hellip; but it&rsquo;s at
least not intentionally hidden behind language features that obscure the basic
workings of the code.</p>

<h2 id="testing">Testing</h2>

<h3 id="test-suites">Test Suites</h3>

<p>In Juju we used Gustavo Nieyemer&rsquo;s <a href="http://gopkg.in/check.v1">gocheck</a> to run
our tests.  Gocheck’s test suite style encouraged full stack testing by reducing
the developer overhead for spinning up a full Juju server and mongo database
before each test.  Once that code was written, as huge as it was, you could just
embed that “base suite” in your test suite struct, and it would automatically do
all the dirty work for you.  This meant that our unit tests took almost 20
minutes to run even on a high end laptop, because they were doing so much for
each test.  It also made them brittle (because they were running so much code)
and hard to understand and debug.  To understand why a test was passing or
failing, you had to understand all the code that ran before the open brace of
your test function, and because it was easy to embed a suite within a suite,
there was often a LOT that ran before that open brace.</p>

<p>In the future, I would stick with the standard library for testing instead.  I
like the fact that test with the standard library are written just like normal
go code, and I like how explicit the dependencies have to be. If you want to run
code at the beginning of your test, you can just put a method there… but you
have to put a method there.</p>

<h3 id="time-in-a-bottle"><code>time</code> in a bottle</h3>

<p>The time package is the bane of tests and testable code.  If you have code that
times out after 30 seconds, how do you test it?  Do you make a test that takes
30 seconds to run?  Do the rest of the tests take 30 seconds to run if something
goes wrong?  This isn&rsquo;t just related to time.Sleep but time.After or
time.Ticker&hellip;. it&rsquo;s all a disaster during tests.  And not to mention that test
code (especially when run under -race) can go a lot slower than your code does
in production.</p>

<p>The cure is to mock out time&hellip; which of course is non-trivial because the time
package is just a bunch of top level functions.  So everywhere that was using
the time package now needs to take your special clock interface that wraps time
and then for tests you pass in a fake time that you can control.  This tooks us
a long time pull the trigger on and longer still to propagate the changes
throughout our code.  For a long time it was a constant source of flakey tests.
Tests that would pass most of the time, but if the CI machine were slow that
day, some random test would fail.  And when you have hundreds of thousands of
lines of tests, chances are SOMETHING is going to fail, and chances are it&rsquo;s not
the same thing as what failed last time.  Fixing flakey tests was a constant
game of whack-a-mole.</p>

<h2 id="cross-compilation-bliss">Cross Compilation Bliss</h2>

<p>I don&rsquo;t have the exact number of combinations, but the Juju server was built to
run on Windows and Linux (Centos and Ubuntu), and across many more
architectures than just amd64, including some wacky ones like ppc64le, arm64,
and s390x.</p>

<p>In the beginning, Juju used gccgo for builds that the gc compiler did not
support.  This was a source of a few bugs in Juju, where gccgo did something
subtly wacky.  When gc was updated to support all architectures, we were very
happy to leave the extra compiler by the wayside and be able to work with just
gc.</p>

<p>Once we switched to gc, there were basically zero architecture-specific bugs.
This is pretty awesome, given the breadth of architectures Juju supported, and
the fact that usually the people using the wackier ones were big companies that
had a lot of leverage with Canonical.</p>

<h3 id="multi-os-mistakes">Multi-OS Mistakes</h3>

<p>In the beginning when we were ramping up Windows support, there were a few OS
specific bugs (we all developed on Ubuntu, and so Windows bugs often didn&rsquo;t get
caught until CI ran).  They basically boiled down to two common mistakes related
to filesystems.</p>

<p>The first was assuming forward slashes for paths in tests.  So, for example, if
you know that a config file should be in the “juju” subfolder and called
“config.yml”, then your test might check that the file’s path is <code>folder +
“/juju/config.yml”</code>  - except that on Windows it would be <code>folder +
“\juju\config.yml”</code>.</p>

<p>When making a new path, even in tests, use <code>filepath.Join</code>, not <code>path.Join</code> and
definitely not by concatenating strings and slashes. filepath.Join will do the
right thing with slashes for the OS.  For comparing paths, always use
<code>path.ToSlash</code> to convert a filepath to a canonical string that you can then
compare to.</p>

<p>The other common mistake was for linux developers to assume you can delete/move
a file while it&rsquo;s open.  This doesn&rsquo;t work on Windows, because Windows locks the
file when it&rsquo;s open.  This often came in the form of a <code>defer file.Delete()</code>
call, which would get FIFO&rsquo;d before the deferred <code>file.Close()</code> call, and thus
would try to delete the file while it was still open.  Oops.  One fix is to just
always call file.Close() before doing a move or delete.  Note that you can call
Close multiple times on a file, so this is safe to do even if you also have a
defer file.Close() that’ll fire at the end of the function.</p>

<p>None of these were difficult bugs, and I credit the strong cross platform
support of the stdlib for making it so easy to write cross platform code.</p>

<h2 id="error-handling">Error Handling</h2>

<p>Go&rsquo;s error handling has definitely been a boon to the stability of Juju. The
fact that you can tell where any specific function may fail makes it a lot
easier to write code that expects to fail and does so gracefully.</p>

<p>For a long time, Juju just used the standard errors package from the stdlib.
However, we felt like we really wanted more context to better trace the path of
the code that caused the error, and we thought it would be nice to keep more
detail about an error while being able to add context to it (for example, using
fmt.Errorf losing the information from the original error, like if it was an
os.NotFound error).</p>

<p>A couple years ago we went about designing an errors package to capture more
context without losing the original error information. After a lot of
bikeshedding and back and forth, we consolidated our ideas in
<a href="https://github.com/juju/errors">https://github.com/juju/errors</a>.  It&rsquo;s not a perfect library, and it has grown
bloated with functions over the years, but it was a good start.</p>

<p>The main problem is that it requires you to always call errors.Trace(err) when
returning an error to grab the current file and line number to produce a
stack-trace like thing.  These days I would choose Dave Cheney&rsquo;s
<a href="https://github.com/pkg/errors">github.com/pkg/errors</a>, which grabs a stack
trace at creation time and avoid all the tracing.  To be honest, I haven&rsquo;t found
stack traces in errors to be super useful.  In practice, unforeseen errors still
have enough context just from fmt.Errorf(&ldquo;while doing foo: %v&rdquo;, err) that you
don&rsquo;t really need a stack trace most of the time.  Being able to investigate
properties of the original error can sometimes come in handy, though probably
not as often as you think.  If foobar.Init() returns something that&rsquo;s an
os.IsNotFound, is there really anything your code can do about it?  Most of the
time, no.</p>

<h2 id="stability">Stability</h2>

<p>For a huge project, Juju is very stable (which is not to say that it didn&rsquo;t have
plenty of bugs&hellip; I just mean it almost never <em>crashed</em> or grossly
malfunctioned).  I think a lot of that comes from the language.  The company
where I worked before Canonical had a million line C# codebase, and it would
crash with null reference exceptions and unhandled exceptions of various sorts
fairly often. I honestly don&rsquo;t think I ever saw a nil pointer panic from
production Juju code, and only occasionally when I was doing something really
dumb in brand new code during development.</p>

<p>I credit this to go’s pattern of using multiple returns to indicate errors.  The
<code>foo, err :=</code> pattern and always always checking errors really makes for very
few nil pointers being passed around.  Checking an error before accessing the
other variable(s) returned is a basic tenet of Go, so much so that we document
the exceptions to the rule.  The extra error return value cannot be ignored or
forgotten thanks to unused variable checks at compile time.  This makes the
problem of nil pointers in Go fairly well mitigated, compared to other similar
languages.</p>

<h2 id="generics">Generics</h2>

<p>I&rsquo;m going to make this section short, because, well, you know.  Only once or
twice did I ever personally feel like I missed having generics while working on
Juju.  I don&rsquo;t remember ever doing a code review and wishing for generics for
someone else&rsquo;s code.  I was mostly happy not to have to grok the cognitive
complexity I&rsquo;d come to be familiar with in C# with generics.  Interfaces are
good enough 99% of the time.  And I don&rsquo;t mean <code>interface{}</code>.  We used
<code>interface{}</code> rarely in Juju, and almost always it was because some sort of
serialization was going on.</p>

<h2 id="next-time">Next Time</h2>

<p>This is already a pretty long post, so I think I&rsquo;ll cap it here.  I have a lot
of more specific things that I can talk about&hellip; about APIs, versioning, the
database, refactoring, logging, idioms, code reviews, etc.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2016/10/reusable-commands/">
        Writing Go Applications with Reusable Logic
      </a>
    </h1>

    <span class="post-date">Oct 18, 2016</span>

    
      
      <p class="seriesname">Series: <a href="https://npf.io/series/writing-go-applications">Writing Go Applications</a></p>
    


    

<p>Writing libraries in Go is a relatively well-covered topic, I think&hellip; but I see
a lot fewer posts about writing commands.  When it comes down to it, all Go code
ends up in a command.  So let&rsquo;s talk about it!  This will be the first in a
series, since I ended up having a lot more to say than I realized.</p>

<p>Today I&rsquo;m going to focus on basic project layout, with the aims of optimizing
for reusability and testability.</p>

<p>There are three unique bits about commands that influence how I structure my
code when writing a command rather than a library:</p>

<h2 id="package-main">Package main</h2>

<p>This is the only package a go program must have.  However, aside from telling
the go tool to produce a binary, there&rsquo;s one other unique thing about package
main - no one can import code from it.  That means that any code you put in
package main can not be used directly by another project, and that makes the OSS
gods sad.  Since one of the main reasons I write open source code is so that
other developers may use it, this goes directly against my desires.</p>

<p>There have been many times when I&rsquo;ve thought &ldquo;I&rsquo;d love to use the logic behind X
Go binary as a part of my code&rdquo;.  If that logic is in package main, you can&rsquo;t.</p>

<h2 id="os-exit">os.Exit</h2>

<p>If you care about producing a binary that does what users expect, then you
should care about what exit code your binary exits with.  The only way to do
that is to call os.Exit (or call something that calls os.Exit, like log.Fatal).</p>

<p>However, you can&rsquo;t test a function that calls os.Exit.  Why?  Because calling
os.Exit during a test <em>exits the test executable</em>.  This is quite hard to figure
out if you end up doing it by accident (which I know from personal experience).
When running tests, no tests actually fail, the tests just exit sooner than they
should, and you&rsquo;re left scratching your head.</p>

<p>The easiest thing to do is <em>don&rsquo;t call os.Exit</em>.  Most of your code shouldn&rsquo;t be
calling os.Exit anyway&hellip; someone&rsquo;s going to get real mad if they import your
library and it randomly causes their application to terminate under some
conditions.</p>

<p>So, only call os.Exit in exactly one place, as near to the &ldquo;exterior&rdquo; of your
application as you can get, with minimal entry points.  Speaking of which&hellip;</p>

<h2 id="func-main">func main()</h2>

<p>It&rsquo;s is the one function all go commands must have.  You&rsquo;d think that
everyone&rsquo;s func main would be different, after all, everyone&rsquo;s application is
different, right?  Well, it turns out, if you really want to make your code
testable and reusable, there&rsquo;s really only approximately one right answer to
&ldquo;what&rsquo;s in your main function?&rdquo;</p>

<p>In fact, I&rsquo;ll go one step further, I think there&rsquo;s only approximately one right
answer to &ldquo;what&rsquo;s in your package main?&rdquo; and that&rsquo;s this:</p>

<pre><code class="language-go">// command main documentation here.
package main

import (
    &quot;os&quot;

    &quot;github.com/you/proj/cli&quot;
)
func main{
    os.Exit(cli.Run())
}
</code></pre>

<p>That&rsquo;s it.  This is approximately the most minimal code you can have in a useful
package main, thereby wasting no effort on code that others can&rsquo;t reuse.  We
isolated os.Exit to a single line function that is the very exterior of our
project, and effectively needs no testing.</p>

<h2 id="project-layout">Project Layout</h2>

<p>Let&rsquo;s get a look at the total package layout:</p>

<pre><code>/home/you/src/github.com/you/proj $ tree
.
├── cli
│   ├── parse.go
│   ├── parse_test.go
│   └── run.go
├── LICENSE
├── main.go
├── README.md
└── run
    ├── command.go
    └── command_test.go
</code></pre>

<p>We know what&rsquo;s in main.go&hellip; and in fact, main.go is the only go file in the
main package. LICENSE and README.md should be self-explanatory. (Always
use a license!  Otherwise many people won&rsquo;t be able to use your code.)</p>

<p>Now we come to the two subdirectories, run and cli.</p>

<h3 id="cli">CLI</h3>

<p>The cli package contains the command line parsing logic.  This is where you
define the UI for your binary.  It contains flag parsing, arg parsing, help
text, etc.</p>

<p>It also contains the code that returns the exit code to func main (which gets
sent to os.Exit).  Thus, you can test exit codes returned from those functions,
instead of trying to test exit codes your binary as a whole produces.</p>

<h3 id="run">Run</h3>

<p>The run package contains the meat of the logic of your binary.  You should write
this package as if it were a standalone library.  It should be far removed from
any thoughts of CLI, flags, etc.  It should take in structured data and return
errors.  Pretend it might get called by some other library, or a web service, or
someone else&rsquo;s binary.  Make as few assumptions as possible about how it&rsquo;ll be
used, just as you would a generic library.</p>

<p>Now, obviously, larger projects will require more than one directory.  In fact,
you may want to split out your logic into a separate repo.  This kind of depends
on how likely you think it&rsquo;ll be that people want to reuse your logic.  If you
think it&rsquo;s highly likely, I recommend making the logic a separate directory. In
my mind, a separate directory for the logic shows a stronger committment to
quaity and stability than some random directory nestled deep in a repo
somewhere.</p>

<h2 id="putting-it-together">Putting it together</h2>

<p>The cli package forms a command line frontend for the logic in the run package.
If someone else comes along, sees your binary, and wants to use the logic behind
it for a web API, they can just import the run package and use that logic
directly.  Likewise, if they don&rsquo;t like your CLI options, they can easily write
their own CLI parser and use it as a frontend to the run package.</p>

<p>This is what I mean about reusable code.  I never want someone to have to hack
apart my code to get more use out of it.  And the best way to do that is to
separate the UI from the logic.  This is the key part.  <strong>Don&rsquo;t let your UI
(CLI) concepts leak into your logic.</strong>  This is the best way to keep your logic
generic, and your UI manageable.</p>

<h3 id="larger-projects">Larger Projects</h3>

<p>This layout is good for small to medium projects.  There&rsquo;s a single binary that
is in the root of the repo, so it&rsquo;s easier to go-get than if it&rsquo;s under multiple
subdirectories.  Larger projects pretty much throw everything out the window.
They may have multiple binaries, in which case they can&rsquo;t all be in the root of
the repo.  However, such projects usually also have custom build steps and
require more than just go-get (which I&rsquo;ll talk about later).</p>

<p>More to come soon.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2016/10/vanity-imports-with-hugo/">
        Vanity Imports with Hugo
      </a>
    </h1>

    <span class="post-date">Oct 16, 2016</span>

    


    <p>When working on <a href="https://github.com/natefinch/gorram">Gorram</a>, I decided I
wanted to release it via a vanity import path.  After all, that&rsquo;s half the
reason I got npf.io in the first place (an idea blatantly stolen from Russ Cox&rsquo;s
rsc.io).</p>

<p>What is a vanity import path?  It is explained in the go get
<a href="https://golang.org/cmd/go/#hdr-Remote_import_paths, though it
isn't given that name (or any name, unfortunately">documentation</a>.  If you&rsquo;re not hosted on one
of the well known hosting sites (github, bitbucket, etc), go get has to figure
out how to get your code. How it does this is fairly ingenious - it performs an
http GET of the import path (first https then http) and looks for specific meta
elements in the page&rsquo;s header.  The header elements tells go get what type of
VCS is being used and what address to use to get the code.</p>

<p>The great thing about this is that it removes the dependency of your code on any
one code hosting site. If you want to move your code from github to bitbucket,
you can do that without breaking anyone.</p>

<p>So, the first thing you need to host your own vanity imports is something that
will respond to those GET requests with the right response.  You could do
something complicated like a special web application running on a VM in the
cloud, but that costs money and needs maintenance.  Since I already had a Hugo
website (running for free on github pages), I wanted to see if I could use that.
It&rsquo;s a slightly more manual process, but the barrier of entry is a lot lower and
it works on any free static hosting (like github pages).</p>

<p>So what I want is to have <code>go get npf.io/gorram</code>, actually download the code
from <a href="https://github.com/natefinch/gorram">https://github.com/natefinch/gorram</a>.  For that, I need
<a href="https://npf.io/gorram">https://npf.io/gorram</a> to serve up this meta element:</p>

<p><code>&lt;meta name=&quot;go-import&quot; content=&quot;npf.io/gorram git https://github.com/natefinch/gorram&quot;&gt;</code></p>

<p>or more generally:</p>

<p><code>&lt;meta name=&quot;go-import&quot; content=&quot;import-prefix vcs repo-root&quot;&gt;</code></p>

<p>Where import-prefix is a string that matches a prefix of the import statement
used in your code, vcs is the type of source control used, and repo-root is the
root of the VCS repo where your code lives.</p>

<p>What&rsquo;s important to note here is that these should be set this way for packages
in subdirectories as well.  So, for npf.io/gorram/run, the meta tag should still
be as above, since it matches a prefix of the import path, and the root of the
repo is still github.com/natefinch/gorram.  (We&rsquo;ll get to how to handle
subdirectories later.)</p>

<p>You need a page serving that meta tag to live at the exact same place as the import
statement&hellip; that generally will mean it needs to be in the root of your domain
(I know that I, personally don&rsquo;t want to see <code>go get npf.io/code/gorram</code> when I
could have <code>go get npf.io/gorram</code>).</p>

<p>The easiest way to do this and keep your code organized is to put all your pages
for code into a new directory under content called &ldquo;code&rdquo;.  Then you just need
to set the &ldquo;permalink&rdquo; for the code type in your site&rsquo;s config file thusly:</p>

<pre><code class="language-toml">[Permalinks]
	code = &quot;/:filename/&quot;
</code></pre>

<p>Then your content&rsquo;s filename (minus extension) will be used as its url relative
to your site&rsquo;s base URL. Following the same example as above, I have
content/code/gorram.md which will make that page now appear at npf.io/gorram.</p>

<p>Now, for the content.  I don&rsquo;t actually want to have to populate this page with
content&hellip; I&rsquo;d rather people just get forwarded on to github, so that&rsquo;s what
we&rsquo;ll do, by using a refresh header.  So here&rsquo;s our template, that&rsquo;ll live under layouts/code/single.html:</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
  &lt;meta name=&quot;go-import&quot; content=&quot;npf.io{{substr .RelPermalink 0 -1}} git {{.Params.vanity}}&quot;&gt;
  &lt;meta name=&quot;go-source&quot; content=&quot;npf.io{{substr .RelPermalink 0 -1}} {{.Params.vanity}} {{.Params.vanity}}/tree/master{/dir} {{.Params.vanity}}/blob/master{/dir}/{file}#L{line}&quot;&gt;
  &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url={{.Params.vanity}}&quot;&gt;
&lt;/head&gt;
&lt;/html&gt;
</code></pre>

<p>This will generate a page that will auto-forward anyone who hits it on to your
github account.  Now, there&rsquo;s one more (optional but recommended) piece - the
go-source meta header.  This is only relevant to godoc.org, and tells godoc how
to link to the sourcecode for your package (so links on godoc.org will go
straight to github and not back to your vanity url, see more details <a href="https://github.com/golang/gddo/wiki/Source-Code-Links">here</a>).</p>

<p>Now all you need is to put a value of <code>vanity = https://github.com/you/yourrepo</code>
in the frontmatter of the correct page, and the template does the rest. If your
repo has multiple directories, you&rsquo;ll need a page for each directory (such as
npf.io/gorram/run).  This would be kind of a drag, making the whole directory
struture with content docs in each, except there&rsquo;s a trick you can do here to
make that easier.</p>

<p>I recently landed a change in Hugo that lets you customize the rendering of
alias pages.  Alias pages are pages that are mainly used to redirect people from
an old URL to the new URL of the same content.  But in our case, they can serve
up the go-import and go-source meta headers for subdirectories of the main code
document.  To do this, make an alias.html template in the root of your layouts
directory, and make it look like this:</p>

<pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;
    &lt;head&gt;
        {{if .Page.Params.vanity -}}
        &lt;meta name=&quot;go-import&quot; content=&quot;npf.io{{substr .Page.RelPermalink 0 -1}} git {{.Page.Params.vanity}}&quot;&gt;
        &lt;meta name=&quot;go-source&quot; content=&quot;npf.io{{substr .Page.RelPermalink 0 -1}} {{.Page.Params.vanity}} {{.Page.Params.vanity}}/tree/master{/dir} {{.Page.Params.vanity}}/blob/master{/dir}/{file}#L{line}&quot;&gt;
        {{- end}}
        &lt;title&gt;{{ .Permalink }}&lt;/title&gt;
        &lt;link rel=&quot;canonical&quot; href=&quot;{{ .Permalink }}&quot;/&gt;
        &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
        &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url={{ .Permalink }}&quot; /&gt;
    &lt;/head&gt;
&lt;/html&gt;
</code></pre>

<p>Other than the stuff in the if statement, the rest is the default alias page
that Hugo creates anyway.  The stuff in the if statement is basically the same
as what&rsquo;s in the code template, just with an extra indirection of specifying
.Page first.</p>

<p><strong>Note that this change to Hugo is in master but not in a release yet.  It&rsquo;ll be
in 0.18, but for now you&rsquo;ll have to build master to get it.</strong></p>

<p>Now, to produce pages for subpackages, you can just specify aliases in the front
matter of the original document with the alias being the import path under the
domain name:</p>

<p><code>aliases = [ &quot;gorram/run&quot;, &quot;gorram/cli&quot; ]</code></p>

<p>So your entire content only needs to look like this:</p>

<pre><code>+++
date = 2016-10-02T23:00:00Z
title = &quot;Gorram&quot;
vanity = &quot;https://github.com/natefinch/gorram&quot;
aliases = [
    &quot;/gorram/run&quot;,
    &quot;/gorram/cli&quot;,
]
+++
</code></pre>

<p>Any time you add a new subdirectory to the package, you&rsquo;ll need to add a new
alias, and regenerate the site.  This is unfortunately manual, but at least it&rsquo;s
a trivial amount of work.</p>

<p>That&rsquo;s it. Now go get (and godoc.org) will know how to get your code.</p>

  </div>
  
  
  
  
  
  
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2015/12/enums/">
        To Enum or Not To Enum
      </a>
    </h1>

    <span class="post-date">Dec 2, 2015</span>

    


    <p>Enum-like values have come up in my reviews of other people&rsquo;s code a few times, and I&rsquo;d like to nail down what we feel is best practice.</p>

<p>I&rsquo;ve seen many places what in other languages would be an enum, i.e. a bounded list of known values that encompass every value that should ever exist.</p>

<p>The code I have been critical of simply calls these values strings, and creates a few well-known values, thusly:
package tool</p>

<p>// types of tools
const (
    ScrewdriverType = &ldquo;screwdriver&rdquo;
    HammerType = &ldquo;hammer&rdquo;
   // &hellip;
)</p>

<p>type Tool struct {
    typ string
}</p>

<p>func NewTool(tooltype string) (Tool, error) {
    switch tooltype{
        case ScrewdriverType, HammerType:
            return Tool{typ:tooltype}, nil
        default:
            return Tool{}, errors.New(&ldquo;invalid type&rdquo;)
    }
}
The problem with this is that there&rsquo;s nothing stopping you from doing something totally wrong like this:
name := user.Name()</p>

<p>// &hellip; some other stuff</p>

<p>a := NewTool(name)
That would fail only at runtime, which kind of defeats the purpose of having a compiler.</p>

<p>I&rsquo;m not sure why we don&rsquo;t at least define the tool type as a named type of string, i.e.
package tool</p>

<p>type ToolType string</p>

<p>const (
    Screwdriver ToolType = &ldquo;screwdriver&rdquo;
    Hammer = &ldquo;hammer&rdquo;
   // &hellip;
)</p>

<p>type Tool struct {
    typ ToolType
}</p>

<p>func NewTool(tooltype ToolType) Tool {
        return Tool{typ:tooltype}
}
Note that now we can drop the error checking in NewTool because the compiler does it for us.  The ToolType still works in all ways like a string, so it&rsquo;s trivial to convert for printing, serialization, etc.</p>

<p>However, this still lets you do something which is wrong but might not always look wrong:
a := NewTool(&ldquo;drill&rdquo;)
Because of how Go constants work, this will get converted to a ToolType, even though it&rsquo;s not one of the ones we have defined.</p>

<p>The final revision, which is the one I&rsquo;d propose, removes even this possibility, by not using a string at all (it also uses a lot less memory and creates less garbage):
package tool</p>

<p>type ToolType int</p>

<p>const (
    Screwdriver ToolType = iota
    Hammer
   // &hellip;
)</p>

<p>type Tool struct {
    typ ToolType
}</p>

<p>func NewTool(tooltype ToolType) Tool {
        return Tool{typ:tooltype}
}
This now prevents passing in a constant string that looks like it might be right. You can pass in a constant number, but NewTool(5) is a hell of a lot more obviously wrong than NewTool(&ldquo;drill&rdquo;), IMO.</p>

<p>The push back I&rsquo;ve heard about this is that then you have to manually write the String() function to make human-readable strings&hellip; but there are code generators that already do this for you in extremely optimized ways (see <a href="https://github.com/golang/tools/blob/master/cmd/stringer/stringer.go">https://github.com/golang/tools/blob/master/cmd/stringer/stringer.go</a>)</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2015/10/errors/">
        Returning Errors
      </a>
    </h1>

    <span class="post-date">Oct 10, 2015</span>

    


    <p>There are basically two ways to return errors in Go:</p>

<pre><code class="language-go">func (c Config) Save() error {
	if err := c.checkDefault(); err != nil {
		return err
	}
	...
}
</code></pre>

<p>or</p>

<pre><code class="language-go">func (c Config) Save() error {
	if err := c.checkDefault(); err != nil {
		return fmt.Errorf(&quot;can't find default config file: %v&quot;, err)
	}
	...
}
</code></pre>

<p>The former passes the original error up the stack, but adds no context to it.
Thus, your saveConfig function may end up printing &ldquo;file not found:
default.cfg&rdquo; without telling the caller why it was trying to open default.cfg.</p>

<p>The latter allows you to add context to an error, so the above error could
become &ldquo;can&rsquo;t find default config file: file not found: default.cfg&rdquo;.
This gives nice context to the error, but unfortunately, it creates an entirely
new error that only maintains the error string from the original.  This is fine
for human-facing output, but is useless for error handling code.</p>

<p>If you use the former code, calling code can then use <code>os.IsNotExist()</code>, figure
out that it was a not found error, and create the file.  Using the latter code,
the type of the error is now a different type than the one from os.Open, and
thus will not return true from os.IsNotExist.  Using fmt.Errorf effectively
masks the original error from calling code (unless you do ugly string parsing -
please don&rsquo;t).</p>

<p>Sometimes it&rsquo;s good to mask the original error, if you don&rsquo;t want your callers
depending on what should be an implementation detail (thus effectively making it
part of your API contract). However, lots of times you may want to give your
callers the ability to introspect your errors and act on them. This then loses
the opportunity to add context to the error, and so people calling your code
have to do some mental gymnastics (and/or look at the implementation) to
understand what an error really means.</p>

<p>A further problem for both these cases is that when debugging, you lose all
knowledge of where an error came from.  There&rsquo;s no stack trace, there&rsquo;s not even
a file and line number of where the error originated.  This can make debugging
errors fairly difficult, unless you&rsquo;re careful to make your error messages easy
to grep for.  I can&rsquo;t tell you how often I&rsquo;ve searched for an error formatting
string, and hoped I was guessing the format correctly.</p>

<p>This is just the way it is in Go, so what&rsquo;s a developer to do?  Why, write an
errors library that does smarter things of course!  And there are a ton of these
things out there.  Many add a stack trace at error creation time.  Most wrap an
original error in some way, so you can add some context while keeping the
original error for checks like os.IsNotExist. At Canonical, the Juju team wrote
just such a library (actually we wrote 3 and then had them fight until only one
was standing), and the result is <a href="https://github.com/juju/errors">https://github.com/juju/errors</a>.</p>

<p>Thus you might return an error this way:</p>

<pre><code class="language-go">func (c Config) Save() error {
	if err := c.checkDefault(); err != nil {
		return errors.Annotatef(err, &quot;can't find default config file&quot;)
	}
}
</code></pre>

<p>This returns a new error created by the errors package which adds the given
string to the front of the original error&rsquo;s error message (just like
fmt.Errorf), but you can introspect it using <code>errors.Cause(err)</code> to access the
original error return by checkDefault.  Thus you can use
<code>os.IsNotExist(errors.Cause(err))</code> and it&rsquo;ll do the right thing.</p>

<p>However, this and every other special error library suffer from the same problem
- your library can only understand its own special errors.  And no one else&rsquo;s
code can understand your errors (because they won&rsquo;t know to use errors.Cause
before checking the error).  Now you&rsquo;re back to square one - your errors are
just as opaque to third party code as if they were created by fmt.Errorf.</p>

<p>I don&rsquo;t really have an answer to this problem. It&rsquo;s inherent in the
functionality (or lack thereof) of the standard Go error type.</p>

<p>Obviously, if you&rsquo;re writing a standalone package for many other people to use,
don&rsquo;t use a third party error wrapping library.  Your callers are likely not
going to be using the same library, so they won&rsquo;t get use out of it, and it adds
unnecessary dependencies to your code.  To decide between returning the original
error and an annotated error using fmt.Errorf is harder.  It&rsquo;s hard to know when
the information in the original error might be useful to your caller.  On the
other hand, the additional context added by fmt.Errorf can often change an
inscrutable error into an obvious one.</p>

<p>If you&rsquo;re writing an application where you&rsquo;ll be controlling most of the
packages being written, then an errors package may make sense&hellip; but you still
run the risk of giving your custom errors to third party code that can&rsquo;t
understand them.  Plus, any errors library adds some complexity to the code (for
example, you always have to rememeber to call <code>os.IsNotExist(errors.Cause(err))</code>
rather than just calling <code>os.InNotExist(err)</code>).</p>

<p>You have to choose one of the three options every time you return an error.
Choose carefully.  Sometimes you&rsquo;re going to make a choice that makes your life
more difficult down the road.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2015/06/deputy/">
        Take control of your commands with Deputy
      </a>
    </h1>

    <span class="post-date">Jun 30, 2015</span>

    


    

<p><img src="https://cloud.githubusercontent.com/assets/3185864/8237448/6bc30102-15bd-11e5-9e87-6423197a73d6.jpg" alt="deputy-sm" /></p>

<p><sup><sub>image: creative commons, &copy; <a href="http://matsurd.deviantart.com/art/Paper53-Deputy-Stubbs-342123485">MatsuRD</a></sub></sup></p>

<p>As a part of my work on <a href="https://github.com/juju/juju">Juju</a>, I have published a
new package at <a href="http://github.com/juju/deputy">http://github.com/juju/deputy</a>.  I think it&rsquo;ll be of general use
to a lot of people.</p>

<p><blockquote class="twitter-tweet" lang="en"><p lang="en" dir="ltr">I want to name a package &quot;lieutenant&quot;, but it&#39;s too hard to spell.</p>&mdash; Nate Finch (@NateTheFinch) <a href="https://twitter.com/NateTheFinch/status/610481962311131136">June 15, 2015</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<p>True story.  The idea was this package would be a lieutenant commander (get
it?)&hellip; but I also knew I didn&rsquo;t want to have to try to spell lieutenant
correctly every time I used the package.  So that&rsquo;s why it&rsquo;s called deputy.
He&rsquo;s the guy who&rsquo;s not in charge, but does all the work.</p>

<h3 id="errors">Errors</h3>

<p>At <a href="https://github.com/juju/juju">Juju</a>, we run a lot of external processes
using os/exec. However, the default functionality of an exec.Cmd object is kind
of lacking. The most obvious one is those error returns &ldquo;exit status 1&rdquo;.
Fantastic.  Have you ever wished you could just have the stderr from the command
as the error text?  Well, now you can, with deputy.</p>

<pre><code>func main() {
    d := deputy.Deputy{
        Errors:    deputy.FromStderr,
    }
    cmd := exec.Command(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;)
    err := d.Run(cmd)
}
</code></pre>

<p>In the above code, if the command run by Deputy exits with a non-zero exit
status, deputy will capture the text output to stderr and convert that into the
error text.  <em>e.g.</em> if the command returned exit status 1 and output &ldquo;Error: No
such image or container: bar&rdquo; to stderr, then the error&rsquo;s Error() text would
look like &ldquo;exit status 1: Error: No such image or container: bar&rdquo;.  Bam, the
errors from commands you run are infinitely more useful.</p>

<h3 id="logging">Logging</h3>

<p>Another idiom we use is to pipe some of the output from a command to our logs. This can be super useful for debugging purposes.  With deputy, this is again easy:</p>

<pre><code>func main() {
    d := deputy.Deputy{
        Errors:    deputy.FromStderr,
        StdoutLog: func(b []byte) { log.Print(string(b)) },
    }
    cmd := exec.Command(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;)
    err := d.Run(cmd)
}
</code></pre>

<p>That&rsquo;s it.  Now every line written to stdout by the process will be piped as a
log message to your log.</p>

<h3 id="timeouts">Timeouts</h3>

<p>Finally, an idiom we don&rsquo;t use often enough, but should, is to add a timeout to
command execution.  What happens if you run a command as part of your pipeline
and that command hangs for 30 seconds, or 30 minutes, or forever?  Do you just
assume it&rsquo;ll always finish in a reasonable time?  Adding a timeout to running
commands requires some tricky coding with goroutines, channels, selects, and
killing the process&hellip; and deputy wraps all that up for you in a simple API:</p>

<pre><code>func main() {
    d := deputy.Deputy{
        Errors:    deputy.FromStderr,
        StdoutLog: func(b []byte) { log.Print(string(b)) },
        Timeout:   time.Second * 10,
    }
    cmd := exec.Command(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;)
    err := d.Run(cmd)
}
</code></pre>

<p>The above code adds a 10 second timeout.  After that time, if the process has
not finished, it will be killed and an error returned.</p>

<p>That&rsquo;s it.  Give deputy a spin and let me know what you think.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2015/06/testing-exec-command/">
        Testing os/exec.Command
      </a>
    </h1>

    <span class="post-date">Jun 26, 2015</span>

    


    <p>In <a href="https://github.com/juju/juju">Juju</a>, we often have code that needs to run external
executables.  Testing this code is a nightmare&hellip; because you really don&rsquo;t want
to run those files on the dev&rsquo;s machine or the CI machine.  But mocking out
os/exec is really hard.  There&rsquo;s no interface to replace, there&rsquo;s no function to
mock out and replace.  In the end, your code calls the Run method on the
exec.Cmd struct.</p>

<p>There&rsquo;s a bunch of bad ways you can mock this out - you can write out scripts to
disk with the right name and structure their contents to write out the correct
data to stdout, stderr and return the right return code&hellip; but then you&rsquo;re
writing platform-specific code in your tests, which means you need a Windows
version and a Linux version&hellip; It also means you&rsquo;re writing shell scripts or
Windows batch files or whatever, instead of writing Go.  And we all know that we
want our tests to be in Go, not shell scripts.</p>

<p>So what&rsquo;s the answer?  Well, it turns out, if you want to mock out exec.Command,
the best place to look is in the exec package&rsquo;s tests themselves.  Lo and
behold, it&rsquo;s right there in the first function of <a href="https://github.com/golang/go/blob/master/src/os/exec/exec_test.go#L31">exec_test.go</a></p>

<pre><code>func helperCommand(t *testing.T, s ...string) *exec.Cmd {
    cs := []string{&quot;-test.run=TestHelperProcess&quot;, &quot;--&quot;}
    cs = append(cs, s...)
    cmd := exec.Command(os.Args[0], cs...)
    cmd.Env = []string{&quot;GO_WANT_HELPER_PROCESS=1&quot;}
    return cmd
}
</code></pre>

<p><sub><sup>(one line elided for clarity) </sup></sub></p>

<p>What the heck is that doing?  It&rsquo;s pretty slick, so I&rsquo;ll explain it.</p>

<p>First off, you have to understand how tests in Go work.  When running <code>go test</code>,
the go tool compiles an executable from your code, runs it, and passes it the
flags you passed to <code>go test</code>.  It&rsquo;s that executable which actually handles the
flags and runs the tests.  Thus, while your tests are running, os.Args[0] is the
name of the test executable.</p>

<p>This function is making an exec.Command that runs the test executable, and
passes it the flag to tell the executable just to run a single test.  It then
terminates the argument list with <code>--</code> and appends the command and arguments
that would have been given to exec.Command to run <em>your</em> command.</p>

<p>The end result is that when you run the exec.Cmd that is returned, it will run
the single test from this package called &ldquo;TestHelperProcess&rdquo; and os.Args will
contain (after the <code>--</code>) the command and arguments from the original call.</p>

<p>The environment variable is there so that the test can know to do nothing unless
that environment variable is set.</p>

<p>This is awesome for a few reasons:</p>

<ul>
<li>It&rsquo;s all Go code. No more needing to write shell scripts.</li>
<li>The code run in the excutable is compiled with the rest of your test code.  No more needing to worry about typos in the strings you&rsquo;re writing to disk.</li>
<li>No need to create new files on disk - the executable is already there and runnable, by definition.</li>
</ul>

<p>So, let&rsquo;s use this in a real example to make it more clear.</p>

<p>In your production code, you can do something like this:</p>

<pre><code>var execCommand = exec.Command
func RunDocker(container string) ([]byte, error) {
    cmd := execCommand(&quot;docker&quot;, &quot;run&quot;, &quot;-d&quot;, container)
    out, err := cmd.CombinedOutput()
}
</code></pre>

<p>Mocking this out in test code is now super easy:</p>

<pre><code>func fakeExecCommand(command string, args...string) *exec.Cmd {
    cs := []string{&quot;-test.run=TestHelperProcess&quot;, &quot;--&quot;, command}
    cs = append(cs, args...)
    cmd := exec.Command(os.Args[0], cs...)
    cmd.Env = []string{&quot;GO_WANT_HELPER_PROCESS=1&quot;}
    return cmd
}

const dockerRunResult = &quot;foo!&quot;
func TestRunDocker(t *testing.T) {
    execCommand = fakeExecCommand
    defer func(){ execCommand = exec.Command }()
    out, err := RunDocker(&quot;docker/whalesay&quot;)
    if err != nil {
        t.Errorf(&quot;Expected nil error, got %#v&quot;, err)
    }
    if string(out) != dockerRunResult {
        t.Errorf(&quot;Expected %q, got %q&quot;, dockerRunResult, out)
    }
}

func TestHelperProcess(t *testing.T){
    if os.Getenv(&quot;GO_WANT_HELPER_PROCESS&quot;) != &quot;1&quot; {
        return
    }
    // some code here to check arguments perhaps?
    fmt.Fprintf(os.Stdout, dockerRunResult)
    os.Exit(0)
}
</code></pre>

<p>Of course, you can do a lot more interesting things. The environment variables
on the command that fakeExecCommand returns make a nice side channel for telling
the executable what you want it to do.  I use one to tell the process to exit
with a non-zero error code, which is great for testing your error handling code.
You can see how the standard library uses its TestHelperProcess test
<a href="https://github.com/golang/go/blob/master/src/os/exec/exec_test.go#L559">here</a>.</p>

<p>Hopefully this will help you avoid writing really gnarly testing code (or even worse,
not testing your code at all).</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2015/06/wip-godoc/">
        Sharing Godoc of a WIP Branch
      </a>
    </h1>

    <span class="post-date">Jun 11, 2015</span>

    


    <p>I had a problem yesterday - I wanted to use the excellent godoc.org to show
coworkers the godoc for the feature I was working on.  However, the feature was
on a branch of the main code in Github, and <code>go get</code> Does Not Work That Way™.
So, what to do?  Well, I figured out a hack to make it work.</p>

<p><a href="https://gopkg.in">https://gopkg.in</a> is a super handy service that lets you point <code>go get</code> at
branches of your repo named vN (e.g. v0, v1, etc).  It also happens to work on
tags.  So, we can leverage this to get godoc.org to render the godoc for our WIP
branch.</p>

<p>From your WIP branch, simply do</p>

<pre><code>git tag v0
git push myremote v0
</code></pre>

<p>This creates a lightweight tag that only affects your repo (not upstream from
whence you forked).</p>

<p>You now can point godoc at your branch by way of gopkg.in:
<a href="https://godoc.org/gopkg.in/GithubUser/repo.v0">https://godoc.org/gopkg.in/GithubUser/repo.v0</a></p>

<p>This will tell godoc to &lsquo;go get&rsquo; your code from gopkg.in, and gopkg.in will
redirect the command to your v0 tag, which is currently on your branch.  Bam,
now you have godoc for your WIP branch on godoc.org.</p>

<p>Later, the tag can easily be removed (and reused if needed) thusly:</p>

<pre><code>git tag -d v0
git push myremote :refs/tags/v0
</code></pre>

<p>So, there you go, go forth and share your godoc.  I find it&rsquo;s a great way to get
feedback on architecture before I dive into the reeds of the implementation.</p>

  </div>
  
  
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2015/05/pie/">
        Go Plugins are as Easy as Pie
      </a>
    </h1>

    <span class="post-date">May 25, 2015</span>

    


    

<p>When people hear that Go only supports static linking, one of the things they
eventually realize is that they can&rsquo;t have traditional plugins via dlls/libs (in
compiled languages) or scripts (in interpreted languages).  However, that
doesn&rsquo;t mean that you can&rsquo;t have plugins.  Some people suggest doing &ldquo;compiled-
in&rdquo; plugins - but to me, that&rsquo;s not a plugin, that&rsquo;s just code.  Some people
suggest just running sub processes and sending messages via their CLI, but that
runs into CLI parsing issues and requires runnnig a new process for every
request.  The last option people think of is using RPC to an external process,
which may also seem cumbersome, but it doesn&rsquo;t have to be.</p>

<h3 id="serving-up-some-pie">Serving up some pie</h3>

<p>I&rsquo;d like to introduce you to <a href="https://github.com/natefinch/pie">https://github.com/natefinch/pie</a> - this is a Go
package which contains a toolkit for writing plugins in Go.  It uses processes
external to the main program as the plugins, and communicates with them via RPC
over the plugin&rsquo;s stdin and stout.  Having the plugin as an external process can
actually has several benefits:</p>

<ul>
<li>If the plugin crashes, it won&rsquo;t crash your process.</li>
<li>The plugin is not in your process&rsquo; memory space, so it can&rsquo;t do anything nasty.</li>
<li>The plugin can be written in any language, not just Go.</li>
</ul>

<p>I think this last point is actually the most valuable.  One of the nicest things
about Go applications is that they&rsquo;re just copy-and-run.  No one even needs to
know they were written in Go.  With plugins as external processes, this remains
true.  People wanting to extend your application can do so in the language of
their choice, so long as it supports the codec your application has chosen for
RPC.</p>

<p>The fact that the communication occurs over stdin and stdout means that there is
no need to worry about negotiating ports, it&rsquo;s easily cross platform compatible,
and it&rsquo;s very secure.</p>

<h3 id="orthogonality">Orthogonality</h3>

<p>Pie is written to be a very simple set of functions that help you set up
communication between your process and a plugin process.  Once you make a couple
calls to pie, you then need to work out your own way to use the RPC connection
created.  Pie does not attempt to be an all-in-one plugin framework, though you
could certainly use it as the basis for one.</p>

<h3 id="why-is-it-called-pie">Why is it called pie?</h3>

<p>Because if you pronounce API like &ldquo;a pie&rdquo;, then all this consuming and serving
of APIs becomes a lot more palatable.  Also, pies are the ultimate pluggable
interface - depending on what&rsquo;s inside, you can get dinner, dessert, a snack, or
even breakfast.  Plus, then I get to say that plugins in Go are as easy as&hellip;
well, you know.</p>

<h3 id="conclusion">Conclusion</h3>

<p>I plan to be using pie in one of my own side projects.  Take it out for a spin
in one of your projects and let me know what you think.  Happy eating!</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2014/10/go-nitpicks/">
        Go Nitpicks
      </a>
    </h1>

    <span class="post-date">Oct 28, 2014</span>

    


    

<p>I saw this tweet last night:</p>

<p><blockquote class="twitter-tweet" lang="en"><p>A code interview I like to ask:&#10;&#10;&quot;What would you change about &lt;your favourite language&gt;?&quot;&#10;&#10;Having nothing to say to that is a big strike.</p>&mdash; karlseguin (@karlseguin) <a href="https://twitter.com/karlseguin/status/526860386704695296">October 27, 2014</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<p>I figured I&rsquo;d answer it here about Go.  Luckily, Go is a very small language, so there&rsquo;s not a lot of surface area to dislike. However, there&rsquo;s definitely some things I wish were different. Most of these are nitpicks, thus the title.</p>

<h4 id="1-bare-returns">#1 Bare Returns</h4>

<pre><code>func foo() (i int, err error) {
    i, err = strconv.ParseInt(&quot;5&quot;) 
    return // wha??
}
</code></pre>

<p>For all that Go promotes readable and immediately understandable code, this seems like a ridiculous outlier. The way it works is that if you don&rsquo;t declare what the function is returning, it&rsquo;ll return the values stored in the named return variables.  Which seems logical and handy, until you see a 100 line function with multiple branches and a single bare return at the bottom, with no idea what is actually getting returned.</p>

<p>To all gophers out there: don&rsquo;t use bare returns.  Ever.</p>

<h4 id="2-new">#2 New</h4>

<pre><code>a := new(MyStruct)
</code></pre>

<p>New means &ldquo;Create a zero value of the given type and return a pointer to it&rdquo;.  It&rsquo;s sorta like the C++ <code>new</code>, which is probably why it exists.  The problem is that it&rsquo;s nearly useless.  It&rsquo;s mostly redundant with simply returning the address of a value thusly:</p>

<pre><code>a := &amp;MyStruct{}
</code></pre>

<p>The above is a lot easier to read, it also gives you the ability to populate the value you&rsquo;re constructing (if you wish).  The only time new is &ldquo;useful&rdquo; is if you want to initialize a pointer to a builtin (like a string or an int), because you can&rsquo;t do this:</p>

<pre><code>a := &amp;int
</code></pre>

<p>but you can do this:</p>

<pre><code>a := new(int)
</code></pre>

<p>Of course, you could always just do it in (<em>gasp</em>) two lines:</p>

<pre><code>a := 0
b := &amp;a
</code></pre>

<p>To all the gophers out there: don&rsquo;t use new. Always use &amp;Foo{} with structs, maps, and slices. Use the two line version for numbers and strings.</p>

<h4 id="3-close">#3 Close</h4>

<p>The close built-in function closes a channel. If the channel is already closed, close will panic.  This pisses me off, because most of the time when I call close, I don&rsquo;t actually care if it&rsquo;s already closed.  I just want to ensure that it&rsquo;s closed.  I&rsquo;d much prefer if close returned a boolean that said whether or not it did anything, and then if <strong>I</strong> choose to panic, I can.  Or, you know, not.</p>

<h4 id="4-there-is-no-4">#4 There is no 4</h4>

<p>That&rsquo;s basically it.  There&rsquo;s some things I think are necessary evils, like <code>goto</code> and <code>panic</code>.  There&rsquo;s some things that are necessary ugliness, like the built-in functions <code>append</code>, <code>make</code>, <code>delete</code>, etc.  I sorta wish <code>x := range foo</code> returned the value in x and not the index, but I get that it&rsquo;s to be consistent between maps and slices, and returning the value in maps would be odd, I think.</p>

<p>All these are even below the level of nitpicks, though.  They don&rsquo;t bug me, really.  I understand that everything in programming is a tradeoff, and I think the decisions made for Go were the right ones in these cases.  Sometimes you need goto.  Sometimes you need to panic.  Making those functions built-ins rather than methods on the types means you don&rsquo;t need any methods on the types, which keeps them simpler, and means they&rsquo;re &ldquo;just data&rdquo;.  It also means you don&rsquo;t lose any functionality if you make new named types based on them.</p>

<p>So that&rsquo;s my list for Go.</p>

<h4 id="postscript">Postscript</h4>

<p>Someone on the twitter discussion mentioned he couldn&rsquo;t think of anything he disliked about C#, which just about made me spit my coffee across the room.  I programmed in C# for ~9 years, starting out porting some 1.1 code to 2.0, and leaving as 5.0 came out.  The list of features in C# as of 5.0 is gigantic.  Even being a developer writing in it 40+ hours a week for 9 years, there was still stuff I had to look up to remember how it worked.</p>

<p>I feel like my mastery of Go after a year of side projects was about equivalent to my mastery of C# after 9 years of full time development.  If we assume 1:1 correlation between time to master and size of the language, an order of magnitude sounds about right.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2014/10/why-everyone-hates-go/">
        Why Everyone Hates Go
      </a>
    </h1>

    <span class="post-date">Oct 14, 2014</span>

    


    <p>Obviously, not <em>everyone</em> hates Go.  But there was a <a href="https://www.quora.com/Why-does-Go-seem-to-be-the-most-heavily-
criticised-among-the-newer-programming-languages?srid=uCiY&amp;share=1">quora
question</a> recently
about why everyone criticizes Go so much. (sorry, I don&rsquo;t normally post links to
Quora, but it was the motivator for this post) Even before I saw the answers to
the question, I knew what they&rsquo;d consist of:</p>

<ul>
<li>Go is a language stuck in the 70&rsquo;s.</li>
<li>Go ignores 40 years of programming language research.</li>
<li>Go is a language for blue collar (mediocre) developers.</li>
<li>Gophers are ok with working in Java 1.0.</li>
</ul>

<p>Unfortunately, the answers to the questions were more concerned with explaining
why Go is &ldquo;bad&rdquo;, rather than why this gets under so many people&rsquo;s skin.</p>

<p>When reading the answers I had a eureka moment, and I realized why it is. So
here&rsquo;s my answer to the same question. This is why Go is so heavily criticized,
not why Go is &ldquo;bad&rdquo;.</p>

<p>There&rsquo;s two awesome posts that inform my answer: Paul Graham&rsquo;s
<a href="http://www.paulgraham.com/identity.html">post</a> about keeping your identity
small, and Kathy Sierra&rsquo;s <a href="http://seriouspony.com/trouble-at-the-koolaid-
point">post</a> about the Koolaid point. I encourage you to read those two posts, as
they&rsquo;re both very informative.  I hesitate to compare the horrific things that
happen to women online with the pedantry of flamewars about programming
languages, but the Koolaid Point is such a valid metaphor that I wanted to link
to the article.</p>

<p>Paul says</p>

<blockquote>
<p>people can never have a fruitful argument about
something that&rsquo;s part of their identity</p>
</blockquote>

<p><em>i.e.</em> the subject hits too close to home,
and their response becomes emotional rather than logical.</p>

<p>Kathy says</p>

<blockquote>
<p>the hate wasn’t so much about the product/brand but that <em>other people were falling for it</em>.</p>
</blockquote>

<p><em>i.e.</em> they&rsquo;d drunk the kool-aid.</p>

<p>Go is the only recent language that takes the aforementioned 40 years of
programming language research and tosses it out the window. Other new languages
at least try to keep up with the Jones - Clojure, Scala, Rust - all try to
incorporate &ldquo;modern programming theory&rdquo; into their design. Go actively tries
not to. There is no pattern matching, there&rsquo;s no borrowing, there&rsquo;s no pure
functional programming, there&rsquo;s no immutable variables, there&rsquo;s no option types,
there&rsquo;s no exceptions, there&rsquo;s no classes, there&rsquo;s no generics&hellip;. there&rsquo;s a lot
Go doesn&rsquo;t have. And in the beginning this was enough to merely earn it scorn.
Even I am guilty of this. When I first heard about Go, I thought &ldquo;What? No
exceptions? Pass.&rdquo;</p>

<p>But then something happened - people started <em>using</em> it. And liking it. And
building big projects with it. This is the Koolaid-point - where people have
started to drink the Koolaid and get fooled into thinking Go is a good
language. And this is where the scorn turns into derision and attacks on the
character of the people using it.</p>

<p>The most vocal Go detractors are those developers who write in ML-derived
languages (Haskell, Rust, Scala, <em>et al</em>) who have tied their preferred
programming language into their identity. The mere existence of Go says
&ldquo;your views on what makes a good programming language are wrong&rdquo;. And the more
people that use and like Go, the more strongly they feel that they&rsquo;re being told
their choice of programming language - and therefore their identity - is wrong.</p>

<p>Note that basically no one in the Go community actually says this. But the Go
philosophy of simplicity and pragmatism above all else is the polar opposite of
what those languages espouse (in which complexity in the language is ok because
it enforces correctness in the code). This is insulting to the people who tie
their identity to that language. Whenever a post on Go makes it to the front
page of Hacker News, it is an affront to everything they hold dear, and so you
get comments like Go developers are stuck in the 70&rsquo;s, or is only for blue-collar devs.</p>

<p>So, this is why I think people are so much more vocal about their dislike of Go:
because it challenges their identity, and other people are falling for it. This
is also why these posts so often mention Google and how the language would have
died without them. Google is now the koolaid dispenser. The fact that they
are otherwise generally thought of as a very talented pool of developers means
that it is simultaneously more outrageous that they are fooling people and more
insulting that their language flies in the face of ML-derived languages.</p>

<p><strong>Update:</strong>  I removed the &ldquo;panties in a bunch&rdquo; comment, since I was (correctly)
scolded for being sexist, not to mention unprofessional.  My apologies to
anyone I offended.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2014/10/deploy-discourse-juju/">
        Deploy Discourse with Juju in 8 minutes
      </a>
    </h1>

    <span class="post-date">Oct 1, 2014</span>

    


    <p><a href="http://stevefrancia.com/">Steve Francia</a> asked me to help him get
<a href="https://discourse.org">Discourse</a> deployed as a place for people to discuss
<a href="http://gohugo.io">Hugo</a>, his static site generator (which is what I use to
build this blog).  If you don&rsquo;t know Discourse, it&rsquo;s pretty amazing forum
software with community-driven moderation, all the modern features you expect
(@mentions, SSO integration, deep email integration, realtime async updates, and
a whole lot more).  What I ended up deploying is now at
<a href="http://discuss.gohugo.io">discuss.gohugo.io</a>.</p>

<p>I&rsquo;d already played around with deploying Discourse about six months ago, so I
already had an idea of what was involved.  Given that I work on
<a href="http://juju.ubuntu.com">Juju</a> as my day job, of course I decided to use Juju to
deploy Discourse for Steve.  This involved writing a Juju <em>charm</em> which is sort
of like an install script, but with hooks for updating configuration and hooks
for interacting with other services. I&rsquo;ll talk about the process of writing the
charm in a later post, but for now, all you need to know is that it follows the
official <a href="https://github.com/discourse/discourse/blob/master/docs/INSTALL-digital-ocean.md">install guide</a> for installing Discourse.</p>

<p>The install guide says that you can install Discourse in 30 minutes.  Following
it took me a <strong>lot</strong> longer than that, due to some confusion about what the
install guide really wanted you to do, and what the install really required.
But you don&rsquo;t need to know any of that to use Juju to install Discourse, and you
can get it done in 8 minutes, not 30.  Here&rsquo;s how:</p>

<p>First, install Juju:</p>

<pre><code>sudo add-apt-repository -y ppa:juju/stable
sudo apt-get update &amp;&amp; sudo apt-get install -y juju-core
</code></pre>

<p>Now, Juju does not yet have a provider for Digital Ocean, so we have to use a
plugin to get the machine created.  We&rsquo;re in the process of writing a provider
for Digital Ocean, so soon the plugin won&rsquo;t be necessary.  If you use another
cloud provider, such as AWS, Azure, HP Cloud, Joyent, or run your own Openstack
or MAAS, you can easily <a href="https://juju.ubuntu.com/docs/getting-a
started.html#configuring">configure Juju</a> to use that service, and a couple of these steps will
not be necessary.  I&rsquo;ll post separate steps for that later.  But for now, let&rsquo;s
assume you&rsquo;re using Digital Ocean.</p>

<p>Install the juju <a href="https://github.com/kapilt/juju-digitalocean">Digital Ocean plugin</a>:</p>

<pre><code>sudo apt-get install -y python-pip
pip install -U juju-docean
</code></pre>

<p>Get your Digital Ocean <a href="https://cloud.digitalocean.com/api_access">access info</a>
and set the client id in an environment variable called DO_CLIENT_ID and the API
key in an environment variable called DO_API_KEY.</p>

<p>Juju requires access with an SSH key to the machines, so make sure you have one
set up in your Digital Ocean account.</p>

<p>Now, let&rsquo;s create a simple configuration so juju knows where you want to deploy
your new environment.</p>

<pre><code>juju init
</code></pre>

<p>Running juju init will create a boilerplate configuration file at
~/.juju/environments.yaml.  We&rsquo;ll append our digital ocean config at the bottom:</p>

<pre><code>echo &quot;    digitalocean:
        type: manual
        bootstrap-host: null
        bootstrap-user: root
&quot; &gt;&gt; ~/.juju/environments.yaml
</code></pre>

<p>Note that this is yaml, so the spaces at the beginning of each line are
important.  Copy and paste should do the right thing, though.</p>

<p>Now we can start the real fun, let&rsquo;s switch to the digitalocean environment we
just configured, and create the first Juju machine in Digital Ocean:</p>

<pre><code>juju switch digitalocean
juju docean bootstrap --constraints=&quot;mem=2g, region=nyc2&quot;
</code></pre>

<p>(obviously replace the region with whatever one you want)</p>

<p>Now, it&rsquo;ll take about a minute for the machine to come up.</p>

<p>Discourse <em>requires</em> email to function, so you need an account at
<a href="http://mandrill.com">mandrill</a>, <a href="http://mailgun.com">mailgun</a>, etc.  They&rsquo;re free, so
don&rsquo;t worry.  From that account you need to get some information to properly set
up Discourse.  You can do this after installing discourse, but it&rsquo;s faster if
you do it before and give the configuration at deploy time. (changing settings
later will take a couple minutes while discourse reconfigures itself)</p>

<p>When you deploy discourse, you&rsquo;re going to give it a configuration file, which
will look something like this:</p>

<pre><code>discourse:
  DISCOURSE_HOSTNAME: discuss.example.com
  DISCOURSE_DEVELOPER_EMAILS: foo@example.com,bar@example.com
  DISCOURSE_SMTP_ADDRESS: smtp.mailservice.com
  DISCOURSE_SMTP_PORT: 587
  DISCOURSE_SMTP_USER_NAME: postmaster@example.com
  DISCOURSE_SMTP_PASSWORD: supersecretpassword
  UNICORN_WORKERS: 3
</code></pre>

<p>The first line must be the same as the name of the service you&rsquo;re deploying.  By
default it&rsquo;s &ldquo;discourse&rdquo;, so you don&rsquo;t need to change it unless you&rsquo;re deploying
multiple copies of discourse to the same Juju environment.  And remember, this
is yaml, so those spaces at the beginning of the rest of the lines are
important.</p>

<p>The rest should be pretty obvious.  Hostname is the domain name where your site
will be hosted.  This is important, because discourse will send account
activation emails, and the links will use that hostname.  Developer emails are
the email addresses of accounts that should get automatically promoted to admin
when created.  The rest is email-related stuff from your mail service account.
Finally, unicorn workers should just stay 3 unless you&rsquo;re deploying to a machine
with less than 2GB of RAM, in which case set it to 2.</p>

<p>Ok, so now that you have this file somewhere on disk, we can deploy discourse.
Don&rsquo;t worry, it&rsquo;s really easy.  Just do this:</p>

<pre><code>juju deploy cs:~natefinch/trusty/discourse --config path/to/configfile --to 0
juju expose discourse
</code></pre>

<p>That&rsquo;s it. If you&rsquo;re deploying to a 2GB Digital Ocean droplet, it&rsquo;ll take about
7 minutes.</p>

<p>To check on the status of the charm deployment, you can do <code>juju status</code>, which
will show, among other things &ldquo;agent-state: pending&rdquo; while the charm is being
deployed.  Or, if you want to watch the logs roll by, you can do <code>juju debug-
log</code>.</p>

<p>Eventually juju status will show <code>agent-state: started</code>.  Now grab the ip
address listed at <code>public address:</code> in the same output and drop that into your
browser.  Bam!  Welcome to Discourse.</p>

<p>If you ever need to change the configuration you set in the config file above,
you can do that by editing the file and doing</p>

<pre><code>juju set discourse --config=/path/to/config
</code></pre>

<p>Or, if you just want to tweak a few values, you can do</p>

<pre><code>juju set discourse foo=bar baz=bat ...
</code></pre>

<p>Note that every time you call juju set, it&rsquo;ll take a couple minutes for
Discourse to reconfigure itself, so you don&rsquo;t want to be doing this over and
over if you can hep it.</p>

<p>Now you&rsquo;re on your own, and will have to consult the gurus at
<a href="discourse.org">discourse.org</a> if you have any problems.  But don&rsquo;t worry, since
you deployed using Juju, which uses their official install instructions, your
discourse install is just like the ones people deploy manually (albeit with a
lot less time and trouble).</p>

<p>Good Luck!</p>

<p>Please let me know if you find any errors in this page, and I will fix them
immediately.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2014/08/intro-to-toml/">
        Intro to TOML
      </a>
    </h1>

    <span class="post-date">Aug 16, 2014</span>

    


    

<p>TOML stands for Tom&rsquo;s Own Minimal Language.  It is a configuration language
vaguely similar to YAML or property lists, but far, far better.  But before we
get into it in detail, let&rsquo;s look back at what came before.</p>

<h3 id="long-ago-in-a-galaxy-far-far-away">Long Ago, In A Galaxy Far, Far Away</h3>

<p>Since the beginning of computing, people have needed a way to configure
their software.  On Linux, this generally is done in text files.  For simple
configurations, good old foo = bar works pretty well.  One setting per line,
name on the left, value on the right, separated by an equals.  Great.  But when
your configuration gets more complicated, this quickly breaks down.  What if you
need a value that is more than one line?  How do you indicate a value should be
parsed as a number instead of a string?  How do you namespace related
configuration values so you don&rsquo;t need ridiculously long names to prevent
collisions?</p>

<h3 id="the-dark-ages">The Dark Ages</h3>

<p>In the 90&rsquo;s, we used XML.  And it sucked.  XML is verbose, it&rsquo;s hard for humans
to read and write, and it still doesn&rsquo;t solve a lot of the problems above (like
how to specify the type of a value).  In addition, the XML spec is huge,
processing is very complicated, and all the extra features invite abuse and
overcomplication.</p>

<h3 id="enlightenment">Enlightenment</h3>

<p>In the mid 2000&rsquo;s, JSON came to popularity as a data exchange format, and it was
so much better than XML.  It had real types, it was easy for programs to
process, and you didn&rsquo;t have to write a spec on what values should get processed
in what way (well, mostly).  It was sigificantly less verbose than XML.  But it
is a format intended for computers to read and write, not humans.  It is a pain
to write by hand, and even pretty-printed, it can be hard to read and the
compact data format turns into a nested mess of curly braces.  Also, JSON is not
without its problems&hellip; for example, there&rsquo;s no date type, there&rsquo;s no support
for comments, and all numbers are floats.</p>

<h3 id="a-false-start">A False Start</h3>

<p>YAML came to popularity some time after JSON as a more human-readable format,
and its <code>key: value</code> syntax and pretty indentation is definitely a lot easier on
the eyes than JSON&rsquo;s nested curly-braces.  However, YAML trades ease of reading
for difficulty in writing.  Indentation as delimiters is fraught with error&hellip;
figuring out how to get multiple lines of data into any random value is an
exercise in googling and trial &amp; error.</p>

<p>The YAML spec is also ridiculously long.  100% compatible parsers are very
difficult to write.  Writing YAML by hand is a ridden with landmines of corner
cases where your choice of names or values happens to hit a reserved word or
special marker.  It does support comments, though.</p>

<h3 id="the-savior">The Savior</h3>

<p>On February 23, 2013, Tom Preston-Werner (former CEO of GitHub) made his first
commit to <a href="https://github.com/toml-lang/toml">https://github.com/toml-lang/toml</a>.  TOML stands for Tom&rsquo;s Obvious,
Minimal Language.  It is a language designed for configuring software.  Finally.</p>

<p>TOML takes inspiration from all of the above (well, except XML) and even gets
some of its syntax from Microsoft&rsquo;s INI files.  It is easy to write by hand and
easy to read.  The spec is short and understandable by mere humans, and it&rsquo;s
fairly easy for computers to parse.  It supports comments, has first class
dates, and supports both integers and floats.  It is generally insensitive to
whitespace, without requiring a ton of delimiters.</p>

<p>Let&rsquo;s dive in.</p>

<h3 id="the-basics">The Basics</h3>

<p>The basic form is key = value</p>

<pre><code># Comments start with hash
foo = &quot;strings are in quotes and are always UTF8 with escape codes: \n \u00E9&quot;

bar = &quot;&quot;&quot;multi-line strings
use three quotes&quot;&quot;&quot;

baz = 'literal\strings\use\single\quotes'

bat = '''multiline\literals\use
three\quotes'''

int = 5 # integers are just numbers
float = 5.0 # floats have a decimal point with numbers on both sides

date = 2006-05-27T07:32:00Z # dates are ISO 8601 full zulu form

bool = true # good old true and false
</code></pre>

<p>One cool point:  If the first line of a multiline string (either literal or not)
is a line return, it will be trimmed.  So you can make your big blocks of text
start on the line after the name of the value and not need to worry about the
extraneous newline at the beginning of your text:</p>

<pre><code>preabmle = &quot;&quot;&quot;
We the people of the United States, in order to form a more perfect union,
establish justice, insure domestic tranquility, provide for the common defense,
promote the general welfare, and secure the blessings of liberty to ourselves
and our posterity, do ordain and establish this Constitution for the United
States of America.&quot;&quot;&quot;
</code></pre>

<h3 id="lists">Lists</h3>

<p>Lists (arrays) are signified with brackets and delimited with commas.  Only
primitives are allowed in this form, though you may have nested lists.  The
format is forgiving, ignoring whitespace and newlines, and yes, the last comma
is optional (thank you!):</p>

<pre><code>foo = [ &quot;bar&quot;, &quot;baz&quot;
        &quot;bat&quot;
]

nums = [ 1, 2, ]

nested = [[ &quot;a&quot;, &quot;b&quot;], [1, 2]]
</code></pre>

<p>I love that the format is forgiving of whitespace and that last comma.  I like
that the arrays are all of a single type, but allowing mixed types of sub-arrays
bugs the heck out of me.</p>

<h3 id="now-we-get-crazy">Now we get crazy</h3>

<p>What&rsquo;s left?  In JSON there are objects, in YAML there are associative arrays&hellip;
in common parlance they are maps or dictionaries or hash tables.  Named
collections of key/value pairs.</p>

<p>In TOML they are called tables and look like this:</p>

<pre><code># some config above
[table_name]
foo = 1
bar = 2
</code></pre>

<p>Foo and bar are keys in the table called table_name.  Tables have to be at the
end of the config file. Why?  because there&rsquo;s no end delimiter.  All keys under
a table declaration are associated with that table, until a new table is
declared or the end of the file.  So declaring two tables looks like this:</p>

<pre><code># some config above
[table1]
foo = 1
bar = 2

[table2]
	foo = 1
	baz = 2
</code></pre>

<p>The declaration of table2 defines where table1 ends.  Note that you can indent
the values if you want, or not.  TOML doesn&rsquo;t care.</p>

<p>If you want nested tables, you can do that, too.  It looks like this:</p>

<pre><code>[table1]
	foo = &quot;bar&quot;

[table1.nested_table]
	baz = &quot;bat&quot;
</code></pre>

<p><code>nested_table</code> is defined as a value in <code>table1</code> because its name starts with
<code>table1.</code>.  Again, the table goes until the next table definition, so <code>baz=&quot;bat&quot;</code>
is a value in <code>table1.nested_table</code>.  You can indent the nested table to make it
more obvious, but again, all whitespace is optional:</p>

<pre><code>[table1]
	foo = &quot;bar&quot;

	[table1.nested_table]
		baz = &quot;bat&quot;
</code></pre>

<p>This is equivalent to the JSON:</p>

<pre><code>{ 
	&quot;table1&quot; : {
		&quot;foo&quot; : &quot;bar&quot;,
		&quot;nested_table&quot; : {
			&quot;baz&quot; : &quot;bat&quot;
		}
	}
}
</code></pre>

<p>Having to retype the parent table name for each sub-table is kind of annoying,
but I do like that it is very explicit.  It also means that ordering and
indenting and delimiters don&rsquo;t matter.  You don&rsquo;t have to declare parent tables
if they&rsquo;re empty, so you can do something like this:</p>

<pre><code>[foo.bar.baz]
bat = &quot;hi&quot;
</code></pre>

<p>Which is the equivalent to this JSON:</p>

<pre><code>{
	&quot;foo&quot; : {
		&quot;bar&quot; : {
			&quot;baz&quot; : {
				&quot;bat&quot; : &quot;hi&quot;
			}
		}
	}
}
</code></pre>

<h3 id="last-but-not-least">Last but not least</h3>

<p>The last thing is arrays of tables, which are declared with double brackets
thusly:</p>

<pre><code>[[comments]]
author = &quot;Nate&quot;
text = &quot;Great Article!&quot;

[[comments]]
author = &quot;Anonymous&quot;
text = &quot;Love it!&quot;
</code></pre>

<p>This is equivalent to the JSON:</p>

<pre><code>{
	&quot;comments&quot; : [
		{
			&quot;author&quot; : &quot;Nate&quot;,
			&quot;text&quot; : Great Article!&quot;
		},
		{
			&quot;author&quot; : &quot;Anonymous&quot;,
			&quot;text&quot; : Love It!&quot;
		}
	]
}
</code></pre>

<p>Arrays of tables inside another table get combined in the way you&rsquo;d expect, like
[[table1.array]].</p>

<p>TOML is very permissive here. Because all tables have very explicitly defined
parentage, the order they&rsquo;re defined in doesn&rsquo;t matter. You can have tables (and
entries in an array of tables) in whatever order you want.  This is totally
acceptable:</p>

<pre><code>[[comments]]
author = &quot;Anonymous&quot;
text = &quot;Love it!&quot;

[foo.bar.baz]
bat = &quot;hi&quot;

[foo.bar]
howdy = &quot;neighbor&quot;

[[comments]]
author = &quot;Anonymous&quot;
text = &quot;Love it!&quot;
</code></pre>

<p>Of course, it generally makes sense to actually order things in a more organized
fashion, but it&rsquo;s nice that you can&rsquo;t shoot yourself in the foot if you reorder
things &ldquo;incorrectly&rdquo;.</p>

<h3 id="conclusion">Conclusion</h3>

<p>That&rsquo;s TOML.  It&rsquo;s pretty awesome.</p>

<p>There&rsquo;s a <a href="https://github.com/toml-lang/toml#implementations">list of parsers</a>
on the TOML page on github for pretty much whatever language you want.  I
recommend <a href="http://github.com/BurntSushi/toml">BurntSushi</a>&rsquo;s for Go, since it
works just like the built-in parsers.</p>

<p>It is now my default configuration language for all the applications I write.</p>

<p>The next time you write an application that needs some configuration, take a
look at TOML.  I think your users will thank you.</p>

  </div>
  
  
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2014/08/making-it-a-series/">
        Making It a Series
      </a>
    </h1>

    <span class="post-date">Aug 8, 2014</span>

    
      
      <p class="seriesname">Series: <a href="https://npf.io/series/hugo-101">Hugo 101</a></p>
    


    <p>I obviously have a lot to talk about with Hugo, so I decided I wanted to make
this into a series of posts, and have links at the bottom of each post
automatically populated with the other posts in the series.  This turned out to
be somewhat of a challenge, but doable with some effort&hellip; hopefully someone
else can learn from my work.</p>

<p>This now brings us to <a href="http://gohugo.io/taxonomies/overview">Taxonomies</a>.
Taxonomies are basically just like tags, except that you can have any number of
different types of tags.  So you might have &ldquo;Tags&rdquo; as a taxonomy, and thus you
can give a content tags with values of &ldquo;go&rdquo; and &ldquo;programming&rdquo;.  You can also
have a taxonomy of &ldquo;series&rdquo; and give content a series of &ldquo;Hugo 101&rdquo;.</p>

<p>Taxonomy is sort of like relatable metadata to gather multiple pieces of content
together in a structured way&hellip; it&rsquo;s almost like a minimal relational database.
Taxonomies are listed in your site&rsquo;s metadata, and consist of a list of keys.
Each piece of content can specify one or more values for those keys (the Hugo
documentation calls the values &ldquo;Terms&rdquo;).  The values are completely ad-hoc, and
don&rsquo;t need to be pre-defined anywhere.  Hugo automatically creates pages where
you can view all content based on Taxonomies and see how the various values are
cross-referenced against other content.  This is a way to implement tags on
posts, or series of posts.</p>

<p>So, for my example, we add a Taxonomy to my site config called &ldquo;series&rdquo;.  Then
in this post, the &ldquo;Hugo: Beyond the Defaults&rdquo; post, and the &ldquo;Hugo is Friggin&rsquo;
Awesome&rdquo; post, I just add <code>series = [&quot;Hugo 101&quot;]</code>  (note the brackets - the
values for the taxonomy are actually a list, even if you only have one value).
Now all these posts are magically related together under a taxonomy called
&ldquo;series&rdquo;.  And Hugo automatically generates a listing for this taxonomy value
at <a href="http://npf.io/series/hugo-101">/series/hugo-101</a> (the taxonomy value gets
url-ized).  Any other series I make will be under a similar directory.</p>

<p>This is fine and dandy and pretty aweomse out of the box&hellip; but I really want to
automatically generate a list of posts in the series at the bottom of each post
in the series.  This is where things get tricky, but that&rsquo;s also where things
get interesting.</p>

<p>The examples for <a href="http://gohugo.io/taxonomies/displaying">displaying
Taxonomies</a> all &ldquo;hard code&rdquo; the
taxonomy value in the template&hellip; this works great if you know ahead of time
what value you want to display, like &ldquo;all posts with tag = &lsquo;featured&rsquo;&rdquo;.
However, it doesn&rsquo;t work if you don&rsquo;t know ahead of time what the taxonomy value
will be (like the series on the current post).</p>

<p>This is doable, but it&rsquo;s a little more complicated.</p>

<p>I&rsquo;ll give you a dump of the relevant portion of my post template and then talk
about how I got there:</p>

<pre><code>{{ if .Params.series }}
    {{ $name := index .Params.series 0 }}
    &lt;hr/&gt;
	&lt;p&gt;&lt;a href=&quot;&quot; id=&quot;series&quot;&gt;&lt;/a&gt;This is a post in the 
	&lt;b&gt;{{$name}}&lt;/b&gt; series.&lt;br/&gt;
	Other posts in this series:&lt;/p&gt;

    {{ $name := $name | urlize }}
    {{ $series := index .Site.Taxonomies.series $name }}
    &lt;ul class=&quot;series&quot;&gt;
    {{ range $series.Pages }}
    	&lt;li&gt;{{.Date.Format &quot;Jan 02, 2006&quot;}} -
    	&lt;a href=&quot;{{.Permalink}}&quot;&gt;{{.LinkTitle}}&lt;/a&gt;&lt;/li&gt;
    {{end}}
    &lt;/ul&gt;
{{end}} 
</code></pre>

<p>So we start off defining this part of the template to only be used if the post
has a series.  Right, sure, move on.</p>

<p>Now, the tricky part&hellip; the taxonomy values for the current page resides in the
.Params values, just like any other custom metadata you assign to the page.</p>

<p>Taxonomy values are always a list (so you can give things multiple tags etc),
but I know that I&rsquo;ll never give something more than one series, so I can just
grab the first item from the list.  To do that, I use the index function, which
is just like calling series[0] and assign it to the $name variable.</p>

<p>Now another tricky part&hellip; the series in the metadata is in the pretty form you
put into the metadata, but the list of Taxonomies in .Site.Taxonomies is in the
urlized form&hellip;  How did I figure that out?  Printf
debugging.  Hugo&rsquo;s auto-reloading makes it really easy to use the template
itself to figure out what&rsquo;s going on with the template and the data.</p>

<p>When I started writing this template, I just put <code>{{$name}}</code> in my post template
after the line where I got the name, and I could see it rendered on webpage of
my post that the name was &ldquo;Hugo 101&rdquo;.  Then I put <code>{{.Site.Taxonomies.series}}</code>
and I saw something like <code>map[hugo-101:[{0 0xc20823e000} {0 0xc208048580} {0
0xc208372000}]]</code>  which is ugly, but it showed me that the value in the map is
&ldquo;hugo-101&rdquo;&hellip; and I realized it was using the urlized version, so I used the
pre-defined hugo function <code>urlize</code> to convert the pretty series.</p>

<p>And from there it&rsquo;s just a matter of using <code>index</code> again, this time to use
<code>$name</code> as a key in the map of series&hellip;.  .Site.Taxonomies is a map
(dictionary) of Taxonomy names (like &ldquo;series&rdquo;) to maps of Taxonomy values (like
&ldquo;hugo-101&rdquo;) to lists of pages.  So, .Site.Taxonomies.series reutrns a map of
series names to lists of pages&hellip; index that by the current series names, and
bam, list of pages.</p>

<p>And then it&rsquo;s just a matter of iterating over the pages and displaying them
nicely. And what&rsquo;s great is that this is now all automatic&hellip; all old posts get
updated with links to the new posts in the series, and any new series I make,
regardless of the name, will get the nice list of posts at the bottom for that
series.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2014/08/hugo-beyond-the-defaults/">
        Hugo: Beyond the Defaults
      </a>
    </h1>

    <span class="post-date">Aug 8, 2014</span>

    
      
      <p class="seriesname">Series: <a href="https://npf.io/series/hugo-101">Hugo 101</a></p>
    


    <p>In my last post, I had deployed what is almost the most basic Hugo site
possible.  The only reason it took more than 10 minutes is because I wanted to
tweak the theme.  However, there were a few things that immediately annoyed me.</p>

<p>I didn&rsquo;t like having to type <code>hugo -t hyde</code> all the time.  Well, turns out
that&rsquo;s not necessary.  You can just put  <code>theme = &quot;hyde&quot;</code> in your site
config, and never need to type it again.  Sweet.  Now to run the local server, I
can just run <code>hugo server -w</code>, and for final generation, I can just run <code>hugo</code>.</p>

<p>Next is that my posts were under npf.io/post/postname &hellip; which is not the end
of the world, but I really like seeing the date in post URLs, so that it&rsquo;s easy
to tell if I&rsquo;m looking at something really, really old.  So, I went about
looking at how to do that.  Turns out, it&rsquo;s trivial.  Hugo has a feature called
<a href="http://gohugo.io/extras/permalinks">permalinks</a>, where you can define the
format of the url for a section (a section is a top level division of your site,
denoted by a top level folder under content/).  So, all you have to do is, in
your site&rsquo;s config file, put some config that looks like this:</p>

<pre><code>[permalinks]
    post = &quot;/:year/:month/:filename/&quot;
    code = &quot;/:filename/&quot;
</code></pre>

<p>While we&rsquo;re at it, I had been putting my code in the top level content
directory, because I wanted it available at npf.io/projectname  &hellip;. however
there&rsquo;s no need to do that, I can put the code under the code directory and just
give it a permalink to show at the top level of the site.  Bam, awesome, done.</p>

<p>One note: Don&rsquo;t forget the slash at the end of the permalink.</p>

<p>But wait, this will move my &ldquo;Hugo is Friggin&rsquo; Awesome&rdquo; post to a different URL,
and Steve Francia already tweeted about it with the old URL.  I don&rsquo;t want that
url to send people to a 404 page!
<a href="http://gohugo.io/extras/aliases">Aliases</a> to the rescue.  Aliases are just
a way to make redirects from old URLs to new ones.  So I just put <code>aliases =
[&quot;/post/hugo-is-awesome/&quot;]</code> in the metadata at the top of that post, and now
links to there will redirect to the new location.  Awesome.</p>

<p>Ok, so cool&hellip; except that I don&rsquo;t really want the content for my blog posts
under content/post/ &hellip; I&rsquo;d prefer them under content/blog, but still be of type
&ldquo;post&rdquo;.  So let&rsquo;s change that too.  This is pretty easy, just rename the folder
from post to blog, and then set up an
<a href="http://gohugo.io/content/archetypes">archetype</a> to default the metadata
under /blog/ to type = &ldquo;post&rdquo;.  Archetypes are default metadata for a section,
so in this case, I make a file archetypes/blog.md and add type= &ldquo;post&rdquo; to the
archetype&rsquo;s metadata, and now all my content created with <code>hugo new
blog/foo.md</code> will be prepopulated as type &ldquo;post&rdquo;.  (does it matter if the type
is post vs. blog?  no.  But it matters to me ;)</p>

<p><a href="https://twitter.com/mlafeldt">@mlafeldt</a> on Twitter pointed out my RSS feed was
wonky&hellip;. wait, I have an RSS feed?  Yes, Hugo <a href="http://gohugo.io/templates/rss">has that
too</a>.  There are feed XML files
automatically output for most listing directories&hellip; and the base feed for the
site is a list of recent content.  So, I looked at what Hugo had made for me
(index.xml in the root output directory)&hellip; this is not too bad, but I don&rsquo;t
really like the title, and it&rsquo;s including my code content in the feed as well as
posts, which I don&rsquo;t really want.  Luckily, this is trivial to fix.  The RSS xml
file is output using a Go template just like everything else in the output.
It&rsquo;s trivial to adjust the template so that it only lists content of type
&ldquo;post&rdquo;, and tweak the feed name, etc.</p>

<p>I was going to write about how I got the series stuff at the bottom of this
page, but this post is long enough already, so I&rsquo;ll just make that into its own
post, as the next post in the series! :)</p>

  </div>
  
  
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2014/08/hugo-is-awesome/">
        Hugo Is Friggin&#39; Awesome
      </a>
    </h1>

    <span class="post-date">Aug 1, 2014</span>

    
      
      <p class="seriesname">Series: <a href="https://npf.io/series/hugo-101">Hugo 101</a></p>
    


    <p>This blog is powered by <a href="http://gohugo.io">Hugo</a>, a static site generator
written by Steve Francia (aka spf13).  It is, of course, written in Go.  It is
pretty similar to <a href="jekyllrb.com">Jekyll</a>, in that you write markdown, run a
little program (hugo) and html pages come out the other end in the form of a
full static site.  What&rsquo;s different is that Jekyll is written in ruby and is
relatively slow, and Hugo is written in Go and is super fast&hellip; only taking a
few milliseconds to render each page.</p>

<p>Hugo includes a webserver to serve the content, which will regenerate the site
automatically when you change your content.  Your browser will update with the
changes immediately, making your development cycle for a site a very tight
loop.</p>

<p>The basic premise of Hugo is that your content is organized in a specific way on
purpose.  Folders of content and the name of the files combine to turn into the
url at which they are hosted. For example, content/foo/bar/baz.md will be hosted
at &lt;site&gt;/foo/bar/baz.</p>

<p>Every content file has a section of metadata at the top that allows you to
specify information about the content, like the title, date, even arbitrary data
for your specific site (for example, I have lists of badges that are shown on
pages for code projects).</p>

<p>All the data in a content file is just that - data.  Other than markdown
specifying a rough view of your page, the actual way the content is viewed is
completely separated from the data.  Views are written in Go&rsquo;s templating
language, which is quick to pick up and easy to use if you&rsquo;ve used other
templating languages (or even if, like me, you haven&rsquo;t).  This lets you do
things like iterate over all the entries in a menu and print them out in a ul/li
block, or iterate over all the posts in your blog and display them on the main
page.</p>

<p>You can learn more about Hugo by going to <a href="http://gohugo.io">its site</a>,
which, of course, is built using Hugo.</p>

<p>The static content for this site is hosted on github pages at
<a href="https://github.com/natefinch/natefinch.github.io">https://github.com/natefinch/natefinch.github.io</a>. But the static content is
relatively boring&hellip; that&rsquo;s what you&rsquo;re looking at in your browser right now.
What&rsquo;s interesting is the code behind it.  That lives in a separate repo on
github at <a href="https://github.com/natefinch/npf">https://github.com/natefinch/npf</a>.  This is where the markdown content
and templates live.</p>

<p>Here&rsquo;s how I have things set up locally&hellip; all open source code on my machine
lives in my GOPATH (which is set to my HOME).  So, it&rsquo;s easy to find anything I
have ever downloaded. Thus, the static site lives at
$GOPATH/src/github.com/natefinch/natefinch.github.io and the markdown +
templates lives in $GOPATH/src/github.com/natefinch/npf.  I created a symbolic
link under npf called public that points to the natefinch.github.io directory.
This is the directory that hugo outputs the static site to by default&hellip; that
way Hugo dumps the static content right into the correct directory for me to
commit and push to github.  I just had to add public to my .gitignore so
everyone wouldn&rsquo;t get confused.</p>

<p>Then, all I do is go to the npf directory, and run</p>

<pre><code>hugo new post/urlofpost.md
hugo server --buildDrafts --watch -t hyde
</code></pre>

<p>That generates a new content item that&rsquo;ll show up on my site under
/post/urlofpost.  Then it runs the local webserver so I can watch the content by
pointing a browser at localhost:1313 on a second monitor as I edit the post in a
text editor. hyde is the name of the theme I&rsquo;m using, though I have modified
it.  Note that hugo will mark the content as a draft by default, so you need
&ndash;buildDrafts for it to get rendered locally, and remember to delete the draft =
true line in the page&rsquo;s metadata when you&rsquo;re ready to publish, or it won&rsquo;t show
up on your site.</p>

<p>When I&rsquo;m satisfied, kill the server, and run</p>

<pre><code>hugo -t hyde
</code></pre>

<p>to generate the final site output, switch into the public directory, and</p>

<pre><code>git commit -am &quot;some new post&quot;
</code></pre>

<p>That&rsquo;s it.  Super easy, super fast, and no muss.  Coming from Blogger, this is
an amazingly better workflow with no wrestling with the WYSIWYG editor to make
it display stuff in a reasonable fashion.  Plus I can write posts 100% offline
and publish them when I get back to civilization.</p>

<p>There&rsquo;s a lot more to Hugo, and a lot more I want to do with the site, but that
will come in time and with more posts :)</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2014/08/first/">
        First Post
      </a>
    </h1>

    <span class="post-date">Aug 1, 2014</span>

    


    <p>This is the first post of my new blog.  You may (eventually) see old posts
showing up behind here, those have been pulled in from my personal blog at
<a href="http://blog.natefinch.com">blog.natefinch.com</a>. I&rsquo;ve decided to split off my
programming posts so that people who only want to see the coding stuff don&rsquo;t
have to see my personal posts, and people that only want to see my personal
stuff don&rsquo;t have to get inundated with programming posts.</p>

<p>Right now the site is pretty basic, but I will add more features to it, such as post history etc.</p>

  </div>
  
  
  
  
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2014/07/ci-for-windows-go-packages-with-appveyor/">
        CI for Windows Go Packages with AppVeyor
      </a>
    </h1>

    <span class="post-date">Jul 9, 2014</span>

    


    <p>I recently needed to update my <a href="https://github.com/natefinch/npipe" target="_blank">npipe</a> package, and since I want it to be production quality, that means setting up CI, so that people using my package can know it&rsquo;s passing tests. &nbsp;Normally I&rsquo;d use Travis CI or Drone.io for that, but npipe is a Windows-only Go package, and neither of the aforementioned services support running tests on Windows.<br /><br />With some googling, I saw that <a href="https://twitter.com/nathany" target="_blank">Nathan Youngman</a>&nbsp;had worked with&nbsp;<a href="http://www.appveyor.com/" target="_blank">AppVeyor</a>&nbsp;to add Go support to their CI system. &nbsp;The example on the blog talks about making a build.cmd file in your repo to enable Go builds, but I found that you can easily set up a Go build without having to put CI-specific files in your repo.<br /><br />To get started with AppVeyor, just log into their site and tell it where to get your code (I logged in with Github, and it was easy to specify what repo of mine to test). &nbsp;Once you choose the repo, go to the Settings page on AppVeyor for that repo. &nbsp;Under the Environment tab on the left, set the clone directory to C:\GOPATH\src&amp;lt;your import path&gt; and set an environment variable called GOPATH to C:\GOPATH. &nbsp;Under the build tab, set the build type to &ldquo;SCRIPT&rdquo; and the script type to &ldquo;CMD&rdquo;, and make the contents of the script <pre style="tab-size: 4;">go get -v -d -t &lt;your import path&gt;/&hellip;</pre> (this will download the dependencies for your package). &nbsp;In the test tab, set the test type to &ldquo;SCRIPT&rdquo;, the script type to &ldquo;CMD&rdquo; and the script contents to <pre style="tab-size: 4;">go test -v -cover ./&hellip;</pre> &nbsp;(this will run all the tests in verbose mode and also output the test coverage).<br /><br />That&rsquo;s pretty much it. &nbsp;AppVeyor will automatically run a build on commits, like you&rsquo;d expect. &nbsp;You can watch the progress on a console output on their page, and get a pretty little badge from the badges page. &nbsp;It&rsquo;s free for open source projects, and seems relatively responsive from my admittedly limited experience.<br /><br />This is a great boon for Go developers, so you can be sure your code builds and passes tests on Windows, with very little work to set it up. &nbsp;I&rsquo;m probably going to add this to all my production repos, even the ones that aren&rsquo;t Windows-only, to ensure my code works well on Windows as well as Linux.<br /><br /><br /></p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2014/07/intro-to-boltdb-painless-performant-persistence/">
        Intro to BoltDB: Painless Performant Persistence
      </a>
    </h1>

    <span class="post-date">Jul 7, 2014</span>

    


    <p><a href="http://github.com/boltdb/bolt" target="_blank">BoltDB</a> is a pure Go persistence solution that saves data to a memory mapped file.  I call it a persistence solution and not a database, because the word database has a lot of baggage associated with it that doesn&rsquo;t apply to bolt. And that lack of baggage is what makes bolt so awesome.<br /><br />Bolt is just a Go package.  There&rsquo;s nothing you need to install on the system, no configuration to figure out before you can start coding, nothing.  You just go get github.com/boltdb/bolt and then import &ldquo;github.com/boltdb/bolt&rdquo;. <br /><br />All you need to fully use bolt as storage is a file name.  This is fantastic from both a developer&rsquo;s point of view, and a user&rsquo;s point of view.  I don&rsquo;t know about you, but I&rsquo;ve spent months of work time over my career configuring and setting up databases and debugging configuration problems, users and permissions and all the other crap you get from more traditional databases like Postgres and Mongo.  There&rsquo;s none of that with bolt.  No users, no setup, just a file name.  This is also a boon for users of your application, because <em>they</em> don&rsquo;t have to futz with all that crap either.<br /><br />Bolt is not a relational database.  It&rsquo;s not even a document store, though you can sort of use it that way.  It&rsquo;s really just a key/value store&hellip; but don&rsquo;t worry if you don&rsquo;t really know what that means or how you&rsquo;d use that for storage.  It&rsquo;s super simple and it&rsquo;s incredibly flexible.  Let&rsquo;s take a look.<br /><br />Storage in bolt is divided into buckets.  A bucket is simply a named collection of key/value pairs, just like Go&rsquo;s map.  The name of the bucket, the keys, and the values are all of type []byte.  Buckets can contain other buckets, also keyed by a []byte name. <br /><br />&hellip; that&rsquo;s it.  No, really, that&rsquo;s it.  Bolt is basically a bunch of nested maps.  And this simplicity is what makes it so easy to use.  There&rsquo;s no tables to set up, no schemas, no complex querying language to struggle with.  Let&rsquo;s look at a bolt hello world:<br /><br /><pre>package main<br /><br />import (<br />    &ldquo;fmt&rdquo;<br />    &ldquo;log&rdquo;<br /><br />    &ldquo;github.com/boltdb/bolt&rdquo;<br />)<br /><br />var world = []byte(&ldquo;world&rdquo;)<br /><br />func main() {<br />    db, err := bolt.Open(&ldquo;/home/nate/foo/bolt.db&rdquo;, 0644, nil)<br />    if err != nil {<br />        log.Fatal(err)<br />    }<br />    defer db.Close()<br /><br />    key := []byte(&ldquo;hello&rdquo;)<br />    value := []byte(&ldquo;Hello World!&rdquo;)<br /><br />    // store some data<br />    err = db.Update(func(tx *bolt.Tx) error {<br />        bucket, err := tx.CreateBucketIfNotExists(world)<br />        if err != nil {<br />            return err<br />        }<br /><br />        err = bucket.Put(key, value)<br />        if err != nil {<br />            return err<br />        }<br />        return nil<br />    })<br /><br />    if err != nil {<br />        log.Fatal(err)<br />    }<br /><br />    // retrieve the data<br />    err = db.View(func(tx *bolt.Tx) error {<br />        bucket := tx.Bucket(world)<br />        if bucket == nil {<br />            return fmt.Errorf(&ldquo;Bucket %q not found!&rdquo;, world)<br />        }<br /><br />        val := bucket.Get(key)<br />        fmt.Println(string(val))<br /><br />        return nil<br />    })<br /><br />    if err != nil {<br />        log.Fatal(err)<br />    }<br />}<br /><br />// output:<br />// Hello World!</pre><div></div>I know what you&rsquo;re thinking - that seems kinda long.  But keep in mind, I fully handled all errors in at least a semi-proper way, and we&rsquo;re doing all this:<br /><br />1.) creating a database <br />2.) creating some structure (the &ldquo;world&rdquo; bucket)<br />3.) storing data to the structure<br />4.) retrieving data from the structure.<br /><br />I think that&rsquo;s not too bad in 54 lines of code.<br /><br />So let&rsquo;s look at what that example is really doing.  First we call bolt.Open to get the database.  This will create the file if necessary, or open it if it exists.<br /><br />All reads from or writes to the bolt database must be done within a transaction. You can have as many Readers in read-only transactions at the same time as you want, but only one Writer in a writable transaction at a time (readers maintain a consistent view of the DB while writers are writing).<br /><br />To begin, we call db.Update, which takes a function to which it&rsquo;ll pass a bolt.Tx - bolt&rsquo;s transaction object.  We then create a Bucket (since all data in bolt lives in buckets), and add our key/value pair to it.  After the write transaction finishes, we start a read- only transaction with DB.View, and get the values back out.<br /><br />What&rsquo;s great about bolt&rsquo;s transaction mechanism is that it&rsquo;s super simple - the scope of the function is the scope of the transaction.  If the function passed to Update returns nil, all updates from the transaction are atomically stored to the database.  If the function passed to Update returns an error, the transaction is rolled back.  This makes bolt&rsquo;s transactions completely intuitive from a Go developer&rsquo;s point of view.  You just exit early out of your function by returning an error as usual, and bolt Does The Right Thing.  No need to worry about manually rolling back updates or anything, just return an error.<br /><br />The only other basic thing you may need is to iterate over key/value pairs in a Bucket, in which case, you just call bucket.Cursor(), which returns a Cursor value, which has functions like Next(), Prev() etc that return a key/value pair and work like you&rsquo;d expect.<br /><br />There&rsquo;s a lot more to the bolt API, but most of the rest of it is more about database statistics and some stuff for more advanced usage scenarios&hellip; but the above is all you really need to know to start storing data in a bolt database.<br /><br />For a more complex application, just storing strings in the database may not be sufficient, but that&rsquo;s ok, Go has your back there, too.  You can easily use encoding/json or encoding/gob to serialize structs into the database, keyed by a unique name or id.  This is what makes it easy for bolt to go from a key/value store to a document store - just have one bucket per document type.  Again, the benefit of bolt is low barrier of entry.  You don&rsquo;t have to figure out a whole database schema or install anything to be able to just start dumping data to disk in a performant and manageable way.<br /><br />The main drawback of bolt is that there are no queries.  You can&rsquo;t say &ldquo;give me all foo objects with a name that starts with bar&rdquo;.  You <i>could</i> make your own index in the database and keep it up to date manually.  This could be as easy as a slice of IDs serialized into an &ldquo;indices&rdquo; bucket for a particular query. Obviously, this is where you start getting into the realm of developing your own relational database, but if you don&rsquo;t go overboard, it can be nice that all this code is just that - code.  It&rsquo;s not queries in some external DSL, it&rsquo;s just code like you&rsquo;d write for an in-memory data store.<br /><br />Bolt is not for every application.  You must understand your application&rsquo;s needs and if bolt&rsquo;s key/value style will be sufficient to fulfill those needs.  If it is, I think you&rsquo;ll be very happy to use such a simple data store with so little mental overhead.<br /><br />[edited to clarify reader/writer relationship]   Bonus Gob vs. Json benchmark for storing structs in Bolt: <pre><br />BenchmarkGobEncode  1000000       2191 ns/op<br />BenchmarkJsonEncode   500000       4738 ns/op<br />BenchmarkGobDecode  1000000       2019 ns/op<br />BenchmarkJsonDecode   200000      12993 ns/op<br /></pre>Code: <a href="http://play.golang.org/p/IvfDUGBpJ6">http://play.golang.org/p/IvfDUGBpJ6</a></p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2014/06/autogenerate-docs-with-this-one-dumb-trick/">
        Autogenerate docs with this one dumb trick
      </a>
    </h1>

    <span class="post-date">Jun 17, 2014</span>

    


    <p>Yesterday, I was trying to think of a way of automating some doc generation for my go packages.  The specific task I wanted to automate was updating a badge in my package&rsquo;s README to show the test coverage.  What I wanted was a way to run go test -cover, parse the results, and put the result in the correct spot of my README.  My first thought was to write an application that would do that for me &hellip; but then I&rsquo;d have to run that <i>instead</i> of go test.  What I realized I wanted was something that was &ldquo;compatible with go test&rdquo; - i.e. I want to run go test and not have to remember to run some special other command.<br /><br />And that&rsquo;s when it hit me:  What is a test in Go?  A test is a Go function that gets run when you run &ldquo;go test&rdquo;. &nbsp;Nothing says your test has to actually test anything. &nbsp;And nothing prevents your test from doing something permanent on your machine (in fact we usually have to bend over backwards to make sure our tests <i>don&rsquo;t</i>&nbsp;do anything permanent. &nbsp;You can just write a test function that updates the docs for you.<br /><br />I actually quite like this technique. &nbsp;I often have some manual tasks after updating my code - usually updating the docs in the README with changes to the API, or changing the docs to show new CLI flags, etc. &nbsp;And there&rsquo;s one thing I always do after I update my code - and that&rsquo;s run &ldquo;go test&rdquo;. &nbsp;If that also updates my docs, all the better.<br /><br />This is how covergen was born. &nbsp;<a href="https://github.com/natefinch/covergen">https://github.com/natefinch/covergen</a><br /><br />Covergen is a particularly heinous example of a test that updates your docs. &nbsp;The heinous part is that it actually doubles the time it takes to run your tests&hellip; this is because that one test re-runs all the tests with -cover to get the coverage percent. &nbsp;I&rsquo;m not sure I&rsquo;d actually release real code that used such a thing - doubling the time it takes to run your tests just to save a few seconds of copy and paste is pretty terrible.<br /><br />However, it&rsquo;s a valid example of what you can do when you throw away testing convention and decide you want to write some code in a test that doesn&rsquo;t actually test anything, and instead just runs some automated tasks that you want run whenever anyone runs go test. &nbsp;Just make sure the result is idempotent so you&rsquo;re not continually causing things to look modified to version control.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2014/05/diffing-go-with-beyond-compare/">
        Diffing Go with Beyond Compare
      </a>
    </h1>

    <span class="post-date">May 14, 2014</span>

    


    <p>I love Beyond Compare, it&rsquo;s an awesome visual diff/merge tool. &nbsp;It&rsquo;s not free, but I don&rsquo;t care, because it&rsquo;s awesome. &nbsp;However, there&rsquo;s no built-in configuration for Go code, so I made one. &nbsp;Not sure what the venn diagram of Beyond Compare users and Go users looks like, it might be that I&rsquo;m the one point of crossover, but just in case I&rsquo;m not, here&rsquo;s the configuration file for Beyond Compare 3 for the Go programming language:&nbsp;<a href="http://play.golang.org/p/G6NWE0z1GC">http://play.golang.org/p/G6NWE0z1GC</a> &nbsp;(please forgive the abuse of the Go playground)<br /><br />Just copy the text into a file and in Beyond Compare, go to Tools-&gt;Import Settings&hellip; and choose the file. &nbsp;Please let me know if you have any troubles or suggested improvements.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2014/05/intro-to-go-interfaces/">
        Intro&#43;&#43; to Go Interfaces
      </a>
    </h1>

    <span class="post-date">May 13, 2014</span>

    


    

<h3 id="standard-interface-intro">Standard Interface Intro</h3>

<p>Go’s interfaces are one of it’s best features, but they’re also one of the most confusing for newbies.  This post will try to give you the understanding you need to use Go’s interfaces and not get frustrated when things don’t work the way you expect.  It’s a little long, but a bunch of that is just code examples.</p>

<p>Go’s interfaces are different than interfaces in other languages, they are implicitly fulfilled.  This means that you never need to mark your type as explicitly implementing the interface (like class CFoo implements IFoo).  Instead, your type just needs to have the methods defined in the interface, and the compiler does the rest.</p>

<p>For example:</p>

<pre><code>type Walker interface {
    Walk(miles int)
}

type Camel struct {
    Name string
}

func (c Camel) Walk(miles int) {
     fmt.Printf(“%s is walking %v miles\n”, c.Name, miles)
}

func LongWalk(w Walker) {
     w.Walk(500)
     w.Walk(500)
}

func main() {
    c := Camel{“Bill”}
    LongWalk(c)
}

// prints
// Bill is walking 500 miles.
// Bill is walking 500 miles.
</code></pre>

<p><a href="http://play.golang.org/p/erodX-JplO">http://play.golang.org/p/erodX-JplO</a></p>

<p>Camel implements the Walker interface, because it has a method named Walk that
takes an int and doesn’t return anything.  This means you can pass it into the
LongWalk function, even though you never specified that your Camel is a Walker.
In fact, Camel and Walker can live in totally different packages and never know
about one another, and this will still work if a third package decides to make a
Camel and pass it into LongWalk.</p>

<h3 id="non-standard-continuation">Non-Standard Continuation</h3>

<p>This is where most tutorials stop, and where most questions and problems begin.
The problem is that you still don’t know how the interfaces actually work, and
since it’s not actually that complicated, let’s talk about that.</p>

<p>What actually happens when you pass Camel into LongWalk?</p>

<p>So, first off, you’re not passing Camel into LongWalk.  You’re actually
assigning c, a value of type Camel to a value w of type Walker, and w is what
you operate on in LongWalk.</p>

<p>Under the covers, the Walker interface (like all interfaces), would look more or
less like this if it were in Go (the actual code is in C, so this is just a
really rough approximation that is easier to read).</p>

<pre><code>type Walker struct {
    type InterfaceType
    data *void
}

type InterfaceType struct {
    valtype *gotype
    func0 *func
    func1 *func
    ...
}
</code></pre>

<p>All interfaces values are just two pointers - one pointer to information about
the interface type, and one pointer to the data from the value you passed into
the interface (a void in C-like languages… this should probably be Go’s
unsafe.Pointer, but I liked the explicitness of two actual *’s in the struct to
show it’s just two pointers).</p>

<p>The InterfaceType contains a pointer to information about the type of the value
that you passed into the interface (valtype).  It also contains pointers to the
methods that are available on the interface.</p>

<p>When you assign c to w, the compiler generates instructions that looks more or
less like this (it’s not actually generating Go, this is just an easier-to-read
approximation):</p>

<pre><code>data := c
w := Walker{ 
    type: &amp;InterfaceType{ 
              valtype: &amp;typeof(c), 
              func0: &amp;Camel.Walk 
          }
    data: &amp;data
}
</code></pre>

<p>When you assign your Camel value c to the Walker value w, the Camel type is
copied into the interface value’s Type.valtype field.  The actual data in the
value of c is copied into a new place in memory, and w’s Data field points at
that memory location.</p>

<h3 id="implications-of-the-implementation">Implications of the Implementation</h3>

<p>Now, let’s look at the implications of this code.  First, interface values are
very small - just two pointers.  When you assign a value to an interface, that
value gets copied once, into the interface, but after that, it’s held in a
pointer, so it doesn’t get copied again if you pass the interface around.</p>

<p>So now you know why you don’t need to pass around pointers to interfaces -
they’re small anyway, so you don’t have to worry about copying the memory, plus
they hold your data in a pointer, so changes to the data will travel with the
interface.</p>

<h3 id="interfaces-are-types">Interfaces Are Types</h3>

<p>Let’s look at Walker again, this is important:</p>

<p>type Walker interface</p>

<p>Note that first word there: type.  Interfaces are types, just like string is a
type or Camel is a type.  They aren’t aliases, they’re not magic hand-waving,
they’re real types and real values which are distinct from the type and value
that gets assigned to them.</p>

<p>Now, let’s assume you have this function:</p>

<p>func LongWalkAll(walkers []Walker) {
    for _, w := range walkers {
        LongWalk(w)
    }
}</p>

<p>And let’s say you have a caravan of Camels that you want to send on a long walk:</p>

<pre><code>caravan := []Camel{ Camel{“Bill”}, Camel{“Bob”}, Camel{“Steve”}}
</code></pre>

<p>You want to pass caravan into LongWalkAll, will the compiler let you?  Nope.
Why is that?  Well, []Walker is a specific type, it’s a slice of values of type
Walker.  It’s not shorthand for “a slice of anything that matches the Walker
interface”.  It’s an actual distinct type, the way []string is different from
[]int.  The Go compiler will output code to assign a single value of Camel to a
single value of Walker.  That’s the only place it’ll help you out.  So, with
slices, you have to do it yourself:</p>

<pre><code>walkers := make([]Walker, len(caravan))
for n, c := range caravan {
    walkers[n] = c
}
LongWalkAll(walkers)
</code></pre>

<p>However, there’s a better way if you know you’ll just need the caravan for
passing into LongWalkAll:</p>

<pre><code>caravan := []Walker{ Camel{“Bill”}, Camel{“Bob”}, Camel{“Steve”}}
LongWalkAll(caravan)
</code></pre>

<p>Note that this goes for any type which includes an interface as part of its
definition: there’s no automatic conversion of your func(Camel) into
func(Walker) or map[string]Camel into map[string]Walker.  Again, they’re totally
different types, they’re not shorthand, and they’re not aliases, and they’re not
just a pattern for the compiler to match.</p>

<p>Interfaces and the Pointers That Satisfy Them</p>

<p>What if Camel’s Walk method had this signature instead?</p>

<pre><code>func (c *Camel) Walk(miles int)
</code></pre>

<p>This line says that the type *Camel has a function called Walk.  This is
important: *Camel is a type.  It’s the “pointer to a Camel” type.  It’s a
distinct type from (non-pointer) Camel.  The part about it being a pointer is
part of its type.  The Walk method is on the type *Camel.  The Walk method (in
this new incarnation) is not on the type Camel. This becomes important when you
try to assign it to an interface.</p>

<pre><code>c := Camel{“Bill”}
LongWalk(c)

// compiler output:
cannot use c (type Camel) as type Walker in function argument:
 Camel does not implement Walker (Walk method has pointer receiver)
</code></pre>

<p>To pass a Camel into LongWalk now, you need to pass in a pointer to a Camel:</p>

<pre><code>c := &amp;Camel{“Bill”}
LongWalk(c)

or

c := Camel{“Bill”}
LongWalk(&amp;c)
</code></pre>

<p>Note that this true even though you can still call Walk directly on Camel:</p>

<pre><code>c := Camel{“Bill”}
c.Walk(500) // this works
</code></pre>

<p>The reason you can do that is that the Go compiler automatically converts this
line to (&amp;c).Walk(500) for you.  However, that doesn’t work for passing the
value into an interface.  The reason is that the value in an interface is in a
hidden memory location, and so the compiler can’t automatically get a pointer to
that memory for you (in Go parlance, this is known as being “not addressable”).</p>

<h3 id="nil-pointers-and-nil-interfaces">Nil Pointers and Nil Interfaces</h3>

<p>The interaction between nil interfaces and nil pointers is where nearly everyone
gets tripped up when they first start with Go.</p>

<p>Let’s say we have our Camel type with the Walk method defined on *Camel as
above, and we want to make a function that returns a Walker that is actually a
Camel (note that you don’t need a function to do this, you can just assign a
*Camel to a Walker, but the function is a good illustrative example):</p>

<pre><code>func MakeWalker() Walker {
    return &amp;Camel{“Bill”}
}

w := MakeWalker()
if w != nil {
    w.Walk(500)  // we will hit this
}
</code></pre>

<p>This works fine.  But now, what if we do something a little different:</p>

<pre><code>func MakeWalker(c *Camel) Walker {
    return c
}

var c *Camel
w := MakeWalker(c)
if w != nil {
    // we’ll get in here, but why?
    w.Walk(500)
}
</code></pre>

<p>This code will also get inside the if statement (and then panic, which we’ll
talk about in a bit) because the returned Walker value is not nil.  How is that
possible, if we returned a nil pointer?  Well, let’s go look back to the
instructions that get generated when we assign a value to an interface.</p>

<pre><code>data := c
w := Walker{ 
    type: &amp;InterfaceType{ 
              valtype: &amp;typeof(c), 
              func0: &amp;Camel.Walk 
          }
    data: &amp;data
}
</code></pre>

<p>In this case, c is a nil pointer. However, that’s a perfectly valid value to
assign to the Walker’s Data value, so it works just fine.  What you return is a
non-nil Walker value, that has a pointer to a nil *Camel as its data.  So, of
course, if you check w == nil, the answer is false, w is not nil… but then
inside the if statement, we try to call Camel’s walk:</p>

<pre><code>func (c *Camel) Walk(miles int) {
     fmt.Printf(“%s is walking %v miles\n”, c.Name, miles)
}
</code></pre>

<p>And when we try to do c.Name, Go automatically turns that into (*c).Name, and
the code panics with a nil pointer dereference error.</p>

<p>Hopefully this makes sense, given our new understanding of how interfaces wrap
values, but then how do you account for nil pointers?  Assume you want
MakeWalker to return a nil interface if it gets passed a nil Camel.  You have to
explicitly assign nil to the interface:</p>

<pre><code>func MakeWalker(c *Camel) Walker {
    if c == nil {
        return nil
    }
    return c
}

var c *Camel
w := MakeWalker(c)
if w != nil {
    // Yay, we don’t get here!
    w.Walk(500)
}
</code></pre>

<p>And now, finally, the code is doing what we expect.  When you pass in a nil
*Camel, we return a nil interface.  Here’s an alternate way to write the
function:</p>

<pre><code>func MakeWalker(c *Camel) Walker {
    var w Walker
    if c != nil {
        w = c
    }
    return w
}
</code></pre>

<p>This is slightly less optimal, but it shows the other way to get a nil
interface, which is to use the zero value for the interface, which is nil.</p>

<p>Note that you can have a nil pointer value that satisfies an interface.  You
just need to be careful not to dereference the pointer in your methods.  For
example, if *Camel’s Walk method looked like this:</p>

<pre><code>func (c *Camel) Walk(miles int) {
    fmt.Printf(“I’m walking %d miles!”, miles)
}
</code></pre>

<p>Note that this method does not dereference c, and therefore you can call it even
if c is nil:</p>

<pre><code>var c *Camel
c.Walk(500)
// prints “I’m walking 500 miles!”
</code></pre>

<p><a href="http://play.golang.org/p/4EfyV21at9">http://play.golang.org/p/4EfyV21at9</a></p>

<h3 id="outro">Outro</h3>

<p>I hope this article helps you better understand how interfaces works, and helps
you avoid some of the common pitfalls and misconceptions newbies have about how
interfaces work.  If you want more information about the internals of interfaces
and some of the optimizations that I didn’t cover here, read Russ Cox’s article
on Go interfaces, I highly recommend it.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2014/04/mocking-functions-in-go/">
        Mocking functions in Go
      </a>
    </h1>

    <span class="post-date">Apr 10, 2014</span>

    


    <p>Functions in Go are first class citizens, that means you can have a variable that contains a function value, and call it like a regular function.<br /><pre style="tab-size: 4;">printf := fmt.Printf<br />printf(&ldquo;This will output %d line.\n&rdquo;, 1)</pre>This ability can come in very handy for testing code that calls a function which is hard to properly test while testing the surrounding code. &nbsp;In <a href="http://juju.ubuntu.com/" target="_blank">Juju</a>, we occasionally use function variables to allow us to stub out a difficult function during tests, in order to more easily test the code that calls it. &nbsp;Here&rsquo;s a simplified example:<br />
<pre style="tab-size: 4;">// in install/mongodb.go<br />package install<br /><br />func SetupMongodb(path string) error {<br />&nbsp; &nbsp; &nbsp;// suppose the code in this method modifies files in root<br />&nbsp; &nbsp; &nbsp;// directories, mucks with the environment, etc&hellip; <br />&nbsp; &nbsp; &nbsp;// Actions you actively don&rsquo;t want to do during most tests.<br />}</pre></span><pre style="tab-size: 4;"><br />// in startup/bootstrap.go<br />package startup<br /><br />func Bootstrap() error {<br />&nbsp; &nbsp; &hellip;<br />&nbsp; &nbsp; path := getPath()<br />&nbsp; &nbsp; if err := install.SetupMongodb(path); err != nil {<br />&nbsp; &nbsp; &nbsp; &nbsp;return err<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; &hellip;<br />}</pre></span>So, suppose you want to write a test for Bootstrap, but you know SetupMongodb won&rsquo;t work, because the tests don&rsquo;t run with root privileges (and you don&rsquo;t want to setup mongodb on the dev&rsquo;s machine anyway). &nbsp;What can you do? &nbsp;This is where mocking comes in.<br /><br />We just make a little tweak to Bootstrap:<br /><pre style="tab-size: 4;">package startup<br /><br />var setupMongo = install.SetupMongodb<br /><br />func Bootstrap() error {<br />&nbsp; &nbsp; &hellip;<br />&nbsp; &nbsp; path := getRootDirPath()<br />&nbsp; &nbsp; if err := setupMongo(path); err != nil {<br />&nbsp; &nbsp; &nbsp; &nbsp;return err<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; &hellip;<br />}</pre></span>Now if we want to test Bootstrap, we can mock out the setupMongo function thusly:<br /><pre style="tab-size: 4;"><span style="TRACE">// in startup/bootstrap_test.go<br />package startup<br /><br />type fakeSetup struct {<br />&nbsp; &nbsp; path string<br />&nbsp; &nbsp; err error<br />}<br /><br />func (f *fakeSetup) setup(path string) error {<br />&nbsp; &nbsp; f.path = path<br />&nbsp; &nbsp; return f.err<br />}<br /><br />TestBootstrap(t *testing.T) {<br />&nbsp; &nbsp; f := &amp;fakeSetup{ err: errors.New(&ldquo;Failed!&rdquo;) }<br />&nbsp; &nbsp; // this mocks out the function that Bootstrap() calls<br />&nbsp; &nbsp; setupMongo = f.setup<br />&nbsp; &nbsp; err := Bootstrap()<br />&nbsp; &nbsp; if err != f.err {<br />&nbsp; &nbsp; &nbsp; &nbsp; t.Fail(&ldquo;Error from setupMongo not returned.  Expected %v, got %v&rdquo;, f.err, err)<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; expPath := getPath()<br />&nbsp; &nbsp; if f.path != expPath {<br />&nbsp; &nbsp; &nbsp; &nbsp; t.Fail(&ldquo;Path not correctly passed into setupMongo. Expected %q, got %q&rdquo;, expPath, f.path)<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; // and then try again with f.err == nil, you get the idea<br />}</pre></span>Now we have full control over what happens in the setupMongo function, we can record the parameters that are passed into it, what it returns, and test that Bootstrap is at least using the API of the function correctly.<br /><br />Obviously, we need tests elsewhere for install.SetupMongodb to make sure it does the right thing, but those can be tests internal to the install package, which can use non-exported fields and functions to effectively test the logic that would be impossible from an external package (like the setup package).  Using this mocking means that we don&rsquo;t have to worry about setting up an environment that allows us to test SetupMongodb when we really only want to test Bootstrap. &nbsp;We can just stub out the function and test that Bootstrap does everything correctly, and trust that SetupMongodb works because it&rsquo;s tested in its own package.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2014/04/effective-godoc/">
        Effective Godoc
      </a>
    </h1>

    <span class="post-date">Apr 1, 2014</span>

    


    <p>I started to write a blog post about how to get the most out of godoc, with examples in a repo, and then realized I could just write the whole post as godoc on the repo, so that&rsquo;s what I did. &nbsp;Feel free to send pull requests if there&rsquo;s anything you see that could be improved.<br /><br />I actually learned quite a lot writing this article, by exploring all the nooks and crannies of Go&rsquo;s documentation generation. &nbsp;Hopefully you&rsquo;ll learn something too.<br /><br />Either view the documentation on godoc.org:<br /><br /><a href="https://godoc.org/github.com/natefinch/godocgo">https://godoc.org/github.com/natefinch/godocgo</a><br /><br />or view it locally using the godoc tool:<br /><br /><pre style="background-color: whitesmoke; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px; border-top-left-radius: 4px; border-top-right-radius: 4px; border: 1px solid rgb(204, 204, 204); box-sizing: border-box; color: #333333; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 13px; line-height: 1.428571429; margin-bottom: 10px; overflow: auto; padding: 9.5px; word-break: normal; word-wrap: normal;">go get code.google.com/p/go.tools/cmd/godoc<br />go get github.com/natefinch/godocgo<br />godoc -http=:8080</pre><br />Then open a browser to <a href="http://localhost:8080/pkg/github.com/natefinch/godocgo">http://localhost:8080/pkg/github.com/natefinch/godocgo</a><br /><br />Enjoy!</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2014/03/unused-variables-in-go/">
        Unused Variables in Go
      </a>
    </h1>

    <span class="post-date">Mar 28, 2014</span>

    


    <p>The Go compiler treats unused variables as a compilation error. This causes much
annoyance to some newbie Gophers, especially those used to writing languages
that aren&rsquo;t compiled, and want to be able to be fast and loose with their code
while doing exploratory hacking.</p>

<p>The thing is, an unused variable is often a bug in your code, so pointing it out
early can save you a lot of heartache.</p>

<p>Here&rsquo;s an example:</p>

<pre><code class="language-go">50 func Connect(name, port string) error {
51     hostport := &quot;&quot;
52    if port == &quot;&quot; {
53        hostport := makeHost(name)
54        logger.Infof(&quot;No port specified, connecting on port 8080.&quot;)
55    } else {
56        hostport := makeHostPort(name, port)
57        logger.Infof(&quot;Connecting on port %s.&quot;, port)
58    }
59    // ... use hostport down here
60 }
</code></pre>

<p>Where&rsquo;s the bug in the above?  Without the compiler error, you&rsquo;d run the code
and have to figure out why hostport was always an empty string.  Did we pass in
empty strings by accident?  Is there a bug in makeHost and makeHostPort?</p>

<p>With the compiler error, it will say &ldquo;53, hostport declared and not used&rdquo; and
&ldquo;56, hostport declared and not used&rdquo;</p>

<p>This makes it a lot more obvious what the problem is&hellip; inside the scope of the
if statement, := declares new variables called hostport.  These hide the
variable from the outer scope, thus, the outer hostport never gets modified,
which is what gets used further on in the function.</p>

<pre><code class="language-go">50 func Connect(name, port string) error {
51    hostport := &quot;&quot;
52    if port == &quot;&quot; {
53        hostport = makeHost(name)
54        logger.Infof(&quot;No port specified, connecting on port 8080.&quot;)
55    } else {
56        hostport = makeHostPort(name, port)
57        logger.Infof(&quot;Connecting on port %s.&quot;, port)
58    }
59    // ... use hostport down here
60 }
</code></pre>

<p>The above is the corrected code. It took only a few seconds to fix, thanks to
the unused variable error from the compiler.  If you&rsquo;d been testing this by
running it or even with unit tests&hellip; you&rsquo;d probably end up spending a non-
trivial amount of time trying to figure it out.  And this is just a very simple
example.  This kind of problem can be a lot more elaborate and hard to find.</p>

<p>And that&rsquo;s why the unused variable declaration error is actually a good thing.
If a value is important enough to be assigned to a variable, it&rsquo;s probably a bug
if you&rsquo;re not actually using that variable.</p>

<p><strong>Bonus tip:</strong></p>

<p>Note that if you don&rsquo;t care about the variable, you can just assign it to the
empty identifier directly:</p>

<pre><code class="language-go">_, err := computeMyVar()
</code></pre>

<p>This is the normal way to avoid the compiler error in cases where a function
returns more than you need.</p>

<p>If you <em>really</em> want to silence the unused variable error and not remove the
variable for some reason, this is the way to do it:</p>

<pre><code class="language-go">v, err := computeMyVar() 
_ = v  // this counts as using the variable 
</code></pre>

<p>Just don&rsquo;t forget to clean it up before committing.</p>

<p>All of the above also goes for unused packages.  And a similar tip for silencing
that error:</p>

<pre><code class="language-go">_ = fmt.Printf // this counts as using the package
</code></pre>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2014/03/go-and-github/">
        Go and Github
      </a>
    </h1>

    <span class="post-date">Mar 21, 2014</span>

    


    <p><span class="fullname js-action-profile-name show-popup-with-id" style="background-color: white; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 16px; text-decoration: none;">Francesc Campoy&nbsp;<span style="color: #292f33;"><a href="http://blog.campoy.cat/2014/03/github-and-go-forking-pull-requests-and.html" target="_blank">recently posted</a> about how to work on someone else&rsquo;s Go repo from github. &nbsp;His description was correct, but I think there&rsquo;s an easier way, and also one that might be slightly less confusing.</span></span><br /><span class="fullname js-action-profile-name show-popup-with-id" style="background-color: white; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 16px; text-decoration: none;"><span style="color: #292f33;"><br /></span></span><span style="color: #292f33; font-family: Helvetica Neue, Helvetica, Arial, sans-serif;"><span style="background-color: white; font-size: 14.399999618530273px; line-height: 16px;">Let&rsquo;s say you want to work on your own branch of github.com/natefinch/gocog - here&rsquo;s the easiest way to do it:</span></span><br /><br /><ol><li><span style="color: #292f33; font-family: Helvetica Neue, Helvetica, Arial, sans-serif;"><span style="font-size: 14.399999618530273px; line-height: 16px;">Fork&nbsp;</span></span><span style="background-color: white; color: #292f33; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14.399999618530273px; line-height: 16px;">github.com/natefinch/gocog on github</span></li><li><span style="background-color: white; color: #292f33; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14.399999618530273px; line-height: 16px;">mkdir -p $GOPATH/src/github.com/natefinch/gocog</span></li><li><span style="background-color: white; color: #292f33; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14.399999618530273px; line-height: 16px;">cd&nbsp;</span><span style="background-color: white; color: #292f33; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14.399999618530273px; line-height: 16px;">$GOPATH/src/github.com/natefinch/gocog</span></li><li><span style="background-color: white; color: #292f33; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14.399999618530273px; line-height: 16px;">git clone https://</span><span style="background-color: white; color: #292f33; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14.399999618530273px; line-height: 16px;">github.com/YOURNAME/gocog .</span></li><li><span style="background-color: white; color: #292f33; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14.399999618530273px; line-height: 16px;">(optional) go get github.com/natefinch/gocog</span></li></ol><div><span style="color: #292f33; font-family: Helvetica Neue, Helvetica, Arial, sans-serif;"><span style="font-size: 14.399999618530273px; line-height: 16px;"><br /></span></span></div><div><span style="color: #292f33; font-family: Helvetica Neue, Helvetica, Arial, sans-serif;"><span style="font-size: 14.399999618530273px; line-height: 16px;">That&rsquo;s it. &nbsp;Now you can work on the code, push/pull etc from your github repo as normal, and submit a pull request when you&rsquo;re done.</span></span></div><div><span style="color: #292f33; font-family: Helvetica Neue, Helvetica, Arial, sans-serif;"><span style="font-size: 14.399999618530273px; line-height: 16px;"><br /></span></span></div><div><span style="color: #292f33;"><span style="font-size: 14.399999618530273px; line-height: 16px;"><code>go get</code><span style="font-family: Helvetica Neue, Helvetica, Arial, sans-serif;"> is useful for getting code that you want to </span><i style="font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;">use,</i><span style="font-family: Helvetica Neue, Helvetica, Arial, sans-serif;">&nbsp;but it&rsquo;s not very useful for getting code that you want to <i>work on</i>. &nbsp;It doesn&rsquo;t set up source control. &nbsp;</span><code>git clone</code><span style="font-family: Helvetica Neue, Helvetica, Arial, sans-serif;"> does. &nbsp;What go get is handy for is getting the dependencies of a project, which is what step 5 does (only needed if the project relies on outside repos you don&rsquo;t already have). &nbsp;(thanks to a post on G+ for reminding me that git clone won&rsquo;t get the dependencies)</span></span></span></div><div><span style="color: #292f33;"><span style="font-size: 14.399999618530273px; line-height: 16px;"><span style="font-family: Helvetica Neue, Helvetica, Arial, sans-serif;"><br /></span></span></span><span style="color: #292f33; font-family: Helvetica Neue, Helvetica, Arial, sans-serif; font-size: 14.399999618530273px; line-height: 16px;">Also note,<b> the path on disk is the same as the original repo&rsquo;s URL, not your branch&rsquo;s URL</b>. &nbsp;That&rsquo;s intentional, and it&rsquo;s the key to making this work. &nbsp;</span><span style="color: #292f33; font-family: Courier New, Courier, monospace; font-size: 14.399999618530273px; line-height: 16px;">go get</span><span style="color: #292f33; font-family: Helvetica Neue, Helvetica, Arial, sans-serif; font-size: 14.399999618530273px; line-height: 16px;"> is the only thing that actually cares if the repo URL is the same as the path on disk. &nbsp;Once the code is on disk, </span><span style="color: #292f33; font-family: Courier New, Courier, monospace; font-size: 14.399999618530273px; line-height: 16px;">go build</span><span style="color: #292f33; font-family: Helvetica Neue, Helvetica, Arial, sans-serif; font-size: 14.399999618530273px; line-height: 16px;"> etc just expects import paths to be directories under $GOPATH. &nbsp;The code expects to be under $GOPATH/src/github.com/natefinch/gocog because that&rsquo;s what the import statements say it should be. &nbsp;There&rsquo;s no need to change import paths or anything wacky like that (though it does mean that you can&rsquo;t have both the original version of the code and your branch coexisting in the same $GOPATH).</span></div><div><span style="color: #292f33;"><span style="font-size: 14.399999618530273px; line-height: 16px;"><span style="font-family: Helvetica Neue, Helvetica, Arial, sans-serif;"><br /></span></span></span></div><div><span style="color: #292f33;"><span style="font-size: 14.399999618530273px; line-height: 16px;"><span style="font-family: Helvetica Neue, Helvetica, Arial, sans-serif;">Note that this is actually <i>the same procedure&nbsp;</i>that you&rsquo;d use to work on your own code from github, you just change step 1 to &ldquo;create the repo in github&rdquo;. &nbsp;I prefer making the repo in github first because it lets me set up the license, the readme, and the .gitignore with just a few checkboxes, though obviously that&rsquo;s optional if you want to hack locally first. &nbsp;In that case, just make sure to set up the path under gopath where it <i>would go</i> if you used </span><code>go get</code><span style="font-family: Helvetica Neue, Helvetica, Arial, sans-serif;">, so that </span><code>go get</code><span style="font-family: Helvetica Neue, Helvetica, Arial, sans-serif;"> will work correctly when you decide to push up to github.</span></span></span><br /><span style="color: #292f33;"><span style="font-size: 14.399999618530273px; line-height: 16px;"><span style="font-family: Helvetica Neue, Helvetica, Arial, sans-serif;"><br /></span></span></span><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif; TRACE">(updated to mention using go get after git clone)</span><br /><span style="color: #292f33;"><span style="line-height: 17.804800033569336px;"></span></span></div></p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2014/03/go-tips-for-newbie-gophers/">
        Go Tips for Newbie Gophers
      </a>
    </h1>

    <span class="post-date">Mar 15, 2014</span>

    


    <p>This is just a collection of tips that would have saved me a lot of time if I had known about them when I was a newbie:<br /><br /><b>Build or test everything under the current directory and subdirectories:</b><br /><b><br /></b><pre style="tab-size: 4;">go build ./&hellip;<br />go test ./&hellip;</pre><span style="font-family: inherit;">Technically, both commands take a pattern to match the name of one or more packages, and the &hellip; specifier is a wildcard, so you could do &hellip;/foo/&hellip; to match all packages under GOPATH with foo in their path.&nbsp;</span><br /><br /><b>Have an io.Writer that writes to an in-memory data structure:</b><br /><br /><div><pre style="tab-size: 4;">b := &amp;bytes.Buffer{}<br />thing.WriteTo(b)</pre><b>Have an io.Reader read from a string (useful when you want to use a string as the input data for something):</b><br /><pre style="tab-size: 4;">r := strings.NewReader(myString)<br />thing.ReadFrom(r)</pre><b>Copy data from a reader to a writer:</b><br /><br /><pre style="tab-size: 4;">io.Copy(toWriter, fromReader)</pre><b>Timeout waiting on a channel:</b><br /><br /><pre style="tab-size: 4;">select {<br/>&nbsp; &nbsp;case val := &lt;- ch<br/>&nbsp; &nbsp; &nbsp; &nbsp;// use val<br/>&nbsp; &nbsp;case &lt;-time.After(time.Second*5)<br />}</pre><b>Convert a slice of bytes to a string:</b><pre style="tab-size: 4;">var b []byte = getData()<br/>s := string(b)</pre><b>Passing a nil pointer into an interface does not result in a nil interface:</b><pre style="tab-size: 4;">func isNil(i interface{}) bool {<br/>&nbsp; &nbsp; return i == nil<br/>}<br/>var f *foo = nil<br />fmt.Println(isNil(f)) &nbsp;// prints false</pre></div><div><b>The only way to get a nil interface is to pass the keyword nil:</b></div><div><pre style="tab-size: 4;">var f *foo = nil<br/>if f == nil {<br />&nbsp; &nbsp; fmt.Println(isNil(nil)) &nbsp;// prints true<br/>}</pre></div><div><b>How to remember where the arrow goes for channels:</b></div><div><br /></div><div>The arrow points in the direction of data flow, either into or out of the channel, and always points left.</div><div><br /></div><div><b>The above is generalizable to anything where you have a source and destination, or reading and writing, or assigning.</b></div><div><b><br /></b></div><div>Data is taken from the right and assigned to the left, just as it is with a := b. &nbsp;So, like io.Copy, you know that the reader (source) is on the right, the writer (destination) is on the left: &nbsp;io.Copy(dest, src).</div><div><br /></div><div><b>If you ever think &ldquo;man, someone should have made a helper function to do this!&rdquo;, chances are they have, and it&rsquo;s in the std lib somewhere.</b></div></div></p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2013/11/working-at-canonical/">
        Working at Canonical
      </a>
    </h1>

    <span class="post-date">Nov 10, 2013</span>

    


    <p><div class="separator" style="clear: both; text-align: left;">I&rsquo;ve been a developer at Canonical (working on <a href="http://juju.ubuntu.com/" target="_blank">Juju</a>) for a little over 3 months, and I have to say, this is the best job I have ever had, bar none.</div><br />Let me tell you why.<br /><br />1.) 100% work from home (minus ~2 one week trips per year)<br />2.) Get paid to write cool open source software.<br />3.) Work with smart people from all over the globe.<br /><br />#1 can&rsquo;t be overstated. This isn&rsquo;t just &ldquo;flex time&rdquo; or &ldquo;work from home when you want to&rdquo;. &nbsp;There is literally no office to go to for most people at Canonical. &nbsp;Working at home is the default. &nbsp;The difference is huge. &nbsp;My last company let us work from home as much as we wanted, but most of the company worked from San Francisco&hellip; which means when there were meetings, 90% of the people were in the room, and the rest of us were on a crappy speakerphone straining to hear and having our questions ignored. &nbsp;At Canonical, everyone is remote, so everyone works to make meetings and interactions work well online&hellip; and these days it&rsquo;s easy with stuff like Google Hangouts and IRC and email and online bug tracking etc.<br /><br />Canonical&rsquo;s benefits don&rsquo;t match Google&rsquo;s or Facebook&rsquo;s (you get the standard stuff, health insurance, 401k etc, just not the crazy stuff like caviar at lunch&hellip; unless of course you have caviar in the fridge at home). &nbsp;However, I&rsquo;m pretty sure the salaries are pretty comparable&hellip; and Google and Facebook don&rsquo;t let you work 100% from home. &nbsp;I&rsquo;m pretty sure they barely let you work from home at all. &nbsp;And that is a huge quality of life issue for me. &nbsp;I don&rsquo;t have to slog through traffic and public transportation to get to work. &nbsp;I just roll out of bed, make some coffee, and sit down at my desk. &nbsp;I get to see my family more, and I save money on transportation.<br /><br />#2 makes a bigger difference than I expected. &nbsp;Working on open source is like entering a whole different world. &nbsp;I&rsquo;d only worked on closed source before, and the difference is awesome. &nbsp;There&rsquo;s purposeful openness and inclusion of the community in our development. &nbsp;Bug lists are public, and anyone can file one. &nbsp;Mailing lists are public (for the most part) and anyone can get on them. &nbsp;IRC channels are public, and anyone can ask questions directly to the developers. &nbsp;It&rsquo;s a really great feeling, and puts us so much closer to the community - the people that have perhaps an even bigger stake in the products we make than we do. &nbsp;Not only that, but we write software for people like us. &nbsp;Developers. &nbsp;I <b>am</b> the target market, in most cases. &nbsp;And that makes it easy to get excited about the work and easy to be proud of and show off what I do.<br /><br />#3 The people. &nbsp;I have people on my team from Germany, the UK, Malta, the UAE, Australia, and New Zealand. &nbsp;It&rsquo;s amazing working with people of such different backgrounds. &nbsp;And when you don&rsquo;t have to tie yourself down to hiring people within a 30 mile radius, you can afford to be more picky. &nbsp;Canonical doesn&rsquo;t skimp on the people, either. &nbsp;I was surprised that nearly everyone on my team was 30+ (possibly all of them, I don&rsquo;t actually know how old everyone is ;) &nbsp;That&rsquo;s a lot of experience to have on one team, and it&rsquo;s so refreshing not to have to try to train the scrappy 20-somethings to value the things that come with experience (no offense to my old colleagues, you guys were great).<br /><br />Put it all together, and it&rsquo;s an amazing opportunity that I am exceedingly pleased to have been given.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2013/09/60-days-with-ubuntu/">
        60 Days with Ubuntu
      </a>
    </h1>

    <span class="post-date">Sep 28, 2013</span>

    


    <p>At the end of July, I started a new job at Canonical, the makers of Ubuntu Linux. &nbsp;Canonical employees mostly work from home, and use their own computer for work. &nbsp;Thus, I would need to switch to Ubuntu from Windows on my personal laptop. &nbsp;Windows has been my primary operating system for most of my 14 year career. &nbsp;I&rsquo;ve played around with Linux on the side a few times, running a mail server on Mandrake for a while&hellip; and I&rsquo;ve worked with Cent OS as server for the software at my last job&hellip; but I wouldn&rsquo;t say I was comfortable spending more than a few minutes on a Linux terminal before I yearned to friggin&rsquo; click something already&hellip;. and I certainly hadn&rsquo;t used it as my day to day machine.<br /><br /><a href="https://4.bp.blogspot.com/-2ufifnI1jbM/UkbFXrqladI/AAAAAAAAahE/WPcfPTmmUpI/s1600/desktop.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" height="360" src="https://4.bp.blogspot.com/-2ufifnI1jbM/UkbFXrqladI/AAAAAAAAahE/WPcfPTmmUpI/s640/desktop.png" width="640" /></a>Enter Ubuntu 13.04 Raring Ringtail, the latest and greatest Ubuntu release (pro-tip, the major version number is the year it was released, and the minor version number is the month, Canonical does two releases a year, in April and October, so they&rsquo;re all .04 and .10, and the release names are alphabetical).<br /><br />Installation on my 2 year old HP laptop was super easy. &nbsp;Pop in the CD I had burned with Ubuntu on it, and boot up&hellip; installation is fully graphical, not too different from a Windows installation. &nbsp;There were no problems installing, and only one cryptic prompt&hellip; do I want to use Logical Volume Management (LVM) for my drives? &nbsp;This is the kind of question I hate. &nbsp;There was no information about what in the heck LVM was, what the benefits or drawbacks are, and since it sounded like it could be a Big Deal, I wanted to make sure I didn&rsquo;t pick the wrong thing and screw myself later. &nbsp;Luckily I could ask a friend with Linux experience&hellip; but it really could have done with a &ldquo;(Recommended)&rdquo; tag, and a link for more information.<br /><br />After installation, a dialog pops up asking if I want to use proprietary third party drivers for my video card (Nvidia) or open source drivers. &nbsp;I&rsquo;m given a list of several proprietary drivers and an open source driver. &nbsp;Again, I don&rsquo;t know what the right answer is, I just want a driver that works, I don&rsquo;t care if it&rsquo;s proprietary or not (sorry, OSS folks, it&rsquo;s true). &nbsp;However, trying to be a good citizen, I pick the open source one and&hellip;. well, it doesn&rsquo;t work well at all. &nbsp;I honestly forget exactly what problems I had, but they were severe enough that I had to go figure out how to reopen that dialog and choose the Nvidia proprietary drivers.<br /><br />Honestly, the most major hurdle in using Ubuntu has been getting used to having the minimize, maximize, and close buttons in the upper left of the window, instead of the upper right.<br /><br />In the first week of using Ubuntu I realized something - 99% of my home use of a computer is in a web browser&hellip; the OS doesn&rsquo;t matter at all. &nbsp;There&rsquo;s actually very little I use native applications for outside of work. &nbsp;So, the transition was exceedingly painless. &nbsp;I installed Chrome, and that was it, I was back in my comfortable world of the browser.<br /><br />Linux has come a long way in the decade since I last used it. &nbsp;It&rsquo;s not longer the OS that requires you drop into a terminal to do everyday things. &nbsp;There are UIs for pretty much everything that are just as easy to use as the ones in Windows, so things like configuring monitors, networking, printers, etc all work pretty much like they do in Windows.<br /><br />So what problems did I have? &nbsp;Well, my scanner doesn&rsquo;t work. &nbsp;I went to get drivers for it, and there are third party scanner drivers, but they didn&rsquo;t work. &nbsp;But honestly, scanners are pretty touch and go in Windows, too, so I&rsquo;m not terribly surprised. &nbsp;All my peripherals worked (monitors, mouse, keyboard, etc), and even my wireless printer worked right away. &nbsp;However, later on, my printer stopped working. &nbsp;I don&rsquo;t know exactly why, I had been messing with the firewall in Linux, and so it may have been my fault. &nbsp;I&rsquo;m talking to Canonical tech support about it, so hopefully they&rsquo;ll be able to help me fix it.<br /><br />Overall, I am very happy with using Linux as my every day operating system. &nbsp;There&rsquo;s very few drawbacks for me. &nbsp;Most Windows software has a corresponding Linux counterpart, and now even Steam games are coming to Linux, so there&rsquo;s really very little reason not to make the switch if you&rsquo;re interested.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2013/04/statically-typed-generic-data-structures-in-go/">
        Statically typed generic data structures in Go
      </a>
    </h1>

    <span class="post-date">Apr 17, 2013</span>

    


    <p><br />I gave a talk at the <a href="https://plus.google.com/u/0/communities/103337146295481792015" target="_blank">Go Boston</a> meetup last night and figured I should write it up and put it here.<br /><div><br /></div><br />The second thing everyone says when they read up on Go is &ldquo;There are no generics!&rdquo;. <br /><div><br /></div><div>(The first thing people say is &ldquo;There are no exceptions!&rdquo;)<br /><div><br /></div><div>Both are only mostly true, &nbsp;but we&rsquo;re only going to talk about generics today.</div><div><br /></div><div>Go has generic built-in data structures - arrays, slices, maps, and channels. You just can&rsquo;t create your own new type, and you can&rsquo;t create generic functions. So, what&rsquo;s a programmer to do? Find another language?</div><div><br /></div><div>No. Many, possibly even most, problems can be solved with the built-in data structures. You can write pretty huge applications just using maps and slices and the occasional channel. There may be a tiny bit of code duplication, but probably not much, and certainly not any tricky code.</div><div><br /></div><div>However, there definitely are times when you need more complicated data structures. Most people writing Go solve this problem by using Interface{}, the empty interface, which is basically like Object in C# or Java or void * in C/C++. &nbsp;It&rsquo;s a thing that can hold any type&hellip; but then you need to type cast it to get at the actual type. This breaks static typing, since the compiler can&rsquo;t tell if you make a mistake and pass the wrong type into something that takes an Interface{}, and it can&rsquo;t tell until runtime if a cast will succeed or not.</div><div><br /></div><div>So, is there any solution? Yes. The inspiration comes from the standard library&rsquo;s<a href="http://golang.org/pkg/sort/#Interface" target="_blank"> sort package</a>. Package sort can sort a slice of any type, it can even sort things that aren&rsquo;t slices, if you&rsquo;ve made your own custom data structure. How does it do that? To sort something, it must support the methods on sort.Interface. Most interesting is Less(i, j int). Less returns true if the item at index i in your data structure is Less than the object at index j in your data structure. Your code has to implement what &ldquo;Less&rdquo; means&hellip; and by only using indices, sort doesn&rsquo;t need to know the types of objects held in your data structure.&nbsp;</div><div><br /></div><div>This use of indices to blindly access data in a separate data structure is how we&rsquo;ll implement our strongly typed tree. The tree structure will hold an index as its data value in each node, and the indices will index into a data structure that holds the actual objects. To make a tree of a new type, you simply implement a Compare function that the tree can use to compare the values at two indices in your data structure. You can use whatever data structure you like, probably a slice or a map, as long as you can use integers to reference values in the data structure.</div><div><br /></div><div>In this way we separate the organization of the data from the storage of the data. The tree structure holds the organization, a slice or map (or something custom) stores the data. The indices are the generic pointers into the storage that holds the actual strongly typed values.</div><div><br /></div><div>This does require a little code for each new tree type, just as using package sort requires a little code for each type. However, it&rsquo;s only a few lines for a few functions, wrapping a tree and your data.&nbsp;</div><div><br /></div><div>You can check out an example binary search tree I wrote that uses this technique in my github account<br /><br /><a href="https://github.com/natefinch/tree">https://github.com/natefinch/tree</a><br /><br />or go get the runnable sample tree:<br /><br />go get github.com/natefinch/treesample</div><div><br /></div><div>This required only 36 lines of code to make the actual tree structure (including empty lines and comments).</div><div><br /></div><div>In some simple benchmarks, this implementation of a tree is about 25% faster than using the same code with Interface{} as the values and casting at runtime&hellip;. plus it&rsquo;s strongly typed.</div></div></p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2013/01/go-is-for-open-source/">
        Go is for Open Source
      </a>
    </h1>

    <span class="post-date">Jan 29, 2013</span>

    


    <p>The Go programming language is built from the ground up to implicitly encourage Go projects to be open source. If you want your project not only to contribute to open source, but to encourage other people to write open source code, Go is a great language to choose.<br /><br />Let&rsquo;s look at how Go does this. These first two points are overly obvious, but we should get them out of the way.<br /><br /><h3>The language is open source</h3>You can go look at the <a href="https://code.google.com/p/go/source/browse/" target="_blank">source code</a>&nbsp;for the language, the compilers, and the build tools for the language. It&rsquo;s a fully open source project. Even though a lot of the work is being done by Google engineers, there are hundreds of names on the <a href="https://code.google.com/p/go/source/browse/CONTRIBUTORS" target="_blank">list of contributors</a> of people who are not Google employees.<br /><br /><h3>The standard library is open source</h3><div>Want to see high quality example code? Look at the code in the standard library. It has been carefully reviewed to be of the best quality, and in canonical Go style. Reading the standard library is a great way to learn the best ways to use and write Go.</div><div><br /></div><div><br /></div><div><b><span style="color: red;">Ok, that&rsquo;s great, but what about all the code that isn&rsquo;t part of Go itself?</span></b></div><div>The design of Go really shows its embrace of open source in how third party code is used in day to day projects.</div><div><br /></div><h3>Go makes it trivial to use someone&nbsp;else&rsquo;s code in your project</h3><div>Go has distributed version control built-in from the ground up. If you want to use a package from github, for example, you just specify the URL in the imports, as if it were a local package:</div><div><br /></div><pre class="brush: go; gutter: false">import (<br />    &ldquo;bytes&rdquo; // std lib package<br />    &ldquo;github.com/fake/foo&rdquo; // 3rd party package<br />)</pre><div><br /></div><div>You don&rsquo;t have to go find and download fake/foo from github and put it in a special directory or anything. Just run &ldquo;go get github.com/fake/foo&rdquo;. Go will then download, build, and install the code, so that you can reference it&hellip; nicely stored in a directory defined by the URL, in this case $GOPATH/src/github.com/fake/foo. Go will even figure out what source control system is used on the other side so you don&rsquo;t have to (support for git, svn, mercurial, and bazaar).<br /><br />What&rsquo;s even better is that the auto-download happens for anyone who calls &ldquo;go get&rdquo; on&nbsp;<i>your</i>&nbsp;code repository. No more giving long drawn-out installation instructions about getting half a dozen 3rd party libraries first. If someone wants your code, they type &ldquo;go get path.to/your/code&rdquo;, and Go will download your code, and any remote imports you have (like the one for github above), any remote imports <i>that</i> code has, etc, and then builds everything.<br /><br />The fact that this is available from the command line tools that come with the language makes it the de facto standard for how all Go code is written. There&rsquo;s no fragmentation in the community about how packages are stored, accessed, used, etc. This means zero overhead for using third party code, it&rsquo;s as easy to use as if it were built into the Go standard library.<br /><br /><h3>Sharing code is the default</h3></div><div>Like most scripting languages (and unlike many compiled languages), using source code from another project is the default way to use third party code in Go. Go creates a monolithic executable during its build, so there are no DLLs to create and distribute in the way you often see with other compiled languages. In theory you could distribute the compiled .a files from your project for other people to link to in their project, but this is not encouraged by the tooling, and I&rsquo;ve personally never seen anyone do it.</div><div><br /></div><h3>All Go code uses the same style</h3><div>Have you ever gone to read the source for a project you&rsquo;d like to contribute to, and had your eyes cross over at the bizarre formatting the authors used? That almost never happens with Go. Go comes with a code formatting tool called gofmt that automatically formats Go code to the same style. The use of gofmt is strongly encouraged in the Go community, and nearly everyone uses it. Most text editors have an extension to automatically format your code with gofmt on save, so you don&rsquo;t even have to think about it. You never have to worry about having a poorly formatted library to work with&hellip; and in the very rare situation where you do, you can just run it through gofmt and you&rsquo;re good to go.</div><div><br /></div><h3>Easy cross platform support</h3><div>Go makes it easy to support multiple platforms. The tooling <a href="http://dave.cheney.net/2012/09/08/an-introduction-to-cross-compilation-with-go" target="_blank">can create native binaries</a> for any popular operating system from the same source on a single machine. If you need platform-specific code, it&rsquo;s easy to specify code that only gets compiled for a single platform, by simply appending _&lt;os&gt; to a file name <i>.e.g</i>&nbsp;path_windows.go will only be compiled for builds targeting Windows.</div><div><br /></div><h3>Built-in documentation and testing</h3><div>Go comes with a documentation generator that spits generates HTML or plain text from minimally formatted comments in the code. It also comes with a standard testing package that can run unit tests, performance benchmarks, and runnable example code. Because this is all available in the standard library and with the standard tools, nearly everyone uses it&hellip; which means it&rsquo;s easy to look at the documentation for any random Go package, and easy check if the tests pass, without having to go install some third party support tool. Because it&rsquo;s all standardized, several popular websites have popped up to <a href="http://godoc.org/" target="_blank">automate generating</a>&nbsp;(and hosting) the documentation for your project, and you can easily run <a href="http://about.travis-ci.org/docs/user/languages/go/" target="_blank">continuous integration</a> on your package, with only a single line in the setup script - &ldquo;language: go&rdquo;.</div><div><br /></div><h3>Conclusion</h3><div>Everything about Go encourages standardization and openness&hellip; which not only makes it <i>possible </i>to use other people&rsquo;s code, it makes it <b>easy</b><i>&nbsp;</i>to use other people&rsquo;s code. I hope to see Go blossom as a language embraced by the open source community, as they discover the strengths that make it uniquely qualified for open source projects.</div></p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2013/01/what-i-love-about-go/">
        What I love about Go
      </a>
    </h1>

    <span class="post-date">Jan 25, 2013</span>

    


    <p><h2><span style="font-weight: normal;">The best things about Go have nothing to do with the language.</span></h2><h3>Single Executable Output</h3>Go compiles into a single executable that runs natively on the target OS. No more needing to install java, .net, mono, python, ruby, whatever. Here&rsquo;s your executable, feel free to run it like a normal person. &nbsp;And you can target builds for any major OS (windows, linux, OSX, BSD).<br /><br /><h3>One True Coding Style</h3>GoFmt is a build tool that formats your source code in the standard Go format. No more arguing about spacing or brace matching or whatever. There is one true format, and now we can all move on&hellip; and even better, many editors integrate GoFmt so that your code can be automatically formatted whenever you save.<br /><br /><h3>Integrated Testing</h3>Testing is integrated into the language. Name a file with the suffix _test.go and it&rsquo;ll only build under test. You run tests simply by running &ldquo;go test&rdquo; in the directory. You can also define runnable example code with output that is checked at test time. &nbsp;This example code is then included in the documentation (see below)&hellip; now you&rsquo;ll never have examples in documentation with errors in them. &nbsp;Finally, you can have built-in benchmarks that are controlled by the go tool to automatically run enough iterations to get a significant result, displayed in number of operations per second.<br /><br /><h3>Integrated Documentation</h3>HTML documentation is built into the language. No need for ugly HTML in your source or weirdly formatted comments. Plaintext comments are turned into very legible documentation, and see above for examples that actually run and can have their output tested as a part of the tests.<br /><br /><h3>DVCS</h3>Support for distributed version control is built into the language. Want to reference code from a project on github? &nbsp;Just use the url of the project as the import path in your code, <i>e.g.</i> import &ldquo;github.com/jsmith/foo&rdquo; &nbsp; When you build your code it&rsquo;ll get downloaded and built automatically.<br /><br />Want to get a tool written in go? &nbsp;From the command line type &ldquo;go get github.com/jsmith/bar&rdquo; - go will download the source, build it, and install the executable in your path. &nbsp;Now you can run bar.<br /><br />Any git, SVN, mercurial, or bazaar repository will work, but all the major public source code sites are supported out of the box - github, bitbucket, google code, and launchpad.<br /><br /><h3>Other Cool Stuff</h3><div>Debugging with gdb<br />Integrated profiling tools<br />Easy to define custom includes per targeted OS/architecture (simple _windows will only build if targetting windows)<br />Integrated code parsers and lexers.</div><div><br /></div><h4>Do you even care about the actual language anymore? &nbsp;I wouldn&rsquo;t. &nbsp;But just in case:</h4><ul><li>C-like</li><li>Garbage Collected</li><li>Statically typed</li><li>&hellip;but with type inference so you&rsquo;re not typing boilerplate all the time: a := &ldquo;my string&rdquo;</li><li>Implicit interfaces - if a type has the methods of an interface, it implements the interface</li><li>Pointers but no pointer arithmetic (thank god)</li><li>First class functions</li><li>No exceptions</li><li>&hellip;but multiple returns from a single function so you don&rsquo;t have to overload return types</li><li>Everything is UTF8 (both strings and source code.. yes you can have Θ as a variable name now)</li><li>Highly performant asynchronous code that is trivial to write</li><li>A deep standard library that does most of the boring stuff for you</li></ul><div><br /></div></p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2013/01/gocog/">
        gocog
      </a>
    </h1>

    <span class="post-date">Jan 25, 2013</span>

    


    <p>I recently got very enamored with <a href="http://golang.org/" target="_blank">Go</a>, and decided that I needed to write a real program with it to properly get up to speed. One thing came to mind after reading a lot on the <a href="https://groups.google.com/forum/#!forum/golang-nuts" target="_blank">Go mailing list</a>: a code generator.<br /><br />I had worked with <a href="http://nedbatchelder.com/" target="_blank">Ned Batchelder</a>&nbsp;at a now-defunct startup, where he developed <a href="http://nedbatchelder.com/code/cog/">cog.py</a>. I figured I could do something pretty similar with Go, except, I could do one better - Go generates native executables, which means you can run it without needing any specific programming framework installed, and you can run it on any major operating system. Also, I could construct it so that gocog supports any programming language embedded in the file, so long as it can be run via command line.<br /><br />Thus was born gocog -&nbsp;<a href="https://github.com/natefinch/gocog">https://github.com/natefinch/gocog</a><br /><br />Gocog runs very similarly to cog.py - you give it files to look at, and it reads the files looking for specially tagged embedded code (generally in comments of the actual text). Gocog extracts the code, runs it, and rewrites the file with the output of the code embedded.<br /><br />Thus you can do something like this in a file called test.html:<br /><pre class="brush: xml; gutter: false;">&lt;html&gt;<br />&lt;body&gt;<br />&lt;!&ndash; [[[gocog<br />print &ldquo;&lt;b&gt;Hello World!&lt;/b&gt;&ldquo;<br />gocog]]] &ndash;&gt;<br />&lt;!&ndash; [[[end]]] &ndash;&gt;<br />&lt;/body&gt;<br />&lt;/html&gt;<br /></pre><br />if you run gocog over the file, specifying python as the command to run:<br /><br />gocog test.html -cmd python -args %s -ext .py<br /><br />This tells gocog to extract the code from test.html into a &nbsp;file with the .py extension, and then run python &lt;filename&gt; and pipe the output back into the file.<br /><br />This is what test.html looks like after running gocog:<br /><br /><pre class="brush: xml; gutter: false;">&lt;html&gt;<br />&lt;body&gt;<br />&lt;!&ndash; [[[gocog<br />print &ldquo;&lt;b&gt;Hello World!&lt;/b&gt;&ldquo;<br />gocog]]] &ndash;&gt;<br />&lt;b&gt;Hello World!&lt;/b&gt;<br />&lt;!&ndash; [[[end]]] &ndash;&gt;<br />&lt;/body&gt;<br />&lt;/html&gt;<br /></pre><div><br /></div><div>Note that the generator code still exists in the file, so you can always rerun gocog to update the generated text. &nbsp;</div><div><br /></div><div>By default gocog assumes you&rsquo;re running embedded Go in the file (hey, I wrote it, I&rsquo;m allowed to be biased), but you can specify any command line tool to run the code - python, ruby, perl, even compiled languages if you have a command line tool to compile and run them in a single step (I know of one for C# at least).</div><div><br /></div><div>&ldquo;Ok&rdquo;, you&rsquo;re saying to yourself, &ldquo;but what would I really do with it?&rdquo; &nbsp;Well, it can be really useful for reducing copy and paste or recreating boilerplate. Ned and I used it to keep a schema of properties in sync over several different projects. Someone on Golang-nuts emailed me and is using it to generate boilerplate for CGo enum properties in Go.</div><div><br /></div><div>Gocog&rsquo;s sourcecode actually uses gocog - I embed the usage text into three different spots for documentation purposes - two in regular Go comments and one in a markdown file. &nbsp;I also use gocog to generate a timestamp in the code that gets displayed with the version information.</div><div><br /></div><div>You don&rsquo;t need to know Go to run Gocog, it&rsquo;s just an executable that anyone can run, without any prerequisites. &nbsp;You can download the binaries of the latest build from the gocog wiki here:&nbsp;<a href="https://github.com/natefinch/gocog/wiki">https://github.com/natefinch/gocog/wiki</a></div><div><br /></div><div>Feel &nbsp;free to submit an issue if you find a bug or would like to request a feature.</div></p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://npf.io/2012/11/go-win-stuff/">
        Go Win Stuff
      </a>
    </h1>

    <span class="post-date">Nov 16, 2012</span>

    


    <p>No, not contests, <a href="http://golang.org/" target="_blank">golang</a> (the programming language), and Win as in Windows.<br /><div><br /></div><div>Quick background - Recently I started writing a <a href="http://en.wikipedia.org/wiki/MUD" target="_blank">MUD</a> in Go for the purposes of learning Go, and writing something that is non-trivial to code. &nbsp;MUDs are particularly suited to Go, since they are entirely server based, are text-based, and are highly concurrent and parallel problems (which is to say, you have a whole bunch of people doing stuff all at the same time on the server).&nbsp;</div><div><br /></div><div>Anyway, after getting a pretty good prototype of the MUD up and running (which was quite fun), I started thinking about using Go for some scripty things that I want to do at work. There&rsquo;s a bit of a hitch, though&hellip; the docs on working in Windows are not very good. &nbsp;In fact, if you look at golang.org, they&rsquo;re actually non-existent. &nbsp;This is because the syscall package changes based on what OS you&rsquo;re running on, and (not surprisingly) Google&rsquo;s public golang site is not running on Windows.</div><div><br /></div><div>So, anyway, a couple notes here on Windowy things that you (I) might want to do with Go:</div><div><br /></div><div>Open the default browser with a given URL:</div><br /><pre class="brush: go; gutter: false;tab-size: 4;">import (<br />    &ldquo;syscall/exec&rdquo;<br />) <br /><br />func OpenBrowser(url string) {<br />    exec.Command(&ldquo;rundll32&rdquo;, &ldquo;url.dll&rdquo;, &ldquo;FileProtocolHandler&rdquo;, url)<br />}<br /></pre>Example of a wrapper for syscall&rsquo;s Windows Registry functions:<br /><br /><pre class="brush: go; gutter: false;tab-size: 4;">import (<br />    &ldquo;syscall&rdquo;<br />)<br /><br />func ReadRegString(hive syscall.Handle, subKeyPath, valueName string) (value string, err error) {<br />    var h syscall.Handle<br />    err = syscall.RegOpenKeyEx(hive, syscall.StringToUTF16Ptr(subKeyPath), 0, syscall.KEY_READ, &amp;h)<br />    if err != nil {<br />        return<br />     }<br />     defer syscall.RegCloseKey(h)<br /><br />    var typ uint32<br />    var bufSize uint32<br /><br />    err = syscall.RegQueryValueEx(<br />              hKey,<br />              syscall.StringToUTF16Ptr(valueName),<br />              nil,<br />              &amp;typ,<br />              nil,<br />              &amp;bufSize)<br />    if err != nil {<br />        return<br />    }<br /><br />    data := make([]uint16, bufSize/2+1)<br /><br />    err = syscall.RegQueryValueEx(<br />              hKey,<br />              syscall.StringToUTF16Ptr(valueName),<br />              nil,<br />              &amp;typ,<br />              (*byte)(unsafe.Pointer(&amp;data[0])),<br />              &amp;bufSize)<br />    if err != nil {<br />        return<br />    }<br /><br />    return syscall.UTF16ToString(data), nil<br />}<br /></pre></p>

  </div>
  
  
</div>


  </body>
</html>
