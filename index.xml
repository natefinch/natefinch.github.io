<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>npf.io</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://npf.io/index.xml</link>
    <language>en-us</language>
    <author>Nate Finch</author>
    <copyright>2014 Nate Finch</copyright>
    <updated>Fri, 08 Aug 2014 11:12:44 UTC</updated>
    
    
    <item>
      <title>Making It a Series</title>
      <link>http://npf.io/2014/08/making-it-a-series/</link>
      <pubDate>Fri, 08 Aug 2014 11:12:44 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/08/making-it-a-series/</guid>
      <description>&lt;p&gt;I obviously have a lot to talk about with Hugo, so I decided I wanted to make
this into a series of posts, and have links at the bottom of each post
automatically populated with the other posts in the series.  This turned out to
be somewhat of a challenge, but doable with some effort&amp;hellip; hopefully someone
else can learn from my work.&lt;/p&gt;

&lt;p&gt;This now brings us to &lt;a href=&#34;http://hugo.spf13.com/taxonomies/overview&#34;&gt;Taxonomies&lt;/a&gt;.
Taxonomies are basically just like tags, except that you can have any number of
different types of tags.  So you might have &amp;ldquo;Tags&amp;rdquo; as a taxonomy, and thus you
can give a content tags with values of &amp;ldquo;go&amp;rdquo; and &amp;ldquo;programming&amp;rdquo;.  You can also
have a taxonomy of &amp;ldquo;series&amp;rdquo; and give content a series of &amp;ldquo;Hugo 101&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Taxonomy is sort of like relatable metadata to gather multiple pieces of content
together in a structured way&amp;hellip; it&amp;rsquo;s almost like a minimal relational database.
Taxonomies are listed in your site&amp;rsquo;s metadata, and consist of a list of keys.
Each piece of content can specify one or more values for those keys (the Hugo
documentation calls the values &amp;ldquo;Terms&amp;rdquo;).  The values are completely ad-hoc, and
don&amp;rsquo;t need to be pre-defined anywhere.  Hugo automatically creates pages where
you can view all content based on Taxonomies and see how the various values are
cross-referenced against other content.  This is a way to implement tags on
posts, or series of posts.&lt;/p&gt;

&lt;p&gt;So, for my example, we add a Taxonomy to my site config called &amp;ldquo;series&amp;rdquo;.  Then
in this post, the &amp;ldquo;Hugo: Beyond the Defaults&amp;rdquo; post, and the &amp;ldquo;Hugo is Friggin&amp;rsquo;
Awesome&amp;rdquo; post, I just add &lt;code&gt;series = [&amp;quot;Hugo 101&amp;quot;]&lt;/code&gt;  (note the brackets - the
values for the taxonomy are actually a list, even if you only have one value).
Now all these posts are magically related together under a taxonomy called
&amp;ldquo;series&amp;rdquo;.  And Hugo automatically generates a listing for this taxonomy value
at &lt;a href=&#34;http://npf.io/series/hugo-101&#34;&gt;/series/hugo-101&lt;/a&gt; (the taxonomy value gets
url-ized).  Any other series I make will be under a similar directory.&lt;/p&gt;

&lt;p&gt;This is fine and dandy and pretty aweomse out of the box&amp;hellip; but I really want to
automatically generate a list of posts in the series at the bottom of each post
in the series.  This is where things get tricky, but that&amp;rsquo;s also where things
get interesting.&lt;/p&gt;

&lt;p&gt;The examples for &lt;a href=&#34;http://hugo.spf13.com/taxonomies/displaying&#34;&gt;displaying
Taxonomies&lt;/a&gt; all &amp;ldquo;hard code&amp;rdquo; the
taxonomy value in the template&amp;hellip; this works great if you know ahead of time
what value you want to display, like &amp;ldquo;all posts with tag = &amp;lsquo;featured&amp;rsquo;&amp;rdquo;.
However, it doesn&amp;rsquo;t work if you don&amp;rsquo;t know ahead of time what the taxonomy value
will be (like the series on the current post).&lt;/p&gt;

&lt;p&gt;This is doable, but it&amp;rsquo;s a little more complicated.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll give you a dump of the relevant portion of my post template and then talk
about how I got there:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ if .Params.series }}
    {{ $name := index .Params.series 0 }}
    &amp;lt;hr/&amp;gt;
	&amp;lt;p&amp;gt;&amp;lt;a href=&amp;quot;&amp;quot; id=&amp;quot;series&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;This is a post in the 
	&amp;lt;b&amp;gt;{{$name}}&amp;lt;/b&amp;gt; series.&amp;lt;br/&amp;gt;
	Other posts in this series:&amp;lt;/p&amp;gt;

    {{ $name := $name | urlize }}
    {{ $series := index .Site.Taxonomies.series $name }}
    &amp;lt;ul class=&amp;quot;series&amp;quot;&amp;gt;
    {{ range $series.Pages }}
    	&amp;lt;li&amp;gt;{{.Date.Format &amp;quot;Jan 02, 2006&amp;quot;}} -
    	&amp;lt;a href=&amp;quot;{{.Permalink}}&amp;quot;&amp;gt;{{.LinkTitle}}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    {{end}}
    &amp;lt;/ul&amp;gt;
{{end}} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we start off defining this part of the template to only be used if the post
has a series.  Right, sure, move on.&lt;/p&gt;

&lt;p&gt;Now, the tricky part&amp;hellip; the taxonomy values for the current page resides in the
.Params values, just like any other custom metadata you assign to the page.&lt;/p&gt;

&lt;p&gt;Taxonomy values are always a list (so you can give things multiple tags etc),
but I know that I&amp;rsquo;ll never give something more than one series, so I can just
grab the first item from the list.  To do that, I use the index function, which
is just like calling series[0] and assign it to the $name variable.&lt;/p&gt;

&lt;p&gt;Now another tricky part&amp;hellip; the series in the metadata is in the pretty form you
put into the metadata, but the list of Taxonomies in .Site.Taxonomies is in the
urlized form&amp;hellip;  How did I figure that out?  Printf
debugging.  Hugo&amp;rsquo;s auto-reloading makes it really easy to use the template
itself to figure out what&amp;rsquo;s going on with the template and the data.&lt;/p&gt;

&lt;p&gt;When I started writing this template, I just put &lt;code&gt;{{$name}}&lt;/code&gt; in my post template
after the line where I got the name, and I could see it rendered on webpage of
my post that the name was &amp;ldquo;Hugo 101&amp;rdquo;.  Then I put &lt;code&gt;{{.Site.Taxonomies.series}}&lt;/code&gt;
and I saw something like &lt;code&gt;map[hugo-101:[{0 0xc20823e000} {0 0xc208048580} {0
0xc208372000}]]&lt;/code&gt;  which is ugly, but it showed me that the value in the map is
&amp;ldquo;hugo-101&amp;rdquo;&amp;hellip; and I realized it was using the urlized version, so I used the
pre-defined hugo function &lt;code&gt;urlize&lt;/code&gt; to convert the pretty series.&lt;/p&gt;

&lt;p&gt;And from there it&amp;rsquo;s just a matter of using &lt;code&gt;index&lt;/code&gt; again, this time to use
&lt;code&gt;$name&lt;/code&gt; as a key in the map of series&amp;hellip;.  .Site.Taxonomies is a map
(dictionary) of Taxonomy names (like &amp;ldquo;series&amp;rdquo;) to maps of Taxonomy values (like
&amp;ldquo;hugo-101&amp;rdquo;) to lists of pages.  So, .Site.Taxonomies.series reutrns a map of
series names to lists of pages&amp;hellip; index that by the current series names, and
bam, list of pages.&lt;/p&gt;

&lt;p&gt;And then it&amp;rsquo;s just a matter of iterating over the pages and displaying them
nicely. And what&amp;rsquo;s great is that this is now all automatic&amp;hellip; all old posts get
updated with links to the new posts in the series, and any new series I make,
regardless of the name, will get the nice list of posts at the bottom for that
series.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Hugo: Beyond the Defaults</title>
      <link>http://npf.io/2014/08/hugo-beyond-the-defaults/</link>
      <pubDate>Fri, 08 Aug 2014 10:07:46 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/08/hugo-beyond-the-defaults/</guid>
      <description>&lt;p&gt;In my last post, I had deployed what is almost the most basic Hugo site
possible.  The only reason it took more than 10 minutes is because I wanted to
tweak the theme.  However, there were a few things that immediately annoyed me.&lt;/p&gt;

&lt;p&gt;I didn&amp;rsquo;t like having to type &lt;code&gt;hugo -t hyde&lt;/code&gt; all the time.  Well, turns out
that&amp;rsquo;s not necessary.  You can just put  &lt;code&gt;theme = &amp;quot;hyde&amp;quot;&lt;/code&gt; in your site
config, and never need to type it again.  Sweet.  Now to run the local server, I
can just run &lt;code&gt;hugo server -w&lt;/code&gt;, and for final generation, I can just run &lt;code&gt;hugo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Next is that my posts were under npf.io/post/postname &amp;hellip; which is not the end
of the world, but I really like seeing the date in post URLs, so that it&amp;rsquo;s easy
to tell if I&amp;rsquo;m looking at something really, really old.  So, I went about
looking at how to do that.  Turns out, it&amp;rsquo;s trivial.  Hugo has a feature called
&lt;a href=&#34;http://hugo.spf13.com/extras/permalinks&#34;&gt;permalinks&lt;/a&gt;, where you can define the
format of the url for a section (a section is a top level division of your site,
denoted by a top level folder under content/).  So, all you have to do is, in
your site&amp;rsquo;s config file, put some config that looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[permalinks]
    post = &amp;quot;/:year/:month/:filename/&amp;quot;
    code = &amp;quot;/:filename/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While we&amp;rsquo;re at it, I had been putting my code in the top level content
directory, because I wanted it available at npf.io/projectname  &amp;hellip;. however
there&amp;rsquo;s no need to do that, I can put the code under the code directory and just
give it a permalink to show at the top level of the site.  Bam, awesome, done.&lt;/p&gt;

&lt;p&gt;One note: Don&amp;rsquo;t forget the slash at the end of the permalink.&lt;/p&gt;

&lt;p&gt;But wait, this will move my &amp;ldquo;Hugo is Friggin&amp;rsquo; Awesome&amp;rdquo; post to a different URL,
and Steve Francia already tweeted about it with the old URL.  I don&amp;rsquo;t want that
url to send people to a 404 page!
&lt;a href=&#34;http://hugo.spf13.com/extras/aliases&#34;&gt;Aliases&lt;/a&gt; to the rescue.  Aliases are just
a way to make redirects from old URLs to new ones.  So I just put &lt;code&gt;aliases =
[&amp;quot;/post/hugo-is-awesome/&amp;quot;]&lt;/code&gt; in the metadata at the top of that post, and now
links to there will redirect to the new location.  Awesome.&lt;/p&gt;

&lt;p&gt;Ok, so cool&amp;hellip; except that I don&amp;rsquo;t really want the content for my blog posts
under content/post/ &amp;hellip; I&amp;rsquo;d prefer them under content/blog, but still be of type
&amp;ldquo;post&amp;rdquo;.  So let&amp;rsquo;s change that too.  This is pretty easy, just rename the folder
from post to blog, and then set up an
&lt;a href=&#34;http://hugo.spf13.com/content/archetypes&#34;&gt;archetype&lt;/a&gt; to default the metadata
under /blog/ to type = &amp;ldquo;post&amp;rdquo;.  Archetypes are default metadata for a section,
so in this case, I make a file archetypes/blog.md and add type= &amp;ldquo;post&amp;rdquo; to the
archetype&amp;rsquo;s metadata, and now all my content created with &lt;code&gt;hugo new
blog/foo.md&lt;/code&gt; will be prepopulated as type &amp;ldquo;post&amp;rdquo;.  (does it matter if the type
is post vs. blog?  no.  But it matters to me ;)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/mlafeldt&#34;&gt;@mlafeldt&lt;/a&gt; on Twitter pointed out my RSS feed was
wonky&amp;hellip;. wait, I have an RSS feed?  Yes, Hugo &lt;a href=&#34;http://hugo.spf13.com/templates/rss&#34;&gt;has that
too&lt;/a&gt;.  There are feed XML files
automatically output for most listing directories&amp;hellip; and the base feed for the
site is a list of recent content.  So, I looked at what Hugo had made for me
(index.xml in the root output directory)&amp;hellip; this is not too bad, but I don&amp;rsquo;t
really like the title, and it&amp;rsquo;s including my code content in the feed as well as
posts, which I don&amp;rsquo;t really want.  Luckily, this is trivial to fix.  The RSS xml
file is output using a Go template just like everything else in the output.
It&amp;rsquo;s trivial to adjust the template so that it only lists content of type
&amp;ldquo;post&amp;rdquo;, and tweak the feed name, etc.&lt;/p&gt;

&lt;p&gt;I was going to write about how I got the series stuff at the bottom of this
page, but this post is long enough already, so I&amp;rsquo;ll just make that into its own
post, as the next post in the series! :)&lt;/p&gt;
</description>
    </item>
    
    
    
    
    
    <item>
      <title>Hugo Is Friggin&#39; Awesome</title>
      <link>http://npf.io/2014/08/hugo-is-awesome/</link>
      <pubDate>Fri, 01 Aug 2014 06:45:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/08/hugo-is-awesome/</guid>
      <description>&lt;p&gt;This blog is powered by &lt;a href=&#34;http://hugo.spf13.com&#34;&gt;Hugo&lt;/a&gt;, a static site generator
written by Steve Francia (aka spf13).  It is, of course, written in Go.  It is
pretty similar to &lt;a href=&#34;jekyllrb.com&#34;&gt;Jekyll&lt;/a&gt;, in that you write markdown, run a
little program (hugo) and html pages come out the other end in the form of a
full static site.  What&amp;rsquo;s different is that Jekyll is written in ruby and is
relatively slow, and Hugo is written in Go and is super fast&amp;hellip; only taking a
few milliseconds to render each page.&lt;/p&gt;

&lt;p&gt;Hugo includes a webserver to serve the content, which will regenerate the site
automatically when you change your content.  Your browser will update with the
changes immediately, making your development cycle for a site a very tight
loop.&lt;/p&gt;

&lt;p&gt;The basic premise of Hugo is that your content is organized in a specific way on
purpose.  Folders of content and the name of the files combine to turn into the
url at which they are hosted. For example, content/foo/bar/baz.md will be hosted
at &amp;lt;site&amp;gt;/foo/bar/baz.&lt;/p&gt;

&lt;p&gt;Every content file has a section of metadata at the top that allows you to
specify information about the content, like the title, date, even arbitrary data
for your specific site (for example, I have lists of badges that are shown on
pages for code projects).&lt;/p&gt;

&lt;p&gt;All the data in a content file is just that - data.  Other than markdown
specifying a rough view of your page, the actual way the content is viewed is
completely separated from the data.  Views are written in Go&amp;rsquo;s templating
language, which is quick to pick up and easy to use if you&amp;rsquo;ve used other
templating languages (or even if, like me, you haven&amp;rsquo;t).  This lets you do
things like iterate over all the entries in a menu and print them out in a ul/li
block, or iterate over all the posts in your blog and display them on the main
page.&lt;/p&gt;

&lt;p&gt;You can learn more about Hugo by going to &lt;a href=&#34;http://hugo.spf13.com&#34;&gt;its site&lt;/a&gt;,
which, of course, is built using Hugo.&lt;/p&gt;

&lt;p&gt;The static content for this site is hosted on github pages at
&lt;a href=&#34;https://github.com/natefinch/natefinch.github.io&#34;&gt;https://github.com/natefinch/natefinch.github.io&lt;/a&gt;. But the static content is
relatively boring&amp;hellip; that&amp;rsquo;s what you&amp;rsquo;re looking at in your browser right now.
What&amp;rsquo;s interesting is the code behind it.  That lives in a separate repo on
github at &lt;a href=&#34;https://github.com/natefinch/npf&#34;&gt;https://github.com/natefinch/npf&lt;/a&gt;.  This is where the markdown content
and templates live.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how I have things set up locally&amp;hellip; all open source code on my machine
lives in my GOPATH (which is set to my HOME).  So, it&amp;rsquo;s easy to find anything I
have ever downloaded. Thus, the static site lives at
$GOPATH/src/github.com/natefinch/natefinch.github.io and the markdown +
templates lives in $GOPATH/src/github.com/natefinch/npf.  I created a symbolic
link under npf called public that points to the natefinch.github.io directory.
This is the directory that hugo outputs the static site to by default&amp;hellip; that
way Hugo dumps the static content right into the correct directory for me to
commit and push to github.  I just had to add public to my .gitignore so
everyone wouldn&amp;rsquo;t get confused.&lt;/p&gt;

&lt;p&gt;Then, all I do is go to the npf directory, and run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo new post/urlofpost.md
hugo server --buildDrafts --watch -t hyde
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That generates a new content item that&amp;rsquo;ll show up on my site under
/post/urlofpost.  Then it runs the local webserver so I can watch the content by
pointing a browser at localhost:1313 on a second monitor as I edit the post in a
text editor. hyde is the name of the theme I&amp;rsquo;m using, though I have modified
it.  Note that hugo will mark the content as a draft by default, so you need
&amp;ndash;buildDrafts for it to get rendered locally, and remember to delete the draft =
true line in the page&amp;rsquo;s metadata when you&amp;rsquo;re ready to publish, or it won&amp;rsquo;t show
up on your site.&lt;/p&gt;

&lt;p&gt;When I&amp;rsquo;m satisfied, kill the server, and run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo -t hyde
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to generate the final site output, switch into the public directory, and&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git commit -am &amp;quot;some new post&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it.  Super easy, super fast, and no muss.  Coming from Blogger, this is
an amazingly better workflow with no wrestling with the WYSIWYG editor to make
it display stuff in a reasonable fashion.  Plus I can write posts 100% offline
and publish them when I get back to civilization.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a lot more to Hugo, and a lot more I want to do with the site, but that
will come in time and with more posts :)&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>First Post</title>
      <link>http://npf.io/2014/08/first/</link>
      <pubDate>Fri, 01 Aug 2014 06:30:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/08/first/</guid>
      <description>&lt;p&gt;This is the first post of my new blog.  You may (eventually) see old posts
showing up behind here, those have been pulled in from my personal blog at
&lt;a href=&#34;http://blog.natefinch.com&#34;&gt;blog.natefinch.com&lt;/a&gt;. I&amp;rsquo;ve decided to split off my
programming posts so that people who only want to see the coding stuff don&amp;rsquo;t
have to see my personal posts, and people that only want to see my personal
stuff don&amp;rsquo;t have to get inundated with programming posts.&lt;/p&gt;

&lt;p&gt;Right now the site is pretty basic, but I will add more features to it, such as post history etc.&lt;/p&gt;
</description>
    </item>
    
    
    
    
    
    
    
    <item>
      <title>CI for Windows Go Packages with AppVeyor</title>
      <link>http://npf.io/2014/07/ci-for-windows-go-packages-with-appveyor/</link>
      <pubDate>Wed, 09 Jul 2014 17:43:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/07/ci-for-windows-go-packages-with-appveyor/</guid>
      <description>&lt;p&gt;I recently needed to update my &lt;a href=&#34;https://github.com/natefinch/npipe&#34; target=&#34;_blank&#34;&gt;npipe&lt;/a&gt; package, and since I want it to be production quality, that means setting up CI, so that people using my package can know it&amp;rsquo;s passing tests. &amp;nbsp;Normally I&amp;rsquo;d use Travis CI or Drone.io for that, but npipe is a Windows-only Go package, and neither of the aforementioned services support running tests on Windows.&lt;br /&gt;&lt;br /&gt;With some googling, I saw that &lt;a href=&#34;https://twitter.com/nathany&#34; target=&#34;_blank&#34;&gt;Nathan Youngman&lt;/a&gt;&amp;nbsp;had worked with&amp;nbsp;&lt;a href=&#34;http://www.appveyor.com/&#34; target=&#34;_blank&#34;&gt;AppVeyor&lt;/a&gt;&amp;nbsp;to add Go support to their CI system. &amp;nbsp;The example on the blog talks about making a build.cmd file in your repo to enable Go builds, but I found that you can easily set up a Go build without having to put CI-specific files in your repo.&lt;br /&gt;&lt;br /&gt;To get started with AppVeyor, just log into their site and tell it where to get your code (I logged in with Github, and it was easy to specify what repo of mine to test). &amp;nbsp;Once you choose the repo, go to the Settings page on AppVeyor for that repo. &amp;nbsp;Under the Environment tab on the left, set the clone directory to C:\GOPATH\src&amp;amp;lt;your import path&amp;gt; and set an environment variable called GOPATH to C:\GOPATH. &amp;nbsp;Under the build tab, set the build type to &amp;ldquo;SCRIPT&amp;rdquo; and the script type to &amp;ldquo;CMD&amp;rdquo;, and make the contents of the script &lt;pre style=&#34;tab-size: 4;&#34;&gt;go get -v -d -t &amp;lt;your import path&amp;gt;/&amp;hellip;&lt;/pre&gt; (this will download the dependencies for your package). &amp;nbsp;In the test tab, set the test type to &amp;ldquo;SCRIPT&amp;rdquo;, the script type to &amp;ldquo;CMD&amp;rdquo; and the script contents to &lt;pre style=&#34;tab-size: 4;&#34;&gt;go test -v -cover ./&amp;hellip;&lt;/pre&gt; &amp;nbsp;(this will run all the tests in verbose mode and also output the test coverage).&lt;br /&gt;&lt;br /&gt;That&amp;rsquo;s pretty much it. &amp;nbsp;AppVeyor will automatically run a build on commits, like you&amp;rsquo;d expect. &amp;nbsp;You can watch the progress on a console output on their page, and get a pretty little badge from the badges page. &amp;nbsp;It&amp;rsquo;s free for open source projects, and seems relatively responsive from my admittedly limited experience.&lt;br /&gt;&lt;br /&gt;This is a great boon for Go developers, so you can be sure your code builds and passes tests on Windows, with very little work to set it up. &amp;nbsp;I&amp;rsquo;m probably going to add this to all my production repos, even the ones that aren&amp;rsquo;t Windows-only, to ensure my code works well on Windows as well as Linux.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Intro to BoltDB: Painless Performant Persistence</title>
      <link>http://npf.io/2014/07/intro-to-boltdb-painless-performant-persistence/</link>
      <pubDate>Mon, 07 Jul 2014 08:25:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/07/intro-to-boltdb-painless-performant-persistence/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://github.com/boltdb/bolt&#34; target=&#34;_blank&#34;&gt;BoltDB&lt;/a&gt; is a pure Go persistence solution that saves data to a memory mapped file.  I call it a persistence solution and not a database, because the word database has a lot of baggage associated with it that doesn&amp;rsquo;t apply to bolt. And that lack of baggage is what makes bolt so awesome.&lt;br /&gt;&lt;br /&gt;Bolt is just a Go package.  There&amp;rsquo;s nothing you need to install on the system, no configuration to figure out before you can start coding, nothing.  You just go get github.com/boltdb/bolt and then import &amp;ldquo;github.com/boltdb/bolt&amp;rdquo;. &lt;br /&gt;&lt;br /&gt;All you need to fully use bolt as storage is a file name.  This is fantastic from both a developer&amp;rsquo;s point of view, and a user&amp;rsquo;s point of view.  I don&amp;rsquo;t know about you, but I&amp;rsquo;ve spent months of work time over my career configuring and setting up databases and debugging configuration problems, users and permissions and all the other crap you get from more traditional databases like Postgres and Mongo.  There&amp;rsquo;s none of that with bolt.  No users, no setup, just a file name.  This is also a boon for users of your application, because &lt;em&gt;they&lt;/em&gt; don&amp;rsquo;t have to futz with all that crap either.&lt;br /&gt;&lt;br /&gt;Bolt is not a relational database.  It&amp;rsquo;s not even a document store, though you can sort of use it that way.  It&amp;rsquo;s really just a key/value store&amp;hellip; but don&amp;rsquo;t worry if you don&amp;rsquo;t really know what that means or how you&amp;rsquo;d use that for storage.  It&amp;rsquo;s super simple and it&amp;rsquo;s incredibly flexible.  Let&amp;rsquo;s take a look.&lt;br /&gt;&lt;br /&gt;Storage in bolt is divided into buckets.  A bucket is simply a named collection of key/value pairs, just like Go&amp;rsquo;s map.  The name of the bucket, the keys, and the values are all of type []byte.  Buckets can contain other buckets, also keyed by a []byte name. &lt;br /&gt;&lt;br /&gt;&amp;hellip; that&amp;rsquo;s it.  No, really, that&amp;rsquo;s it.  Bolt is basically a bunch of nested maps.  And this simplicity is what makes it so easy to use.  There&amp;rsquo;s no tables to set up, no schemas, no complex querying language to struggle with.  Let&amp;rsquo;s look at a bolt hello world:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;package main&lt;br /&gt;&lt;br /&gt;import (&lt;br /&gt;    &amp;ldquo;fmt&amp;rdquo;&lt;br /&gt;    &amp;ldquo;log&amp;rdquo;&lt;br /&gt;&lt;br /&gt;    &amp;ldquo;github.com/boltdb/bolt&amp;rdquo;&lt;br /&gt;)&lt;br /&gt;&lt;br /&gt;var world = []byte(&amp;ldquo;world&amp;rdquo;)&lt;br /&gt;&lt;br /&gt;func main() {&lt;br /&gt;    db, err := bolt.Open(&amp;ldquo;/home/nate/foo/bolt.db&amp;rdquo;, 0644, nil)&lt;br /&gt;    if err != nil {&lt;br /&gt;        log.Fatal(err)&lt;br /&gt;    }&lt;br /&gt;    defer db.Close()&lt;br /&gt;&lt;br /&gt;    key := []byte(&amp;ldquo;hello&amp;rdquo;)&lt;br /&gt;    value := []byte(&amp;ldquo;Hello World!&amp;rdquo;)&lt;br /&gt;&lt;br /&gt;    // store some data&lt;br /&gt;    err = db.Update(func(tx *bolt.Tx) error {&lt;br /&gt;        bucket, err := tx.CreateBucketIfNotExists(world)&lt;br /&gt;        if err != nil {&lt;br /&gt;            return err&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        err = bucket.Put(key, value)&lt;br /&gt;        if err != nil {&lt;br /&gt;            return err&lt;br /&gt;        }&lt;br /&gt;        return nil&lt;br /&gt;    })&lt;br /&gt;&lt;br /&gt;    if err != nil {&lt;br /&gt;        log.Fatal(err)&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    // retrieve the data&lt;br /&gt;    err = db.View(func(tx *bolt.Tx) error {&lt;br /&gt;        bucket := tx.Bucket(world)&lt;br /&gt;        if bucket == nil {&lt;br /&gt;            return fmt.Errorf(&amp;ldquo;Bucket %q not found!&amp;rdquo;, world)&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        val := bucket.Get(key)&lt;br /&gt;        fmt.Println(string(val))&lt;br /&gt;&lt;br /&gt;        return nil&lt;br /&gt;    })&lt;br /&gt;&lt;br /&gt;    if err != nil {&lt;br /&gt;        log.Fatal(err)&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;// output:&lt;br /&gt;// Hello World!&lt;/pre&gt;&lt;div&gt;&lt;/div&gt;I know what you&amp;rsquo;re thinking - that seems kinda long.  But keep in mind, I fully handled all errors in at least a semi-proper way, and we&amp;rsquo;re doing all this:&lt;br /&gt;&lt;br /&gt;1.) creating a database &lt;br /&gt;2.) creating some structure (the &amp;ldquo;world&amp;rdquo; bucket)&lt;br /&gt;3.) storing data to the structure&lt;br /&gt;4.) retrieving data from the structure.&lt;br /&gt;&lt;br /&gt;I think that&amp;rsquo;s not too bad in 54 lines of code.&lt;br /&gt;&lt;br /&gt;So let&amp;rsquo;s look at what that example is really doing.  First we call bolt.Open to get the database.  This will create the file if necessary, or open it if it exists.&lt;br /&gt;&lt;br /&gt;All reads from or writes to the bolt database must be done within a transaction. You can have as many Readers in read-only transactions at the same time as you want, but only one Writer in a writable transaction at a time (readers maintain a consistent view of the DB while writers are writing).&lt;br /&gt;&lt;br /&gt;To begin, we call db.Update, which takes a function to which it&amp;rsquo;ll pass a bolt.Tx - bolt&amp;rsquo;s transaction object.  We then create a Bucket (since all data in bolt lives in buckets), and add our key/value pair to it.  After the write transaction finishes, we start a read- only transaction with DB.View, and get the values back out.&lt;br /&gt;&lt;br /&gt;What&amp;rsquo;s great about bolt&amp;rsquo;s transaction mechanism is that it&amp;rsquo;s super simple - the scope of the function is the scope of the transaction.  If the function passed to Update returns nil, all updates from the transaction are atomically stored to the database.  If the function passed to Update returns an error, the transaction is rolled back.  This makes bolt&amp;rsquo;s transactions completely intuitive from a Go developer&amp;rsquo;s point of view.  You just exit early out of your function by returning an error as usual, and bolt Does The Right Thing.  No need to worry about manually rolling back updates or anything, just return an error.&lt;br /&gt;&lt;br /&gt;The only other basic thing you may need is to iterate over key/value pairs in a Bucket, in which case, you just call bucket.Cursor(), which returns a Cursor value, which has functions like Next(), Prev() etc that return a key/value pair and work like you&amp;rsquo;d expect.&lt;br /&gt;&lt;br /&gt;There&amp;rsquo;s a lot more to the bolt API, but most of the rest of it is more about database statistics and some stuff for more advanced usage scenarios&amp;hellip; but the above is all you really need to know to start storing data in a bolt database.&lt;br /&gt;&lt;br /&gt;For a more complex application, just storing strings in the database may not be sufficient, but that&amp;rsquo;s ok, Go has your back there, too.  You can easily use encoding/json or encoding/gob to serialize structs into the database, keyed by a unique name or id.  This is what makes it easy for bolt to go from a key/value store to a document store - just have one bucket per document type.  Again, the benefit of bolt is low barrier of entry.  You don&amp;rsquo;t have to figure out a whole database schema or install anything to be able to just start dumping data to disk in a performant and manageable way.&lt;br /&gt;&lt;br /&gt;The main drawback of bolt is that there are no queries.  You can&amp;rsquo;t say &amp;ldquo;give me all foo objects with a name that starts with bar&amp;rdquo;.  You &lt;i&gt;could&lt;/i&gt; make your own index in the database and keep it up to date manually.  This could be as easy as a slice of IDs serialized into an &amp;ldquo;indices&amp;rdquo; bucket for a particular query. Obviously, this is where you start getting into the realm of developing your own relational database, but if you don&amp;rsquo;t go overboard, it can be nice that all this code is just that - code.  It&amp;rsquo;s not queries in some external DSL, it&amp;rsquo;s just code like you&amp;rsquo;d write for an in-memory data store.&lt;br /&gt;&lt;br /&gt;Bolt is not for every application.  You must understand your application&amp;rsquo;s needs and if bolt&amp;rsquo;s key/value style will be sufficient to fulfill those needs.  If it is, I think you&amp;rsquo;ll be very happy to use such a simple data store with so little mental overhead.&lt;br /&gt;&lt;br /&gt;[edited to clarify reader/writer relationship]   Bonus Gob vs. Json benchmark for storing structs in Bolt: &lt;pre&gt;&lt;br /&gt;BenchmarkGobEncode  1000000       2191 ns/op&lt;br /&gt;BenchmarkJsonEncode   500000       4738 ns/op&lt;br /&gt;BenchmarkGobDecode  1000000       2019 ns/op&lt;br /&gt;BenchmarkJsonDecode   200000      12993 ns/op&lt;br /&gt;&lt;/pre&gt;Code: &lt;a href=&#34;http://play.golang.org/p/IvfDUGBpJ6&#34;&gt;http://play.golang.org/p/IvfDUGBpJ6&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Autogenerate docs with this one dumb trick</title>
      <link>http://npf.io/2014/06/autogenerate-docs-with-this-one-dumb-trick/</link>
      <pubDate>Tue, 17 Jun 2014 05:59:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/06/autogenerate-docs-with-this-one-dumb-trick/</guid>
      <description>&lt;p&gt;Yesterday, I was trying to think of a way of automating some doc generation for my go packages.  The specific task I wanted to automate was updating a badge in my package&amp;rsquo;s README to show the test coverage.  What I wanted was a way to run go test -cover, parse the results, and put the result in the correct spot of my README.  My first thought was to write an application that would do that for me &amp;hellip; but then I&amp;rsquo;d have to run that &lt;i&gt;instead&lt;/i&gt; of go test.  What I realized I wanted was something that was &amp;ldquo;compatible with go test&amp;rdquo; - i.e. I want to run go test and not have to remember to run some special other command.&lt;br /&gt;&lt;br /&gt;And that&amp;rsquo;s when it hit me:  What is a test in Go?  A test is a Go function that gets run when you run &amp;ldquo;go test&amp;rdquo;. &amp;nbsp;Nothing says your test has to actually test anything. &amp;nbsp;And nothing prevents your test from doing something permanent on your machine (in fact we usually have to bend over backwards to make sure our tests &lt;i&gt;don&amp;rsquo;t&lt;/i&gt;&amp;nbsp;do anything permanent. &amp;nbsp;You can just write a test function that updates the docs for you.&lt;br /&gt;&lt;br /&gt;I actually quite like this technique. &amp;nbsp;I often have some manual tasks after updating my code - usually updating the docs in the README with changes to the API, or changing the docs to show new CLI flags, etc. &amp;nbsp;And there&amp;rsquo;s one thing I always do after I update my code - and that&amp;rsquo;s run &amp;ldquo;go test&amp;rdquo;. &amp;nbsp;If that also updates my docs, all the better.&lt;br /&gt;&lt;br /&gt;This is how covergen was born. &amp;nbsp;&lt;a href=&#34;https://github.com/natefinch/covergen&#34;&gt;https://github.com/natefinch/covergen&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;Covergen is a particularly heinous example of a test that updates your docs. &amp;nbsp;The heinous part is that it actually doubles the time it takes to run your tests&amp;hellip; this is because that one test re-runs all the tests with -cover to get the coverage percent. &amp;nbsp;I&amp;rsquo;m not sure I&amp;rsquo;d actually release real code that used such a thing - doubling the time it takes to run your tests just to save a few seconds of copy and paste is pretty terrible.&lt;br /&gt;&lt;br /&gt;However, it&amp;rsquo;s a valid example of what you can do when you throw away testing convention and decide you want to write some code in a test that doesn&amp;rsquo;t actually test anything, and instead just runs some automated tasks that you want run whenever anyone runs go test. &amp;nbsp;Just make sure the result is idempotent so you&amp;rsquo;re not continually causing things to look modified to version control.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Diffing Go with Beyond Compare</title>
      <link>http://npf.io/2014/05/diffing-go-with-beyond-compare/</link>
      <pubDate>Wed, 14 May 2014 13:09:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/05/diffing-go-with-beyond-compare/</guid>
      <description>&lt;p&gt;I love Beyond Compare, it&amp;rsquo;s an awesome visual diff/merge tool. &amp;nbsp;It&amp;rsquo;s not free, but I don&amp;rsquo;t care, because it&amp;rsquo;s awesome. &amp;nbsp;However, there&amp;rsquo;s no built-in configuration for Go code, so I made one. &amp;nbsp;Not sure what the venn diagram of Beyond Compare users and Go users looks like, it might be that I&amp;rsquo;m the one point of crossover, but just in case I&amp;rsquo;m not, here&amp;rsquo;s the configuration file for Beyond Compare 3 for the Go programming language:&amp;nbsp;&lt;a href=&#34;http://play.golang.org/p/G6NWE0z1GC&#34;&gt;http://play.golang.org/p/G6NWE0z1GC&lt;/a&gt; &amp;nbsp;(please forgive the abuse of the Go playground)&lt;br /&gt;&lt;br /&gt;Just copy the text into a file and in Beyond Compare, go to Tools-&amp;gt;Import Settings&amp;hellip; and choose the file. &amp;nbsp;Please let me know if you have any troubles or suggested improvements.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Intro&#43;&#43; to Go Interfaces</title>
      <link>http://npf.io/2014/05/intro-to-go-interfaces/</link>
      <pubDate>Tue, 13 May 2014 07:08:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/05/intro-to-go-interfaces/</guid>
      <description>

&lt;h3 id=&#34;toc_0&#34;&gt;Standard Interface Intro&lt;/h3&gt;

&lt;p&gt;Go’s interfaces are one of it’s best features, but they’re also one of the most confusing for newbies.  This post will try to give you the understanding you need to use Go’s interfaces and not get frustrated when things don’t work the way you expect.  It’s a little long, but a bunch of that is just code examples.&lt;/p&gt;

&lt;p&gt;Go’s interfaces are different than interfaces in other languages, they are implicitly fulfilled.  This means that you never need to mark your type as explicitly implementing the interface (like class CFoo implements IFoo).  Instead, your type just needs to have the methods defined in the interface, and the compiler does the rest.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Walker interface {
    Walk(miles int)
}

type Camel struct {
    Name string
}

func (c Camel) Walk(miles int) {
     fmt.Printf(“%s is walking %v miles\n”, c.Name, miles)
}

func LongWalk(w Walker) {
     w.Walk(500)
     w.Walk(500)
}

func main() {
    c := Camel{“Bill”}
    LongWalk\(c)
}

// prints
// Bill is walking 500 miles.
// Bill is walking 500 miles.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/erodX-JplO&#34;&gt;http://play.golang.org/p/erodX-JplO&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Camel implements the Walker interface, because it has a method named Walk that
takes an int and doesn’t return anything.  This means you can pass it into the
LongWalk function, even though you never specified that your Camel is a Walker.
In fact, Camel and Walker can live in totally different packages and never know
about one another, and this will still work if a third package decides to make a
Camel and pass it into LongWalk.&lt;/p&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;Non-Standard Continuation&lt;/h3&gt;

&lt;p&gt;This is where most tutorials stop, and where most questions and problems begin.
The problem is that you still don’t know how the interfaces actually work, and
since it’s not actually that complicated, let’s talk about that.&lt;/p&gt;

&lt;p&gt;What actually happens when you pass Camel into LongWalk?&lt;/p&gt;

&lt;p&gt;So, first off, you’re not passing Camel into LongWalk.  You’re actually
assigning c, a value of type Camel to a value w of type Walker, and w is what
you operate on in LongWalk.&lt;/p&gt;

&lt;p&gt;Under the covers, the Walker interface (like all interfaces), would look more or
less like this if it were in Go (the actual code is in C, so this is just a
really rough approximation that is easier to read).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Walker struct {
    type InterfaceType
    data *void
}

type InterfaceType struct {
    valtype *gotype
    func0 *func
    func1 *func
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All interfaces values are just two pointers - one pointer to information about
the interface type, and one pointer to the data from the value you passed into
the interface (a void in C-like languages… this should probably be Go’s
unsafe.Pointer, but I liked the explicitness of two actual *’s in the struct to
show it’s just two pointers).&lt;/p&gt;

&lt;p&gt;The InterfaceType contains a pointer to information about the type of the value
that you passed into the interface (valtype).  It also contains pointers to the
methods that are available on the interface.&lt;/p&gt;

&lt;p&gt;When you assign c to w, the compiler generates instructions that looks more or
less like this (it’s not actually generating Go, this is just an easier-to-read
approximation):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data := c
w := Walker{ 
    type: &amp;amp;InterfaceType{ 
              valtype: &amp;amp;typeof\(c), 
              func0: &amp;amp;Camel.Walk 
          }
    data: &amp;amp;data
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you assign your Camel value c to the Walker value w, the Camel type is
copied into the interface value’s Type.valtype field.  The actual data in the
value of c is copied into a new place in memory, and w’s Data field points at
that memory location.&lt;/p&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;Implications of the Implementation&lt;/h3&gt;

&lt;p&gt;Now, let’s look at the implications of this code.  First, interface values are
very small - just two pointers.  When you assign a value to an interface, that
value gets copied once, into the interface, but after that, it’s held in a
pointer, so it doesn’t get copied again if you pass the interface around.&lt;/p&gt;

&lt;p&gt;So now you know why you don’t need to pass around pointers to interfaces -
they’re small anyway, so you don’t have to worry about copying the memory, plus
they hold your data in a pointer, so changes to the data will travel with the
interface.&lt;/p&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;Interfaces Are Types&lt;/h3&gt;

&lt;p&gt;Let’s look at Walker again, this is important:&lt;/p&gt;

&lt;p&gt;type Walker interface&lt;/p&gt;

&lt;p&gt;Note that first word there: type.  Interfaces are types, just like string is a
type or Camel is a type.  They aren’t aliases, they’re not magic hand-waving,
they’re real types and real values which are distinct from the type and value
that gets assigned to them.&lt;/p&gt;

&lt;p&gt;Now, let’s assume you have this function:&lt;/p&gt;

&lt;p&gt;func LongWalkAll(walkers []Walker) {
    for _, w := range walkers {
        LongWalk(w)
    }
}&lt;/p&gt;

&lt;p&gt;And let’s say you have a caravan of Camels that you want to send on a long walk:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;caravan := []Camel{ Camel{“Bill”}, Camel{“Bob”}, Camel{“Steve”}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You want to pass caravan into LongWalkAll, will the compiler let you?  Nope.
Why is that?  Well, []Walker is a specific type, it’s a slice of values of type
Walker.  It’s not shorthand for “a slice of anything that matches the Walker
interface”.  It’s an actual distinct type, the way []string is different from
[]int.  The Go compiler will output code to assign a single value of Camel to a
single value of Walker.  That’s the only place it’ll help you out.  So, with
slices, you have to do it yourself:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;walkers := make([]Walker, len(caravan))
for n, c := range caravan {
    walkers[n] = c
}
LongWalkAll(walkers)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, there’s a better way if you know you’ll just need the caravan for
passing into LongWalkAll:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;caravan := []Walker{ Camel{“Bill”}, Camel{“Bob”}, Camel{“Steve”}}
LongWalkAll(caravan)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this goes for any type which includes an interface as part of its
definition: there’s no automatic conversion of your func(Camel) into
func(Walker) or map[string]Camel into map[string]Walker.  Again, they’re totally
different types, they’re not shorthand, and they’re not aliases, and they’re not
just a pattern for the compiler to match.&lt;/p&gt;

&lt;p&gt;Interfaces and the Pointers That Satisfy Them&lt;/p&gt;

&lt;p&gt;What if Camel’s Walk method had this signature instead?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Camel) Walk(miles int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This line says that the type *Camel has a function called Walk.  This is
important: *Camel is a type.  It’s the “pointer to a Camel” type.  It’s a
distinct type from (non-pointer) Camel.  The part about it being a pointer is
part of its type.  The Walk method is on the type *Camel.  The Walk method (in
this new incarnation) is not on the type Camel. This becomes important when you
try to assign it to an interface.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c := Camel{“Bill”}
LongWalk(c)

// compiler output:
cannot use c (type Camel) as type Walker in function argument:
 Camel does not implement Walker (Walk method has pointer receiver)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To pass a Camel into LongWalk now, you need to pass in a pointer to a Camel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c := &amp;amp;Camel{“Bill”}
LongWalk\(c)

or

c := Camel{“Bill”}
LongWalk(&amp;amp;c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this true even though you can still call Walk directly on Camel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c := Camel{“Bill”}
c.Walk(500) // this works
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason you can do that is that the Go compiler automatically converts this
line to (&amp;amp;c).Walk(500) for you.  However, that doesn’t work for passing the
value into an interface.  The reason is that the value in an interface is in a
hidden memory location, and so the compiler can’t automatically get a pointer to
that memory for you (in Go parlance, this is known as being “not addressable”).&lt;/p&gt;

&lt;h3 id=&#34;toc_4&#34;&gt;Nil Pointers and Nil Interfaces&lt;/h3&gt;

&lt;p&gt;The interaction between nil interfaces and nil pointers is where nearly everyone
gets tripped up when they first start with Go.&lt;/p&gt;

&lt;p&gt;Let’s say we have our Camel type with the Walk method defined on *Camel as
above, and we want to make a function that returns a Walker that is actually a
Camel (note that you don’t need a function to do this, you can just assign a
*Camel to a Walker, but the function is a good illustrative example):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func MakeWalker() Walker {
    return &amp;amp;Camel{“Bill”}
}

w := MakeWalker()
if w != nil {
    w.Walk(500)  // we will hit this
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works fine.  But now, what if we do something a little different:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func MakeWalker(c *Camel) Walker {
    return c
}

var c *Camel
w := MakeWalker\(c)
if w != nil {
    // we’ll get in here, but why?
    w.Walk(500)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code will also get inside the if statement (and then panic, which we’ll
talk about in a bit) because the returned Walker value is not nil.  How is that
possible, if we returned a nil pointer?  Well, let’s go look back to the
instructions that get generated when we assign a value to an interface.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data := c
w := Walker{ 
    type: &amp;amp;InterfaceType{ 
              valtype: &amp;amp;typeof\(c), 
              func0: &amp;amp;Camel.Walk 
          }
    data: &amp;amp;data
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, c is a nil pointer. However, that’s a perfectly valid value to
assign to the Walker’s Data value, so it works just fine.  What you return is a
non-nil Walker value, that has a pointer to a nil *Camel as its data.  So, of
course, if you check w == nil, the answer is false, w is not nil… but then
inside the if statement, we try to call Camel’s walk:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Camel) Walk(miles int) {
     fmt.Printf(“%s is walking %v miles\n”, c.Name, miles)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And when we try to do c.Name, Go automatically turns that into (*c).Name, and
the code panics with a nil pointer dereference error.&lt;/p&gt;

&lt;p&gt;Hopefully this makes sense, given our new understanding of how interfaces wrap
values, but then how do you account for nil pointers?  Assume you want
MakeWalker to return a nil interface if it gets passed a nil Camel.  You have to
explicitly assign nil to the interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func MakeWalker(c *Camel) Walker {
    if c == nil {
        return nil
    }
    return c
}

var c *Camel
w := MakeWalker\(c)
if w != nil {
    // Yay, we don’t get here!
    w.Walk(500)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now, finally, the code is doing what we expect.  When you pass in a nil
*Camel, we return a nil interface.  Here’s an alternate way to write the
function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func MakeWalker(c *Camel) Walker {
    var w Walker
    if c != nil {
        w = c
    }
    return w
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is slightly less optimal, but it shows the other way to get a nil
interface, which is to use the zero value for the interface, which is nil.&lt;/p&gt;

&lt;p&gt;Note that you can have a nil pointer value that satisfies an interface.  You
just need to be careful not to dereference the pointer in your methods.  For
example, if *Camel’s Walk method looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Camel) Walk(miles int) {
    fmt.Printf(“I’m walking %d miles!”, miles)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this method does not dereference c, and therefore you can call it even
if c is nil:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var c *Camel
c.Walk(500)
// prints “I’m walking 500 miles!”
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/4EfyV21at9&#34;&gt;http://play.golang.org/p/4EfyV21at9&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;toc_5&#34;&gt;Outro&lt;/h3&gt;

&lt;p&gt;I hope this article helps you better understand how interfaces works, and helps
you avoid some of the common pitfalls and misconceptions newbies have about how
interfaces work.  If you want more information about the internals of interfaces
and some of the optimizations that I didn’t cover here, read Russ Cox’s article
on Go interfaces, I highly recommend it.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Mocking functions in Go</title>
      <link>http://npf.io/2014/04/mocking-functions-in-go/</link>
      <pubDate>Thu, 10 Apr 2014 11:35:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/04/mocking-functions-in-go/</guid>
      <description>&lt;p&gt;Functions in Go are first class citizens, that means you can have a variable that contains a function value, and call it like a regular function.&lt;br /&gt;&lt;pre style=&#34;tab-size: 4;&#34;&gt;printf := fmt.Printf&lt;br /&gt;printf(&amp;ldquo;This will output %d line.\n&amp;rdquo;, 1)&lt;/pre&gt;This ability can come in very handy for testing code that calls a function which is hard to properly test while testing the surrounding code. &amp;nbsp;In &lt;a href=&#34;http://juju.ubuntu.com/&#34; target=&#34;_blank&#34;&gt;Juju&lt;/a&gt;, we occasionally use function variables to allow us to stub out a difficult function during tests, in order to more easily test the code that calls it. &amp;nbsp;Here&amp;rsquo;s a simplified example:&lt;br /&gt;
&lt;pre style=&#34;tab-size: 4;&#34;&gt;// in install/mongodb.go&lt;br /&gt;package install&lt;br /&gt;&lt;br /&gt;func SetupMongodb(path string) error {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;// suppose the code in this method modifies files in root&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;// directories, mucks with the environment, etc&amp;hellip; &lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;// Actions you actively don&amp;rsquo;t want to do during most tests.&lt;br /&gt;}&lt;/pre&gt;&lt;/span&gt;&lt;pre style=&#34;tab-size: 4;&#34;&gt;&lt;br /&gt;// in startup/bootstrap.go&lt;br /&gt;package startup&lt;br /&gt;&lt;br /&gt;func Bootstrap() error {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;hellip;&lt;br /&gt;&amp;nbsp; &amp;nbsp; path := getPath()&lt;br /&gt;&amp;nbsp; &amp;nbsp; if err := install.SetupMongodb(path); err != nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;return err&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;hellip;&lt;br /&gt;}&lt;/pre&gt;&lt;/span&gt;So, suppose you want to write a test for Bootstrap, but you know SetupMongodb won&amp;rsquo;t work, because the tests don&amp;rsquo;t run with root privileges (and you don&amp;rsquo;t want to setup mongodb on the dev&amp;rsquo;s machine anyway). &amp;nbsp;What can you do? &amp;nbsp;This is where mocking comes in.&lt;br /&gt;&lt;br /&gt;We just make a little tweak to Bootstrap:&lt;br /&gt;&lt;pre style=&#34;tab-size: 4;&#34;&gt;package startup&lt;br /&gt;&lt;br /&gt;var setupMongo = install.SetupMongodb&lt;br /&gt;&lt;br /&gt;func Bootstrap() error {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;hellip;&lt;br /&gt;&amp;nbsp; &amp;nbsp; path := getRootDirPath()&lt;br /&gt;&amp;nbsp; &amp;nbsp; if err := setupMongo(path); err != nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;return err&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;hellip;&lt;br /&gt;}&lt;/pre&gt;&lt;/span&gt;Now if we want to test Bootstrap, we can mock out the setupMongo function thusly:&lt;br /&gt;&lt;pre style=&#34;tab-size: 4;&#34;&gt;&lt;span style=&#34;TRACE&#34;&gt;// in startup/bootstrap_test.go&lt;br /&gt;package startup&lt;br /&gt;&lt;br /&gt;type fakeSetup struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; path string&lt;br /&gt;&amp;nbsp; &amp;nbsp; err error&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;func (f *fakeSetup) setup(path string) error {&lt;br /&gt;&amp;nbsp; &amp;nbsp; f.path = path&lt;br /&gt;&amp;nbsp; &amp;nbsp; return f.err&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;TestBootstrap(t *testing.T) {&lt;br /&gt;&amp;nbsp; &amp;nbsp; f := &amp;amp;fakeSetup{ err: errors.New(&amp;ldquo;Failed!&amp;rdquo;) }&lt;br /&gt;&amp;nbsp; &amp;nbsp; // this mocks out the function that Bootstrap() calls&lt;br /&gt;&amp;nbsp; &amp;nbsp; setupMongo = f.setup&lt;br /&gt;&amp;nbsp; &amp;nbsp; err := Bootstrap()&lt;br /&gt;&amp;nbsp; &amp;nbsp; if err != f.err {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; t.Fail(&amp;ldquo;Error from setupMongo not returned.  Expected %v, got %v&amp;rdquo;, f.err, err)&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; expPath := getPath()&lt;br /&gt;&amp;nbsp; &amp;nbsp; if f.path != expPath {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; t.Fail(&amp;ldquo;Path not correctly passed into setupMongo. Expected %q, got %q&amp;rdquo;, expPath, f.path)&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; // and then try again with f.err == nil, you get the idea&lt;br /&gt;}&lt;/pre&gt;&lt;/span&gt;Now we have full control over what happens in the setupMongo function, we can record the parameters that are passed into it, what it returns, and test that Bootstrap is at least using the API of the function correctly.&lt;br /&gt;&lt;br /&gt;Obviously, we need tests elsewhere for install.SetupMongodb to make sure it does the right thing, but those can be tests internal to the install package, which can use non-exported fields and functions to effectively test the logic that would be impossible from an external package (like the setup package).  Using this mocking means that we don&amp;rsquo;t have to worry about setting up an environment that allows us to test SetupMongodb when we really only want to test Bootstrap. &amp;nbsp;We can just stub out the function and test that Bootstrap does everything correctly, and trust that SetupMongodb works because it&amp;rsquo;s tested in its own package.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Effective Godoc</title>
      <link>http://npf.io/2014/04/effective-godoc/</link>
      <pubDate>Tue, 01 Apr 2014 06:43:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/04/effective-godoc/</guid>
      <description>&lt;p&gt;I started to write a blog post about how to get the most out of godoc, with examples in a repo, and then realized I could just write the whole post as godoc on the repo, so that&amp;rsquo;s what I did. &amp;nbsp;Feel free to send pull requests if there&amp;rsquo;s anything you see that could be improved.&lt;br /&gt;&lt;br /&gt;I actually learned quite a lot writing this article, by exploring all the nooks and crannies of Go&amp;rsquo;s documentation generation. &amp;nbsp;Hopefully you&amp;rsquo;ll learn something too.&lt;br /&gt;&lt;br /&gt;Either view the documentation on godoc.org:&lt;br /&gt;&lt;br /&gt;&lt;a href=&#34;https://godoc.org/github.com/natefinch/godocgo&#34;&gt;https://godoc.org/github.com/natefinch/godocgo&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;or view it locally using the godoc tool:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&#34;background-color: whitesmoke; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px; border-top-left-radius: 4px; border-top-right-radius: 4px; border: 1px solid rgb(204, 204, 204); box-sizing: border-box; color: #333333; font-family: Monaco, Menlo, Consolas, &#39;Courier New&#39;, monospace; font-size: 13px; line-height: 1.428571429; margin-bottom: 10px; overflow: auto; padding: 9.5px; word-break: normal; word-wrap: normal;&#34;&gt;go get code.google.com/p/go.tools/cmd/godoc&lt;br /&gt;go get github.com/natefinch/godocgo&lt;br /&gt;godoc -http=:8080&lt;/pre&gt;&lt;br /&gt;Then open a browser to &lt;a href=&#34;http://localhost:8080/pkg/github.com/natefinch/godocgo&#34;&gt;http://localhost:8080/pkg/github.com/natefinch/godocgo&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;Enjoy!&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Unused Variables in Go</title>
      <link>http://npf.io/2014/03/unused-variables-in-go/</link>
      <pubDate>Fri, 28 Mar 2014 16:13:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/03/unused-variables-in-go/</guid>
      <description>&lt;p&gt;The Go compiler treats unused variables as a compilation error. This causes much annoyance to some newbie Gophers, especially those used to writing languages that aren&amp;rsquo;t compiled, and want to be able to be fast and loose with their code while doing exploratory hacking.&lt;br /&gt;&lt;br /&gt;The thing is, an unused variable is often a bug in your code, so pointing it out early can save you a lot of heartache.&lt;br /&gt;&lt;br /&gt;Here&amp;rsquo;s an example:&lt;br /&gt;&lt;br /&gt;&lt;blockquote class=&#34;tr_bq&#34;&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;50 func Connect(name, port string) error {&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br /&gt;51 &amp;nbsp; &amp;nbsp;hostport := &amp;ldquo;&amp;rdquo;&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br /&gt;52 &amp;nbsp; &amp;nbsp;if port == &amp;ldquo;&amp;rdquo; {&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br /&gt;53 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;hostport := makeHost(name)&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br /&gt;54 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;logger.Infof(&amp;ldquo;No port specified, connecting on port 8080.&amp;rdquo;)&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br /&gt;55 &amp;nbsp; &amp;nbsp;} else {&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br /&gt;56 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;hostport := makeHostPort(name, port)&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br /&gt;57 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;logger.Infof(&amp;ldquo;Connecting on port %s.&amp;rdquo;, port)&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br /&gt;58 &amp;nbsp; &amp;nbsp;}&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br /&gt;59 &amp;nbsp; &amp;nbsp;// &amp;hellip; use hostport down here&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br /&gt;60 }&lt;/span&gt;&lt;/blockquote&gt;&lt;br /&gt;Where&amp;rsquo;s the bug in the above? &amp;nbsp;Without the compiler error, you&amp;rsquo;d run the code and have to figure out why hostport was always an empty string. &amp;nbsp;Did we pass in empty strings by accident? &amp;nbsp;Is there a bug in makeHost and makeHostPort?&lt;br /&gt;&lt;br /&gt;With the compiler error, it will say &amp;ldquo;53, hostport declared and not used&amp;rdquo; and &amp;ldquo;56, hostport declared and not used&amp;rdquo;&lt;br /&gt;&lt;br /&gt;This makes it a lot more obvious what the problem is&amp;hellip; inside the scope of the if statement, := declares new variables called hostport. &amp;nbsp;These hide the variable from the outer scope, thus, the outer hostport never gets modified, which is what gets used further on in the function.&lt;br /&gt;&lt;blockquote class=&#34;tr_bq&#34;&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br class=&#34;Apple-interchange-newline&#34; /&gt;50 func Connect(name, port string) error {&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br /&gt;51 &amp;nbsp; &amp;nbsp;hostport := &amp;ldquo;&amp;rdquo;&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br /&gt;52 &amp;nbsp; &amp;nbsp;if port == &amp;ldquo;&amp;rdquo; {&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br /&gt;53 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;hostport = makeHost(name)&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br /&gt;54 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;logger.Infof(&amp;ldquo;No port specified, connecting on port 8080.&amp;rdquo;)&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br /&gt;55 &amp;nbsp; &amp;nbsp;} else {&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br /&gt;56 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;hostport = makeHostPort(name, port)&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br /&gt;57 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;logger.Infof(&amp;ldquo;Connecting on port %s.&amp;rdquo;, port)&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br /&gt;58 &amp;nbsp; &amp;nbsp;}&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br /&gt;59 &amp;nbsp; &amp;nbsp;// &amp;hellip; use hostport down here&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br /&gt;60 }&lt;/span&gt;&lt;/blockquote&gt;&lt;div&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/div&gt;The above is the corrected code. It took only a few seconds to fix, thanks to the unused variable error from the compiler. &amp;nbsp;If you&amp;rsquo;d been testing this by running it or even with unit tests&amp;hellip; you&amp;rsquo;d probably end up spending a non-trivial amount of time trying to figure it out. &amp;nbsp;And this is just a very simple example. &amp;nbsp;This kind of problem can be a lot more elaborate and hard to find.&lt;br /&gt;&lt;br /&gt;And that&amp;rsquo;s why the unused variable declaration error is actually a good thing. &amp;nbsp;If a value is important enough to be assigned to a variable, it&amp;rsquo;s probably a bug if you&amp;rsquo;re not actually using that variable.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Bonus tip:&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;Note that if you don&amp;rsquo;t care about the variable, you can just assign it to the empty identifier directly:&lt;br /&gt;&lt;blockquote class=&#34;tr_bq&#34;&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;em&gt;, err := computeMyVar()&lt;/span&gt;&lt;/blockquote&gt;This is the normal way to avoid the compiler error in cases where a function returns more than you need.&lt;br /&gt;&lt;br /&gt;If you &lt;i&gt;really&lt;/i&gt; want to silence the unused variable error and not remove the variable for some reason, this is the way to do it:&lt;br /&gt;&lt;blockquote class=&#34;tr_bq&#34;&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;v, err := computeMyVar()&lt;/span&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;&lt;br /&gt;&lt;/em&gt; = v &amp;nbsp;// this counts as using the variable&lt;/span&gt;&lt;/blockquote&gt;Just don&amp;rsquo;t forget to clean it up before committing.&lt;br /&gt;&lt;br /&gt;All of the above also goes for unused packages. &amp;nbsp;And a similar tip for silencing that error:&lt;br /&gt;&lt;blockquote class=&#34;tr_bq&#34;&gt;&lt;span style=&#34;font-family: Courier New, Courier, monospace; TRACE&#34;&gt;_ = fmt.Printf // this counts as using the package&lt;/span&gt;&lt;/blockquote&gt;&lt;/p&gt;
</description>
    </item>
    
    
  </channel>
</rss>