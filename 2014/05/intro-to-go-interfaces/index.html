<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  


  <title> Intro&#43;&#43; to Go Interfaces  &middot; npf.io </title>

  
  <link rel="stylesheet" href="http://npf.io/css/poole.css">
  <link rel="stylesheet" href="http://npf.io/css/syntax.css">
  <link rel="stylesheet" href="http://npf.io/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.ico">

  
  <link href="" rel="alternate" type="application/rss+xml" title="npf.io" />

  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">

  <link href='http://fonts.googleapis.com/css?family=Raleway:400,300' rel='stylesheet' type='text/css'>

  <script src="//ajax.googleapis.com/ajax/libs/webfont/1.4.7/webfont.js"></script>
  <script>
    WebFont.load({
      google: {
        families: ['Raleway']
      }
    });
  </script>

</head>

<body>

  <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1 class="brand"><a href="/">npf.io</a></h1>
      <p class="lead">
       code by Nate Finch 
      </p>
    </div>



    <ul class="sidebar-nav">
      <li><a href="/blog">Posts</a></li>
      
        <li><a href="http://npf.io/about">About </a></li>
      
      <br/>
      
      <li>Code:</li>
        
          <li><a href="http://npf.io/lumberjack.v2/">Lumberjack </a></li>
        
          <li><a href="http://npf.io/npipe.v2/">npipe </a></li>
        
      
    </ul>
      <a href="https://twitter.com/natethefinch"><i class="fa fa-twitter-square"></i></a>&nbsp;&nbsp;
      
      
      <a href="https://github.com/natefinch"><i class="fa fa-github-square"></i></a>&nbsp;&nbsp;
      <a href="https://plus.google.com/&#43;NateFinch"><i class="fa fa-google-plus"></i></a>

    <p class="footnote">powered by <a href="http://hugo.spf13.com">Hugo</a> <br/>
    &copy; 2014 Nate Finch. All rights reserved.</p>
    
  </div>
</div>


  <div class="content container">
    <div class="post">
    <h1 class="post-title">Intro&#43;&#43; to Go Interfaces</h1>
    <span class="post-date">May 13, 2014</span>
    
    <p><span style="font-size: large;"><b> Standard Interface Intro</b></span><br /><br />Go&rsquo;s interfaces are one of it&rsquo;s best features, but they&rsquo;re also one of the most confusing for newbies. &nbsp;This post will try to give you the understanding you need to use Go&rsquo;s interfaces and not get frustrated when things don&rsquo;t work the way you expect. &nbsp;It&rsquo;s a little long, but a bunch of that is just code examples.<br /><br />Go&rsquo;s interfaces are different than interfaces in other languages, they are <i>implicitly</i>&nbsp;fulfilled. &nbsp;This means that you never need to mark your type as explicitly implementing the interface (like class CFoo implements IFoo). &nbsp;Instead, your type just needs to have the methods defined in the interface, and the compiler does the rest.<br /><br />For example:<br /><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">type Walker interface {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; Walk(miles int)</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span> <span style="font-family: Courier New, Courier, monospace; font-size: x-small;">type Camel struct {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; Name string</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span> <span style="font-family: Courier New, Courier, monospace; font-size: x-small;">func (c Camel) Walk(miles int) {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp;fmt.Printf(&ldquo;%s is walking %v miles\n&rdquo;, c.Name, miles)</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span> <span style="font-family: Courier New, Courier, monospace; font-size: x-small;">func LongWalk(w Walker) {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp;w.Walk(500)</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp;w.Walk(500)</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span> <span style="font-family: Courier New, Courier, monospace; font-size: x-small;">func main() {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; c := Camel{&ldquo;Bill&rdquo;}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; LongWalk&copy;</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span> <span style="font-family: Courier New, Courier, monospace; font-size: x-small;">// prints</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">// Bill is walking 500 miles.</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">// Bill is walking 500 miles.</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><a href="http://play.golang.org/p/erodX-JplO" target="_blank"> <a href="http://play.golang.org/p/erodX-JplO">http://play.golang.org/p/erodX-JplO</a></a><br /><br />Camel implements the Walker interface, because it has a method named Walk that takes an int and doesn&rsquo;t return anything. &nbsp;This means you can pass it into the LongWalk function, even though you never specified that your Camel is a Walker. &nbsp;In fact, Camel and Walker can live in totally different packages and never know about one another, and this will still work if a third package decides to make a Camel and pass it into LongWalk.<br /><br /><span style="font-size: large;"><b> Non-Standard Continuation</b></span><br /><br />This is where most tutorials stop, and where most questions and problems begin. &nbsp;The problem is that you still don&rsquo;t know how the interfaces actually <em>work</em>, and since it&rsquo;s not actually that complicated, let&rsquo;s talk about that.<br /><br /><b> What <i>actually</i> happens when you pass Camel into LongWalk?</b><br /><div><br />So, first off, you&rsquo;re not passing Camel into LongWalk. &nbsp;You&rsquo;re actually assigning c, a value of type Camel to a value w of type Walker, and w is what you operate on in LongWalk.</div><div><br /></div><div>Under the covers, the Walker interface (like all interfaces), would look more or less like this if it were in Go (the <a href="http://golang.org/src/pkg/runtime/iface.c" target="_blank">actual code</a> is in C, so this is just a really rough approximation that is easier to read).</div><div><br /></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">type Walker struct {</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; type <em>InterfaceType</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; data *void</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">type InterfaceType struct {</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; valtype *gotype</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; func0 *func</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; func1 *func</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &hellip;</span></div><div><span style="font-family: 'Courier New', Courier, monospace; font-size: x-small;">}</span></div><div><br /></div><div>All interfaces values are just two pointers - one pointer to information about the interface type, and one pointer to the data from the value you passed into the interface (a void</em> in C-like languages&hellip; this should probably be Go&rsquo;s unsafe.Pointer, but I liked the explicitness of two actual *&rsquo;s in the struct to show it&rsquo;s just two pointers).</div><div><br /></div><div>The InterfaceType contains a pointer to information about the type of the value that you passed into the interface (valtype). &nbsp;It also contains pointers to the methods that are available on the interface.&nbsp;</div><div><br /></div><div>When you assign c to w, the compiler generates instructions that looks more or less like this (it&rsquo;s not actually generating Go, this is just an easier-to-read approximation):</div><div><br /></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">data := c</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">w := Walker{&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; type: &amp;InterfaceType{&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valtype: &amp;typeof&copy;,&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; func0: &amp;Camel.Walk&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; data: &amp;data</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span></div><div><br /></div><div>When you assign your Camel value c to the Walker value w, the Camel type is copied into the interface value&rsquo;s Type.valtype field. &nbsp;The actual data in the value of c is copied into a new place in memory, and w&rsquo;s Data field points at that memory location.<br /><br /></div><b> Implications of the Implementation</b><br /><div><br />Now, let&rsquo;s look at the implications of this code. &nbsp;First, interface values are very small - just two pointers. &nbsp;When you assign a value to an interface, that value gets copied once, into the interface, but after that, it&rsquo;s held in a pointer, so it doesn&rsquo;t get copied again if you pass the interface around.</div><div><br /></div><div>So now you know why you don&rsquo;t need to pass around pointers to interfaces - they&rsquo;re small anyway, so you don&rsquo;t have to worry about copying the memory, plus they hold your data in a pointer, so changes to the data will travel with the interface.<br /><br /></div><b><span style="font-size: large;" id="Types">Interfaces Are Types</span></b><br /><div><br />Let&rsquo;s look at Walker again, this is important:</div><div><div><br /></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><b>type</b>&nbsp;Walker interface</span></div><div><br /></div><div>Note that first word there: type. &nbsp;Interfaces are types, just like string is a type or Camel is a type. &nbsp;They aren&rsquo;t aliases, they&rsquo;re not magic hand-waving, they&rsquo;re real types and real values which are distinct from the type and value that gets assigned to them.</div></div><div><br /></div>Now, let&rsquo;s assume you have this function:<br /><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">func LongWalkAll(walkers []Walker) {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; for _, w := range walkers {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; LongWalk(w)</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; }</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><br />And let&rsquo;s say you have a caravan of Camels that you want to send on a long walk:<br /><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">caravan := []Camel{ Camel{&ldquo;Bill&rdquo;}, Camel{&ldquo;Bob&rdquo;}, Camel{&ldquo;Steve&rdquo;}}</span><br /><br />You want to pass caravan into LongWalkAll, will the compiler let you? &nbsp;Nope. &nbsp;Why is that? &nbsp;Well, []Walker is a specific type, it&rsquo;s a slice of values of type Walker. &nbsp;It&rsquo;s not shorthand for &ldquo;a slice of anything that matches the Walker interface&rdquo;. &nbsp;It&rsquo;s an actual distinct type, the way []string is different from []int. &nbsp;The Go compiler will output code to assign a single value of Camel to a single value of Walker. &nbsp;That&rsquo;s the only place it&rsquo;ll help you out. &nbsp;So, with slices, you have to do it yourself:<br /><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">walkers := make([]Walker, len(caravan))</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">for n, c := range caravan {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; walkers[n] = c</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">LongWalkAll(walkers)</span><br /><br />However, there&rsquo;s a better way if you know you&rsquo;ll just need the caravan for passing into LongWalkAll:<br /><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">caravan := []Walker{&nbsp;Camel</span><span style="font-family: 'Courier New', Courier, monospace; font-size: x-small;">{&ldquo;Bill&rdquo;}, Camel{&ldquo;Bob&rdquo;}, Camel{&ldquo;Steve&rdquo;}}</span><br /><div><span style="font-family: 'Courier New', Courier, monospace; font-size: x-small;">LongWalkAll(caravan)</span><br /><span style="font-family: 'Courier New', Courier, monospace; font-size: x-small;"><br /></span> <br /><span style="font-family: inherit;">Note that this goes for any type which includes an interface as part of its definition: there&rsquo;s no automatic conversion of your func(Camel) into func(Walker) or map[string]Camel into map[string]Walker. &nbsp;Again, they&rsquo;re totally different types, they&rsquo;re not shorthand, and they&rsquo;re not aliases, and they&rsquo;re not just a pattern for the compiler to match.</span><br /><span style="font-family: inherit;"><br /></span><b><span style="font-size: large;"> Interfaces and the Pointers That Satisfy Them</span></b></div><div><br />What if Camel&rsquo;s Walk method had this signature instead?</div><div><br /></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">func (c *Camel) Walk(miles int)</span></div><div><br /></div><div>This line says that the type *Camel has a function called Walk. &nbsp;This is important: *Camel is a type. &nbsp;It&rsquo;s the &ldquo;pointer to a Camel&rdquo; type. &nbsp;It&rsquo;s a distinct type from (non-pointer) Camel. &nbsp;The part about it being a pointer is <i>part of its type</i>. &nbsp;The Walk method is on the type *Camel. &nbsp;The Walk method (in this new incarnation) <i>is not on the type Camel</i>. This becomes important when you try to assign it to an interface.</div><div><br /></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">c := Camel{&ldquo;Bill&rdquo;}</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">LongWalk&copy;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">// compiler output:</span></div><div><pre><span class="stderr"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">cannot use c (type Camel) as type Walker in function argument:<br /> Camel does not implement Walker (Walk method has pointer receiver)</span></span></pre><pre><span class="stderr"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></span></pre><div>To pass a Camel into LongWalk now, you need to pass in a pointer to a Camel:<br /><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">c := &amp;Camel{&ldquo;Bill&rdquo;}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">LongWalk&copy;</span><br /><br />or<br /><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">c := Camel{&ldquo;Bill&rdquo;}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">LongWalk(&amp;c)</span><br /><br />Note that this true even though you can still call Walk directly on Camel:<br /><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">c := Camel{&ldquo;Bill&rdquo;}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">c.Walk(500) // this works</span><br /><br />The reason you can do that is that the Go compiler automatically converts this line to (&amp;c).Walk(500) for you. &nbsp;However, that doesn&rsquo;t work for passing the value into an interface. &nbsp;The reason is that the value in an interface is in a hidden memory location, and so the compiler can&rsquo;t automatically get a pointer to that memory for you (in Go parlance, this is known as being &ldquo;not addressable&rdquo;).<br /><br /><b><span style="font-size: large;" id="NilPointers">Nil Pointers and Nil Interfaces</span></b></div></div><div><br />The interaction between nil interfaces and nil pointers is where nearly everyone gets tripped up when they first start with Go.</div><div><br /></div><div>Let&rsquo;s say we have our Camel type with the Walk method defined on *Camel as above, and we want to make a function that returns a Walker that is actually a Camel (note that you don&rsquo;t need a function to do this, you can just assign a *Camel to a Walker, but the function is a good illustrative example):</div><div><br /></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">func MakeWalker() Walker {</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; return &amp;Camel{&ldquo;Bill&rdquo;}</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">w := MakeWalker()</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">if w != nil {</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; w.Walk(500) &nbsp;// we will hit this</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span></div><div><br /></div><div>This works fine. &nbsp;But now, what if we do something a little different:</div><div><br /></div><div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">func MakeWalker(c *Camel) Walker {</span></div><div><span style="font-family: 'Courier New', Courier, monospace; font-size: x-small;">&nbsp; &nbsp; return c</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">var c *Camel</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">w := MakeWalker&copy;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">if w != nil {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; // we&rsquo;ll get in here, but why?</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; w.Walk(500)</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span></div></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></div><div>This code will <i>also</i>&nbsp;get inside the if statement (and then panic, which we&rsquo;ll talk about in a bit)&nbsp;because the returned Walker value is not nil. &nbsp;How is that possible, if we returned a nil pointer? &nbsp;Well, let&rsquo;s go look back to the instructions that get generated when we assign a value to an interface. &nbsp;</div><div><br /></div><div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">data := c</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">w := Walker{&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; type: &amp;InterfaceType{&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valtype: &amp;typeof&copy;,&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; func0: &amp;Camel.Walk&nbsp;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; data: &amp;data</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><br /><span style="font-family: inherit;">In this case, c is a nil pointer. However, that&rsquo;s a perfectly valid value to assign to the Walker&rsquo;s Data value, so it works just fine. &nbsp;What you return is a non-nil Walker value, that has a pointer to a nil *Camel as its data. &nbsp;So, of course, if you check w == nil, the answer is false, w is not nil&hellip; but then inside the if statement, we try to call Camel&rsquo;s walk:</span><br /><span style="font-family: inherit;"><br /></span> <span style="font-family: Courier New, Courier, monospace; font-size: x-small;">func (c *Camel) Walk(miles int) {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp;fmt.Printf(&ldquo;%s is walking %v miles\n&rdquo;, c.Name, miles)</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span><span style="font-family: inherit;">And when we try to do c.Name, Go automatically turns that into (*c).Name, and the code panics with a nil pointer dereference error.</span><br /><span style="font-family: inherit;"><br /></span> <span style="font-family: inherit;">Hopefully this makes sense, given our new understanding of how interfaces wrap values, but then how do you account for nil pointers? &nbsp;Assume you want MakeWalker to return a nil interface if it gets passed a nil Camel. &nbsp;You have to explicitly assign nil to the interface:</span><br /><span style="font-family: inherit;"><br /></span> <br /><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">func MakeWalker(c *Camel) Walker {</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; if c == nil {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; return nil</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; }</span></div><div><span style="font-family: 'Courier New', Courier, monospace; font-size: x-small;">&nbsp; &nbsp; return c</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span> <span style="font-family: Courier New, Courier, monospace; font-size: x-small;">var c *Camel</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">w := MakeWalker&copy;</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">if w != nil {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; // Yay, we don&rsquo;t get here!</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; w.Walk(500)</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span> <span style="font-family: inherit;">And now, finally, the code is doing what we expect. &nbsp;When you pass in a nil *Camel, we return a nil interface. &nbsp;Here&rsquo;s an alternate way to write the function:</span><br /><span style="font-family: inherit;"><br /></span> <br /><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">func MakeWalker(c *Camel) Walker {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; var w Walker</span></div><div><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; if c != nil {</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; &nbsp; &nbsp; w = c</span><br /><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; }</span></div><div><span style="font-family: 'Courier New', Courier, monospace; font-size: x-small;">&nbsp; &nbsp; return w</span></div><div style="orphans: auto; text-align: start; text-indent: 0px; widows: auto;"><div style="-webkit-text-stroke-width: 0px; color: black; font-family: 'Abyssinica SIL'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-family: 'Abyssinica SIL'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;"><br /></span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: inherit;">This is slightly less optimal, but it shows the other way to get a nil interface, which is to use the zero value for the interface, which is nil.</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: inherit;"><br /></span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: inherit;">Note that you <i>can</i>&nbsp;have a nil pointer value that satisfies an interface. &nbsp;You just need to be careful not to dereference the pointer in your methods. &nbsp;For example, if *Camel&rsquo;s Walk method looked like this:</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: inherit;"><br /></span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">func (c *Camel) Walk(miles int) {</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; &nbsp; fmt.Printf(&ldquo;I&rsquo;m walking %d miles!&rdquo;, miles)</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">}</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><br /></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;">Note that this method does not dereference c, and therefore you can call it even if c is nil:</div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><br /></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">var c *Camel</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">c.Walk(500)</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">// prints &ldquo;I&rsquo;m walking 500 miles!&rdquo;</span></div><div style="-webkit-text-stroke-width: 0px; color: black; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><br /></div><div style="margin: 0px;"><a href="http://play.golang.org/p/4EfyV21at9">http://play.golang.org/p/4EfyV21at9</a></div><div style="margin: 0px;"><br /></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><b><span style="font-size: large;"> Outro</span></b></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><br /></div><div style="-webkit-text-stroke-width: 0px; color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; margin: 0px; text-transform: none; white-space: normal; word-spacing: 0px;">I hope this article helps you better understand how interfaces works, and helps you avoid some of the common pitfalls and misconceptions newbies have about how interfaces work. &nbsp;If you want more information about the internals of interfaces and some of the optimizations that I didn&rsquo;t cover here, read&nbsp;<a href="http://research.swtch.com/interfaces" target="_blank">Russ Cox&rsquo;s article</a> on Go interfaces, I highly recommend it.</div></div></div></div></div></p>

    
     
	
    <div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost") 
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'npfio';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the comments powered by <a href="http://disqus.com/?ref_noscript">Disqus.</a></noscript>
</div>
</div> 

</body>w
</html>
