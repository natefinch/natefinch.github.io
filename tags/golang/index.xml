<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>npf.io</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>https://npf.io/tags/golang/index.xml</link>
    <language>en-us</language>
    <author>Nate Finch</author>
    <copyright>0001 Nate Finch</copyright>
    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
    
    
    <item>
      <title>Vanity Imports with Hugo</title>
      <link>https://npf.io/2016/10/vanity-imports-with-hugo/</link>
      <pubDate>Wed, 26 Oct 2016 00:01:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>https://npf.io/2016/10/vanity-imports-with-hugo/</guid>
      <description>&lt;p&gt;When working on &lt;a href=&#34;https://github.com/natefinch/gorram&#34;&gt;Gorram&lt;/a&gt;, I decided I
wanted to release it via a vanity import path.  After all, that&amp;rsquo;s half the
reason I got npf.io in the first place (an idea blatantly stolen from Russ Cox&amp;rsquo;s
rsc.io).&lt;/p&gt;

&lt;p&gt;What is a vanity import path?  It is explained in the go get
&lt;a href=&#34;https://golang.org/cmd/go/#hdr-Remote_import_paths, though it
isn&#39;t given that name (or any name, unfortunately&#34;&gt;documentation&lt;/a&gt;.  If you&amp;rsquo;re not hosted on one
of the well known hosting sites (github, bitbucket, etc), go get has to figure
out how to get your code. How it does this is fairly ingenious - it performs an
http GET of the import path (first https then http) and looks for specific meta
elements in the page&amp;rsquo;s header.  The header elements tells go get what type of
VCS is being used and what address to use to get the code.&lt;/p&gt;

&lt;p&gt;The great thing about this is that it removes the dependency of your code on any
one code hosting site. If you want to move your code from github to bitbucket,
you can do that without breaking anyone.&lt;/p&gt;

&lt;p&gt;So, the first thing you need to host your own vanity imports is something that
will respond to those GET requests with the right response.  You could do
something complicated like a special web application running on a VM in the
cloud, but that costs money and needs maintenance.  Since I already had a Hugo
website (running for free on github pages), I wanted to see if I could use that.
It&amp;rsquo;s a slightly more manual process, but the barrier of entry is a lot lower and
it works on any free static hosting (like github pages).&lt;/p&gt;

&lt;p&gt;So what I want is to have &lt;code&gt;go get npf.io/gorram&lt;/code&gt;, actually download the code
from &lt;a href=&#34;https://github.com/natefinch/gorram&#34;&gt;https://github.com/natefinch/gorram&lt;/a&gt;.  For that, I need
&lt;a href=&#34;https://npf.io/gorram&#34;&gt;https://npf.io/gorram&lt;/a&gt; to serve up this meta element:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;go-import&amp;quot; content=&amp;quot;npf.io/gorram git https://github.com/natefinch/gorram&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;or more generally:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;go-import&amp;quot; content=&amp;quot;import-prefix vcs repo-root&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Where import-prefix is a string that matches a prefix of the import statement
used in your code, vcs is the type of source control used, and repo-root is the
root of the VCS repo where your code lives.&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s important to note here is that these should be set this way for packages
in subdirectories as well.  So, for npf.io/gorram/run, the meta tag should still
be as above, since it matches a prefix of the import path, and the root of the
repo is still github.com/natefinch/gorram.  (We&amp;rsquo;ll get to how to handle
subdirectories later.)&lt;/p&gt;

&lt;p&gt;You need a page serving that meta tag to live at the exact same place as the import
statement&amp;hellip; that generally will mean it needs to be in the root of your domain
(I know that I, personally don&amp;rsquo;t want to see &lt;code&gt;go get npf.io/code/gorram&lt;/code&gt; when I
could have &lt;code&gt;go get npf.io/gorram&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;The easiest way to do this and keep your code organized is to put all your pages
for code into a new directory under content called &amp;ldquo;code&amp;rdquo;.  Then you just need
to set the &amp;ldquo;permalink&amp;rdquo; for the code type in your site&amp;rsquo;s config file thusly:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;[Permalinks]
	code = &amp;quot;/:filename/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then your content&amp;rsquo;s filename (minus extension) will be used as its url relative
to your site&amp;rsquo;s base URL. Following the same example as above, I have
content/code/gorram.md which will make that page now appear at npf.io/gorram.&lt;/p&gt;

&lt;p&gt;Now, for the content.  I don&amp;rsquo;t actually want to have to populate this page with
content&amp;hellip; I&amp;rsquo;d rather people just get forwarded on to github, so that&amp;rsquo;s what
we&amp;rsquo;ll do, by using a refresh header.  So here&amp;rsquo;s our template, that&amp;rsquo;ll live under layouts/code/single.html:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta http-equiv=&amp;quot;content-type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;&amp;gt;
  &amp;lt;meta name=&amp;quot;go-import&amp;quot; content=&amp;quot;npf.io{{substr .RelPermalink 0 -1}} git {{.Params.vanity}}&amp;quot;&amp;gt;
  &amp;lt;meta name=&amp;quot;go-source&amp;quot; content=&amp;quot;npf.io{{substr .RelPermalink 0 -1}} {{.Params.vanity}} {{.Params.vanity}}/tree/master{/dir} {{.Params.vanity}}/blob/master{/dir}/{file}#L{line}&amp;quot;&amp;gt;
  &amp;lt;meta http-equiv=&amp;quot;refresh&amp;quot; content=&amp;quot;0; url={{.Params.vanity}}&amp;quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will generate a page that will auto-forward anyone who hits it on to your
github account.  Now, there&amp;rsquo;s one more (optional but recommended) piece - the
go-source meta header.  This is only relevant to godoc.org, and tells godoc how
to link to the sourcecode for your package (so links on godoc.org will go
straight to github and not back to your vanity url, see more details &lt;a href=&#34;https://github.com/golang/gddo/wiki/Source-Code-Links&#34;&gt;here&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Now all you need is to put a value of &lt;code&gt;vanity = https://github.com/you/yourrepo&lt;/code&gt;
in the frontmatter of the correct page, and the template does the rest. If your
repo has multiple directories, you&amp;rsquo;ll need a page for each directory (such as
npf.io/gorram/run).  This would be kind of a drag, making the whole directory
struture with content docs in each, except there&amp;rsquo;s a trick you can do here to
make that easier.&lt;/p&gt;

&lt;p&gt;I recently landed a change in Hugo that lets you customize the rendering of
alias pages.  Alias pages are pages that are mainly used to redirect people from
an old URL to the new URL of the same content.  But in our case, they can serve
up the go-import and go-source meta headers for subdirectories of the main code
document.  To do this, make an alias.html template in the root of your layouts
directory, and make it look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        {{if .Page.Params.vanity -}}
        &amp;lt;meta name=&amp;quot;go-import&amp;quot; content=&amp;quot;npf.io{{substr .Page.RelPermalink 0 -1}} git {{.Page.Params.vanity}}&amp;quot;&amp;gt;
        &amp;lt;meta name=&amp;quot;go-source&amp;quot; content=&amp;quot;npf.io{{substr .Page.RelPermalink 0 -1}} {{.Page.Params.vanity}} {{.Page.Params.vanity}}/tree/master{/dir} {{.Page.Params.vanity}}/blob/master{/dir}/{file}#L{line}&amp;quot;&amp;gt;
        {{- end}}
        &amp;lt;title&amp;gt;{{ .Permalink }}&amp;lt;/title&amp;gt;
        &amp;lt;link rel=&amp;quot;canonical&amp;quot; href=&amp;quot;{{ .Permalink }}&amp;quot;/&amp;gt;
        &amp;lt;meta http-equiv=&amp;quot;content-type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot; /&amp;gt;
        &amp;lt;meta http-equiv=&amp;quot;refresh&amp;quot; content=&amp;quot;0; url={{ .Permalink }}&amp;quot; /&amp;gt;
    &amp;lt;/head&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Other than the stuff in the if statement, the rest is the default alias page
that Hugo creates anyway.  The stuff in the if statement is basically the same
as what&amp;rsquo;s in the code template, just with an extra indirection of specifying
.Page first.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note that this change to Hugo is in master but not in a release yet.  It&amp;rsquo;ll be
in 0.18, but for now you&amp;rsquo;ll have to build master to get it.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Now, to produce pages for subpackages, you can just specify aliases in the front
matter of the original document with the alias being the import path under the
domain name:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;aliases = [ &amp;quot;gorram/run&amp;quot;, &amp;quot;gorram/cli&amp;quot; ]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So your entire content only needs to look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
date = 2016-10-02T23:00:00Z
title = &amp;quot;Gorram&amp;quot;
vanity = &amp;quot;https://github.com/natefinch/gorram&amp;quot;
aliases = [
    &amp;quot;/gorram/run&amp;quot;,
    &amp;quot;/gorram/cli&amp;quot;,
]
+++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Any time you add a new subdirectory to the package, you&amp;rsquo;ll need to add a new
alias, and regenerate the site.  This is unfortunately manual, but at least it&amp;rsquo;s
a trivial amount of work.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it. Now go get (and godoc.org) will know how to get your code.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>To Enum or Not To Enum</title>
      <link>https://npf.io/2015/12/enums/</link>
      <pubDate>Wed, 02 Dec 2015 00:00:19 -0400</pubDate>
      <author>Nate Finch</author>
      <guid>https://npf.io/2015/12/enums/</guid>
      <description>&lt;p&gt;Enum-like values have come up in my reviews of other people&amp;rsquo;s code a few times, and I&amp;rsquo;d like to nail down what we feel is best practice.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve seen many places what in other languages would be an enum, i.e. a bounded list of known values that encompass every value that should ever exist.&lt;/p&gt;

&lt;p&gt;The code I have been critical of simply calls these values strings, and creates a few well-known values, thusly:
package tool&lt;/p&gt;

&lt;p&gt;// types of tools
const (
    ScrewdriverType = &amp;ldquo;screwdriver&amp;rdquo;
    HammerType = &amp;ldquo;hammer&amp;rdquo;
   // &amp;hellip;
)&lt;/p&gt;

&lt;p&gt;type Tool struct {
    typ string
}&lt;/p&gt;

&lt;p&gt;func NewTool(tooltype string) (Tool, error) {
    switch tooltype{
        case ScrewdriverType, HammerType:
            return Tool{typ:tooltype}, nil
        default:
            return Tool{}, errors.New(&amp;ldquo;invalid type&amp;rdquo;)
    }
}
The problem with this is that there&amp;rsquo;s nothing stopping you from doing something totally wrong like this:
name := user.Name()&lt;/p&gt;

&lt;p&gt;// &amp;hellip; some other stuff&lt;/p&gt;

&lt;p&gt;a := NewTool(name)
That would fail only at runtime, which kind of defeats the purpose of having a compiler.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m not sure why we don&amp;rsquo;t at least define the tool type as a named type of string, i.e.
package tool&lt;/p&gt;

&lt;p&gt;type ToolType string&lt;/p&gt;

&lt;p&gt;const (
    Screwdriver ToolType = &amp;ldquo;screwdriver&amp;rdquo;
    Hammer = &amp;ldquo;hammer&amp;rdquo;
   // &amp;hellip;
)&lt;/p&gt;

&lt;p&gt;type Tool struct {
    typ ToolType
}&lt;/p&gt;

&lt;p&gt;func NewTool(tooltype ToolType) Tool {
        return Tool{typ:tooltype}
}
Note that now we can drop the error checking in NewTool because the compiler does it for us.  The ToolType still works in all ways like a string, so it&amp;rsquo;s trivial to convert for printing, serialization, etc.&lt;/p&gt;

&lt;p&gt;However, this still lets you do something which is wrong but might not always look wrong:
a := NewTool(&amp;ldquo;drill&amp;rdquo;)
Because of how Go constants work, this will get converted to a ToolType, even though it&amp;rsquo;s not one of the ones we have defined.&lt;/p&gt;

&lt;p&gt;The final revision, which is the one I&amp;rsquo;d propose, removes even this possibility, by not using a string at all (it also uses a lot less memory and creates less garbage):
package tool&lt;/p&gt;

&lt;p&gt;type ToolType int&lt;/p&gt;

&lt;p&gt;const (
    Screwdriver ToolType = iota
    Hammer
   // &amp;hellip;
)&lt;/p&gt;

&lt;p&gt;type Tool struct {
    typ ToolType
}&lt;/p&gt;

&lt;p&gt;func NewTool(tooltype ToolType) Tool {
        return Tool{typ:tooltype}
}
This now prevents passing in a constant string that looks like it might be right. You can pass in a constant number, but NewTool(5) is a hell of a lot more obviously wrong than NewTool(&amp;ldquo;drill&amp;rdquo;), IMO.&lt;/p&gt;

&lt;p&gt;The push back I&amp;rsquo;ve heard about this is that then you have to manually write the String() function to make human-readable strings&amp;hellip; but there are code generators that already do this for you in extremely optimized ways (see &lt;a href=&#34;https://github.com/golang/tools/blob/master/cmd/stringer/stringer.go&#34;&gt;https://github.com/golang/tools/blob/master/cmd/stringer/stringer.go&lt;/a&gt;)&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Returning Errors</title>
      <link>https://npf.io/2015/10/errors/</link>
      <pubDate>Sat, 10 Oct 2015 00:00:19 EDT</pubDate>
      <author>Nate Finch</author>
      <guid>https://npf.io/2015/10/errors/</guid>
      <description>&lt;p&gt;There are basically two ways to return errors in Go:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (c Config) Save() error {
	if err := c.checkDefault(); err != nil {
		return err
	}
	...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (c Config) Save() error {
	if err := c.checkDefault(); err != nil {
		return fmt.Errorf(&amp;quot;can&#39;t find default config file: %v&amp;quot;, err)
	}
	...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The former passes the original error up the stack, but adds no context to it.
Thus, your saveConfig function may end up printing &amp;ldquo;file not found:
default.cfg&amp;rdquo; without telling the caller why it was trying to open default.cfg.&lt;/p&gt;

&lt;p&gt;The latter allows you to add context to an error, so the above error could
become &amp;ldquo;can&amp;rsquo;t find default config file: file not found: default.cfg&amp;rdquo;.
This gives nice context to the error, but unfortunately, it creates an entirely
new error that only maintains the error string from the original.  This is fine
for human-facing output, but is useless for error handling code.&lt;/p&gt;

&lt;p&gt;If you use the former code, calling code can then use &lt;code&gt;os.IsNotExist()&lt;/code&gt;, figure
out that it was a not found error, and create the file.  Using the latter code,
the type of the error is now a different type than the one from os.Open, and
thus will not return true from os.IsNotExist.  Using fmt.Errorf effectively
masks the original error from calling code (unless you do ugly string parsing -
please don&amp;rsquo;t).&lt;/p&gt;

&lt;p&gt;Sometimes it&amp;rsquo;s good to mask the original error, if you don&amp;rsquo;t want your callers
depending on what should be an implementation detail (thus effectively making it
part of your API contract). However, lots of times you may want to give your
callers the ability to introspect your errors and act on them. This then loses
the opportunity to add context to the error, and so people calling your code
have to do some mental gymnastics (and/or look at the implementation) to
understand what an error really means.&lt;/p&gt;

&lt;p&gt;A further problem for both these cases is that when debuging, you lose all
knowledge of where an error came from.  There&amp;rsquo;s no stack trace, there&amp;rsquo;s not even
a file and line number of where the error originated.  This can make debugging
errors fairly difficult, unless you&amp;rsquo;re careful to make your error messages easy
to grep for.  I can&amp;rsquo;t tell you how often I&amp;rsquo;ve searched for an error formatting
string, and hoped I was guessing the format correctly.&lt;/p&gt;

&lt;p&gt;This is just the way it is in Go, so what&amp;rsquo;s a developer to do?  Why, write an
errors library that does smarter things of course!  And there are a ton of these
things out there.  Many add a stack trace at error creation time.  Most wrap an
original error in some way, so you can add some context while keeping the
original error for checks like os.IsNotExist. At Canonical, the Juju team wrote
just such a library (actually we wrote 3 and then had them fight until only one
was standing), and the result is &lt;a href=&#34;https://github.com/juju/errors&#34;&gt;https://github.com/juju/errors&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Thus you might return an error this way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (c Config) Save() error {
	if err := c.checkDefault(); err != nil {
		return errors.Annotatef(err, &amp;quot;can&#39;t find default config file&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This returns a new error created by the errors package which adds the given
string to the front of the original error&amp;rsquo;s error message (just like
fmt.Errorf), but you can introspect it using &lt;code&gt;errors.Cause(err)&lt;/code&gt; to access the
original error return by checkDefault.  Thus you can use
&lt;code&gt;os.IsNotExist(errors.Cause(err))&lt;/code&gt; and it&amp;rsquo;ll do the right thing.&lt;/p&gt;

&lt;p&gt;However, this and every other special error library suffer from the same problem
- your library can only understand its own special errors.  And no one else&amp;rsquo;s
code can understand your errors (because they won&amp;rsquo;t know to use errors.Cause
before checking the error).  Now you&amp;rsquo;re back to square one - your errors are
just as opaque to third party code as if they were created by fmt.Errorf.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t really have an answer to this problem. It&amp;rsquo;s inherent in the
functionality (or lack thereof) of the standard Go error type.&lt;/p&gt;

&lt;p&gt;Obviously, if you&amp;rsquo;re writing a standalone package for many other people to use,
don&amp;rsquo;t use a third party error wrapping library.  Your callers are likely not
going to be using the same library, so they won&amp;rsquo;t get use out of it, and it adds
unnecessary dependencies to your code.  To decide between returning the original
error and an annotated error using fmt.Errorf is harder.  It&amp;rsquo;s hard to know when
the information in the original error might be useful to your caller.  On the
other hand, the additional context added by fmt.Errorf can often change an
inscrutable error into an obvious one.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re writing an application where you&amp;rsquo;ll be controlling most of the
packages being written, then an errors package may make sense&amp;hellip; but you still
run the risk of giving your custom errors to third party code that can&amp;rsquo;t
understand them.  Plus, any errors library adds some complexity to the code (for
example, you always have to rememeber to call &lt;code&gt;os.IsNotExist(errors.Cause(err))&lt;/code&gt;
rather than just calling &lt;code&gt;os.InNotExist(err)&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;You have to choose one of the three options every time you return an error.
Choose carefully.  Sometimes you&amp;rsquo;re going to make a choice that makes your life
more difficult down the road.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Take control of your commands with Deputy</title>
      <link>https://npf.io/2015/06/deputy/</link>
      <pubDate>Tue, 30 Jun 2015 12:44:29 EDT</pubDate>
      <author>Nate Finch</author>
      <guid>https://npf.io/2015/06/deputy/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/3185864/8237448/6bc30102-15bd-11e5-9e87-6423197a73d6.jpg&#34; alt=&#34;deputy-sm&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;&lt;sub&gt;image: creative commons, &amp;copy; &lt;a href=&#34;http://matsurd.deviantart.com/art/Paper53-Deputy-Stubbs-342123485&#34;&gt;MatsuRD&lt;/a&gt;&lt;/sub&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;As a part of my work on &lt;a href=&#34;https://github.com/juju/juju&#34;&gt;Juju&lt;/a&gt;, I have published a
new package at &lt;a href=&#34;http://github.com/juju/deputy&#34;&gt;http://github.com/juju/deputy&lt;/a&gt;.  I think it&amp;rsquo;ll be of general use
to a lot of people.&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;en&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;I want to name a package &amp;quot;lieutenant&amp;quot;, but it&amp;#39;s too hard to spell.&lt;/p&gt;&amp;mdash; Nate Finch (@NateTheFinch) &lt;a href=&#34;https://twitter.com/NateTheFinch/status/610481962311131136&#34;&gt;June 15, 2015&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;True story.  The idea was this package would be a lieutenant commander (get
it?)&amp;hellip; but I also knew I didn&amp;rsquo;t want to have to try to spell lieutenant
correctly every time I used the package.  So that&amp;rsquo;s why it&amp;rsquo;s called deputy.
He&amp;rsquo;s the guy who&amp;rsquo;s not in charge, but does all the work.&lt;/p&gt;

&lt;h3 id=&#34;errors&#34;&gt;Errors&lt;/h3&gt;

&lt;p&gt;At &lt;a href=&#34;https://github.com/juju/juju&#34;&gt;Juju&lt;/a&gt;, we run a lot of external processes
using os/exec. However, the default functionality of an exec.Cmd object is kind
of lacking. The most obvious one is those error returns &amp;ldquo;exit status 1&amp;rdquo;.
Fantastic.  Have you ever wished you could just have the stderr from the command
as the error text?  Well, now you can, with deputy.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    d := deputy.Deputy{
        Errors:    deputy.FromStderr,
    }
    cmd := exec.Command(&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot;)
    err := d.Run(cmd)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above code, if the command run by Deputy exits with a non-zero exit
status, deputy will capture the text output to stderr and convert that into the
error text.  &lt;em&gt;e.g.&lt;/em&gt; if the command returned exit status 1 and output &amp;ldquo;Error: No
such image or container: bar&amp;rdquo; to stderr, then the error&amp;rsquo;s Error() text would
look like &amp;ldquo;exit status 1: Error: No such image or container: bar&amp;rdquo;.  Bam, the
errors from commands you run are infinitely more useful.&lt;/p&gt;

&lt;h3 id=&#34;logging&#34;&gt;Logging&lt;/h3&gt;

&lt;p&gt;Another idiom we use is to pipe some of the output from a command to our logs. This can be super useful for debugging purposes.  With deputy, this is again easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    d := deputy.Deputy{
        Errors:    deputy.FromStderr,
        StdoutLog: func(b []byte) { log.Print(string(b)) },
    }
    cmd := exec.Command(&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot;)
    err := d.Run(cmd)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it.  Now every line written to stdout by the process will be piped as a
log message to your log.&lt;/p&gt;

&lt;h3 id=&#34;timeouts&#34;&gt;Timeouts&lt;/h3&gt;

&lt;p&gt;Finally, an idiom we don&amp;rsquo;t use often enough, but should, is to add a timeout to
command execution.  What happens if you run a command as part of your pipeline
and that command hangs for 30 seconds, or 30 minutes, or forever?  Do you just
assume it&amp;rsquo;ll always finish in a reasonable time?  Adding a timeout to running
commands requires some tricky coding with goroutines, channels, selects, and
killing the process&amp;hellip; and deputy wraps all that up for you in a simple API:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    d := deputy.Deputy{
        Errors:    deputy.FromStderr,
        StdoutLog: func(b []byte) { log.Print(string(b)) },
        Timeout:   time.Second * 10,
    }
    cmd := exec.Command(&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot;)
    err := d.Run(cmd)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code adds a 10 second timeout.  After that time, if the process has
not finished, it will be killed and an error returned.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it.  Give deputy a spin and let me know what you think.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Testing os/exec.Command</title>
      <link>https://npf.io/2015/06/testing-exec-command/</link>
      <pubDate>Fri, 26 Jun 2015 06:41:56 EDT</pubDate>
      <author>Nate Finch</author>
      <guid>https://npf.io/2015/06/testing-exec-command/</guid>
      <description>&lt;p&gt;In &lt;a href=&#34;https://github.com/juju/juju&#34;&gt;Juju&lt;/a&gt;, we often have code that needs to run external
executables.  Testing this code is a nightmare&amp;hellip; because you really don&amp;rsquo;t want
to run those files on the dev&amp;rsquo;s machine or the CI machine.  But mocking out
os/exec is really hard.  There&amp;rsquo;s no interface to replace, there&amp;rsquo;s no function to
mock out and replace.  In the end, your code calls the Run method on the
exec.Cmd struct.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a bunch of bad ways you can mock this out - you can write out scripts to
disk with the right name and structure their contents to write out the correct
data to stdout, stderr and return the right return code&amp;hellip; but then you&amp;rsquo;re
writing platform-specific code in your tests, which means you need a Windows
version and a Linux version&amp;hellip; It also means you&amp;rsquo;re writing shell scripts or
Windows batch files or whatever, instead of writing Go.  And we all know that we
want our tests to be in Go, not shell scripts.&lt;/p&gt;

&lt;p&gt;So what&amp;rsquo;s the answer?  Well, it turns out, if you want to mock out exec.Command,
the best place to look is in the exec package&amp;rsquo;s tests themselves.  Lo and
behold, it&amp;rsquo;s right there in the first function of &lt;a href=&#34;https://github.com/golang/go/blob/master/src/os/exec/exec_test.go#L31&#34;&gt;exec_test.go&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func helperCommand(t *testing.T, s ...string) *exec.Cmd {
    cs := []string{&amp;quot;-test.run=TestHelperProcess&amp;quot;, &amp;quot;--&amp;quot;}
    cs = append(cs, s...)
    cmd := exec.Command(os.Args[0], cs...)
    cmd.Env = []string{&amp;quot;GO_WANT_HELPER_PROCESS=1&amp;quot;}
    return cmd
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;sub&gt;&lt;sup&gt;(one line elided for clarity) &lt;/sup&gt;&lt;/sub&gt;&lt;/p&gt;

&lt;p&gt;What the heck is that doing?  It&amp;rsquo;s pretty slick, so I&amp;rsquo;ll explain it.&lt;/p&gt;

&lt;p&gt;First off, you have to understand how tests in Go work.  When running &lt;code&gt;go test&lt;/code&gt;,
the go tool compiles an executable from your code, runs it, and passes it the
flags you passed to &lt;code&gt;go test&lt;/code&gt;.  It&amp;rsquo;s that executable which actually handles the
flags and runs the tests.  Thus, while your tests are running, os.Args[0] is the
name of the test executable.&lt;/p&gt;

&lt;p&gt;This function is making an exec.Command that runs the test executable, and
passes it the flag to tell the executable just to run a single test.  It then
terminates the argument list with &lt;code&gt;--&lt;/code&gt; and appends the command and arguments
that would have been given to exec.Command to run &lt;em&gt;your&lt;/em&gt; command.&lt;/p&gt;

&lt;p&gt;The end result is that when you run the exec.Cmd that is returned, it will run
the single test from this package called &amp;ldquo;TestHelperProcess&amp;rdquo; and os.Args will
contain (after the &lt;code&gt;--&lt;/code&gt;) the command and arguments from the original call.&lt;/p&gt;

&lt;p&gt;The environment variable is there so that the test can know to do nothing unless
that environment variable is set.&lt;/p&gt;

&lt;p&gt;This is awesome for a few reasons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It&amp;rsquo;s all Go code. No more needing to write shell scripts.&lt;/li&gt;
&lt;li&gt;The code run in the excutable is compiled with the rest of your test code.  No more needing to worry about typos in the strings you&amp;rsquo;re writing to disk.&lt;/li&gt;
&lt;li&gt;No need to create new files on disk - the executable is already there and runnable, by definition.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So, let&amp;rsquo;s use this in a real example to make it more clear.&lt;/p&gt;

&lt;p&gt;In your production code, you can do something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var execCommand = exec.Command
func RunDocker(container string) ([]byte, error) {
    cmd := execCommand(&amp;quot;docker&amp;quot;, &amp;quot;run&amp;quot;, &amp;quot;-d&amp;quot;, container)
    out, err := cmd.CombinedOutput()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mocking this out in test code is now super easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func fakeExecCommand(command string, args...string) *exec.Cmd {
    cs := []string{&amp;quot;-test.run=TestHelperProcess&amp;quot;, &amp;quot;--&amp;quot;, command}
    cs = append(cs, args...)
    cmd := exec.Command(os.Args[0], cs...)
    cmd.Env = []string{&amp;quot;GO_WANT_HELPER_PROCESS=1&amp;quot;}
    return cmd
}

const dockerRunResult = &amp;quot;foo!&amp;quot;
func TestRunDocker(t *testing.T) {
    execCommand = fakeExecCommand
    defer func(){ execCommand = exec.Command }()
    out, err := RunDocker(&amp;quot;docker/whalesay&amp;quot;)
    if err != nil {
        t.Errorf(&amp;quot;Expected nil error, got %#v&amp;quot;, err)
    }
    if string(out) != dockerRunResult {
        t.Errorf(&amp;quot;Expected %q, got %q&amp;quot;, dockerRunResult, out)
    }
}

func TestHelperProcess(t *testing.T){
    if os.GetEnv(&amp;quot;GO_WANT_HELPER_PROCESS&amp;quot;) != &amp;quot;1&amp;quot; {
        return
    }
    // some code here to check arguments perhaps?
    fmt.Fprintf(os.Stdout, dockerRunResult)
    os.Exit(0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, you can do a lot more interesting things. The environment variables
on the command that fakeExecCommand returns make a nice side channel for telling
the executable what you want it to do.  I use one to tell the process to exit
with a non-zero error code, which is great for testing your error handling code.
You can see how the standard library uses its TestHelperProcess test
&lt;a href=&#34;https://github.com/golang/go/blob/master/src/os/exec/exec_test.go#L559&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Hopefully this will help you avoid writing really gnarly testing code (or even worse,
not testing your code at all).&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Sharing Godoc of a WIP Branch</title>
      <link>https://npf.io/2015/06/wip-godoc/</link>
      <pubDate>Thu, 11 Jun 2015 07:37:00 EDT</pubDate>
      <author>Nate Finch</author>
      <guid>https://npf.io/2015/06/wip-godoc/</guid>
      <description>&lt;p&gt;I had a problem yesterday - I wanted to use the excellent godoc.org to show
coworkers the godoc for the feature I was working on.  However, the feature was
on a branch of the main code in Github, and &lt;code&gt;go get&lt;/code&gt; Does Not Work That Way™.
So, what to do?  Well, I figured out a hack to make it work.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gopkg.in&#34;&gt;https://gopkg.in&lt;/a&gt; is a super handy service that lets you point &lt;code&gt;go get&lt;/code&gt; at
branches of your repo named vN (e.g. v0, v1, etc).  It also happens to work on
tags.  So, we can leverage this to get godoc.org to render the godoc for our WIP
branch.&lt;/p&gt;

&lt;p&gt;From your WIP branch, simply do&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git tag v0
git push myremote v0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates a lightweight tag that only affects your repo (not upstream from
whence you forked).&lt;/p&gt;

&lt;p&gt;You now can point godoc at your branch by way of gopkg.in:
&lt;a href=&#34;https://godoc.org/gopkg.in/GithubUser/repo.v0&#34;&gt;https://godoc.org/gopkg.in/GithubUser/repo.v0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This will tell godoc to &amp;lsquo;go get&amp;rsquo; your code from gopkg.in, and gopkg.in will
redirect the command to your v0 tag, which is currently on your branch.  Bam,
now you have godoc for your WIP branch on godoc.org.&lt;/p&gt;

&lt;p&gt;Later, the tag can easily be removed (and reused if needed) thusly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git tag -d v0
git push myremote :refs/tags/v0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, there you go, go forth and share your godoc.  I find it&amp;rsquo;s a great way to get
feedback on architecture before I dive into the reeds of the implementation.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Go Plugins are as Easy as Pie</title>
      <link>https://npf.io/2015/05/pie/</link>
      <pubDate>Mon, 25 May 2015 22:44:32 EDT</pubDate>
      <author>Nate Finch</author>
      <guid>https://npf.io/2015/05/pie/</guid>
      <description>

&lt;p&gt;When people hear that Go only supports static linking, one of the things they
eventually realize is that they can&amp;rsquo;t have traditional plugins via dlls/libs (in
compiled languages) or scripts (in interpreted languages).  However, that
doesn&amp;rsquo;t mean that you can&amp;rsquo;t have plugins.  Some people suggest doing &amp;ldquo;compiled-
in&amp;rdquo; plugins - but to me, that&amp;rsquo;s not a plugin, that&amp;rsquo;s just code.  Some people
suggest just running sub processes and sending messages via their CLI, but that
runs into CLI parsing issues and requires runnnig a new process for every
request.  The last option people think of is using RPC to an external process,
which may also seem cumbersome, but it doesn&amp;rsquo;t have to be.&lt;/p&gt;

&lt;h3 id=&#34;serving-up-some-pie&#34;&gt;Serving up some pie&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;d like to introduce you to &lt;a href=&#34;https://github.com/natefinch/pie&#34;&gt;https://github.com/natefinch/pie&lt;/a&gt; - this is a Go
package which contains a toolkit for writing plugins in Go.  It uses processes
external to the main program as the plugins, and communicates with them via RPC
over the plugin&amp;rsquo;s stdin and stout.  Having the plugin as an external process can
actually has several benefits:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If the plugin crashes, it won&amp;rsquo;t crash your process.&lt;/li&gt;
&lt;li&gt;The plugin is not in your process&amp;rsquo; memory space, so it can&amp;rsquo;t do anything nasty.&lt;/li&gt;
&lt;li&gt;The plugin can be written in any language, not just Go.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I think this last point is actually the most valuable.  One of the nicest things
about Go applications is that they&amp;rsquo;re just copy-and-run.  No one even needs to
know they were written in Go.  With plugins as external processes, this remains
true.  People wanting to extend your application can do so in the language of
their choice, so long as it supports the codec your application has chosen for
RPC.&lt;/p&gt;

&lt;p&gt;The fact that the communication occurs over stdin and stdout means that there is
no need to worry about negotiating ports, it&amp;rsquo;s easily cross platform compatible,
and it&amp;rsquo;s very secure.&lt;/p&gt;

&lt;h3 id=&#34;orthogonality&#34;&gt;Orthogonality&lt;/h3&gt;

&lt;p&gt;Pie is written to be a very simple set of functions that help you set up
communication between your process and a plugin process.  Once you make a couple
calls to pie, you then need to work out your own way to use the RPC connection
created.  Pie does not attempt to be an all-in-one plugin framework, though you
could certainly use it as the basis for one.&lt;/p&gt;

&lt;h3 id=&#34;why-is-it-called-pie&#34;&gt;Why is it called pie?&lt;/h3&gt;

&lt;p&gt;Because if you pronounce API like &amp;ldquo;a pie&amp;rdquo;, then all this consuming and serving
of APIs becomes a lot more palatable.  Also, pies are the ultimate pluggable
interface - depending on what&amp;rsquo;s inside, you can get dinner, dessert, a snack, or
even breakfast.  Plus, then I get to say that plugins in Go are as easy as&amp;hellip;
well, you know.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;I plan to be using pie in one of my own side projects.  Take it out for a spin
in one of your projects and let me know what you think.  Happy eating!&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Why Everyone Hates Go</title>
      <link>https://npf.io/2014/10/why-everyone-hates-go/</link>
      <pubDate>Tue, 14 Oct 2014 10:46:28 EDT</pubDate>
      <author>Nate Finch</author>
      <guid>https://npf.io/2014/10/why-everyone-hates-go/</guid>
      <description>&lt;p&gt;Obviously, not &lt;em&gt;everyone&lt;/em&gt; hates Go.  But there was a &lt;a href=&#34;https://www.quora.com/Why-does-Go-seem-to-be-the-most-heavily-
criticised-among-the-newer-programming-languages?srid=uCiY&amp;amp;share=1&#34;&gt;quora
question&lt;/a&gt; recently
about why everyone criticizes Go so much. (sorry, I don&amp;rsquo;t normally post links to
Quora, but it was the motivator for this post) Even before I saw the answers to
the question, I knew what they&amp;rsquo;d consist of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Go is a language stuck in the 70&amp;rsquo;s.&lt;/li&gt;
&lt;li&gt;Go ignores 40 years of programming language research.&lt;/li&gt;
&lt;li&gt;Go is a language for blue collar (mediocre) developers.&lt;/li&gt;
&lt;li&gt;Gophers are ok with working in Java 1.0.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unfortunately, the answers to the questions were more concerned with explaining
why Go is &amp;ldquo;bad&amp;rdquo;, rather than why this gets under so many people&amp;rsquo;s skin.&lt;/p&gt;

&lt;p&gt;When reading the answers I had a eureka moment, and I realized why it is. So
here&amp;rsquo;s my answer to the same question. This is why Go is so heavily criticized,
not why Go is &amp;ldquo;bad&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s two awesome posts that inform my answer: Paul Graham&amp;rsquo;s
&lt;a href=&#34;http://www.paulgraham.com/identity.html&#34;&gt;post&lt;/a&gt; about keeping your identity
small, and Kathy Sierra&amp;rsquo;s &lt;a href=&#34;http://seriouspony.com/trouble-at-the-koolaid-
point&#34;&gt;post&lt;/a&gt; about the Koolaid point. I encourage you to read those two posts, as
they&amp;rsquo;re both very informative.  I hesitate to compare the horrific things that
happen to women online with the pedantry of flamewars about programming
languages, but the Koolaid Point is such a valid metaphor that I wanted to link
to the article.&lt;/p&gt;

&lt;p&gt;Paul says&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;people can never have a fruitful argument about
something that&amp;rsquo;s part of their identity&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;i.e.&lt;/em&gt; the subject hits too close to home,
and their response becomes emotional rather than logical.&lt;/p&gt;

&lt;p&gt;Kathy says&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;the hate wasn’t so much about the product/brand but that &lt;em&gt;other people were falling for it&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;i.e.&lt;/em&gt; they&amp;rsquo;d drunk the kool-aid.&lt;/p&gt;

&lt;p&gt;Go is the only recent language that takes the aforementioned 40 years of
programming language research and tosses it out the window. Other new languages
at least try to keep up with the Jones - Clojure, Scala, Rust - all try to
incorporate &amp;ldquo;modern programming theory&amp;rdquo; into their design. Go actively tries
not to. There is no pattern matching, there&amp;rsquo;s no borrowing, there&amp;rsquo;s no pure
functional programming, there&amp;rsquo;s no immutable variables, there&amp;rsquo;s no option types,
there&amp;rsquo;s no exceptions, there&amp;rsquo;s no classes, there&amp;rsquo;s no generics&amp;hellip;. there&amp;rsquo;s a lot
Go doesn&amp;rsquo;t have. And in the beginning this was enough to merely earn it scorn.
Even I am guilty of this. When I first heard about Go, I thought &amp;ldquo;What? No
exceptions? Pass.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;But then something happened - people started &lt;em&gt;using&lt;/em&gt; it. And liking it. And
building big projects with it. This is the Koolaid-point - where people have
started to drink the Koolaid and get fooled into thinking Go is a good
language. And this is where the scorn turns into derision and attacks on the
character of the people using it.&lt;/p&gt;

&lt;p&gt;The most vocal Go detractors are those developers who write in ML-derived
languages (Haskell, Rust, Scala, &lt;em&gt;et al&lt;/em&gt;) who have tied their preferred
programming language into their identity. The mere existence of Go says
&amp;ldquo;your views on what makes a good programming language are wrong&amp;rdquo;. And the more
people that use and like Go, the more strongly they feel that they&amp;rsquo;re being told
their choice of programming language - and therefore their identity - is wrong.&lt;/p&gt;

&lt;p&gt;Note that basically no one in the Go community actually says this. But the Go
philosophy of simplicity and pragmatism above all else is the polar opposite of
what those languages espouse (in which complexity in the language is ok because
it enforces correctness in the code). This is insulting to the people who tie
their identity to that language. Whenever a post on Go makes it to the front
page of Hacker News, it is an affront to everything they hold dear, and so you
get comments like Go developers are stuck in the 70&amp;rsquo;s, or is only for blue-collar devs.&lt;/p&gt;

&lt;p&gt;So, this is why I think people are so much more vocal about their dislike of Go:
because it challenges their identity, and other people are falling for it. This
is also why these posts so often mention Google and how the language would have
died without them. Google is now the koolaid dispenser. The fact that they
are otherwise generally thought of as a very talented pool of developers means
that it is simultaneously more outrageous that they are fooling people and more
insulting that their language flies in the face of ML-derived languages.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt;  I removed the &amp;ldquo;panties in a bunch&amp;rdquo; comment, since I was (correctly)
scolded for being sexist, not to mention unprofessional.  My apologies to
anyone I offended.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>CI for Windows Go Packages with AppVeyor</title>
      <link>https://npf.io/2014/07/ci-for-windows-go-packages-with-appveyor/</link>
      <pubDate>Wed, 09 Jul 2014 17:43:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>https://npf.io/2014/07/ci-for-windows-go-packages-with-appveyor/</guid>
      <description>&lt;p&gt;I recently needed to update my &lt;a href=&#34;https://github.com/natefinch/npipe&#34; target=&#34;_blank&#34;&gt;npipe&lt;/a&gt; package, and since I want it to be production quality, that means setting up CI, so that people using my package can know it&amp;rsquo;s passing tests. &amp;nbsp;Normally I&amp;rsquo;d use Travis CI or Drone.io for that, but npipe is a Windows-only Go package, and neither of the aforementioned services support running tests on Windows.&lt;br /&gt;&lt;br /&gt;With some googling, I saw that &lt;a href=&#34;https://twitter.com/nathany&#34; target=&#34;_blank&#34;&gt;Nathan Youngman&lt;/a&gt;&amp;nbsp;had worked with&amp;nbsp;&lt;a href=&#34;http://www.appveyor.com/&#34; target=&#34;_blank&#34;&gt;AppVeyor&lt;/a&gt;&amp;nbsp;to add Go support to their CI system. &amp;nbsp;The example on the blog talks about making a build.cmd file in your repo to enable Go builds, but I found that you can easily set up a Go build without having to put CI-specific files in your repo.&lt;br /&gt;&lt;br /&gt;To get started with AppVeyor, just log into their site and tell it where to get your code (I logged in with Github, and it was easy to specify what repo of mine to test). &amp;nbsp;Once you choose the repo, go to the Settings page on AppVeyor for that repo. &amp;nbsp;Under the Environment tab on the left, set the clone directory to C:\GOPATH\src&amp;amp;lt;your import path&amp;gt; and set an environment variable called GOPATH to C:\GOPATH. &amp;nbsp;Under the build tab, set the build type to &amp;ldquo;SCRIPT&amp;rdquo; and the script type to &amp;ldquo;CMD&amp;rdquo;, and make the contents of the script &lt;pre style=&#34;tab-size: 4;&#34;&gt;go get -v -d -t &amp;lt;your import path&amp;gt;/&amp;hellip;&lt;/pre&gt; (this will download the dependencies for your package). &amp;nbsp;In the test tab, set the test type to &amp;ldquo;SCRIPT&amp;rdquo;, the script type to &amp;ldquo;CMD&amp;rdquo; and the script contents to &lt;pre style=&#34;tab-size: 4;&#34;&gt;go test -v -cover ./&amp;hellip;&lt;/pre&gt; &amp;nbsp;(this will run all the tests in verbose mode and also output the test coverage).&lt;br /&gt;&lt;br /&gt;That&amp;rsquo;s pretty much it. &amp;nbsp;AppVeyor will automatically run a build on commits, like you&amp;rsquo;d expect. &amp;nbsp;You can watch the progress on a console output on their page, and get a pretty little badge from the badges page. &amp;nbsp;It&amp;rsquo;s free for open source projects, and seems relatively responsive from my admittedly limited experience.&lt;br /&gt;&lt;br /&gt;This is a great boon for Go developers, so you can be sure your code builds and passes tests on Windows, with very little work to set it up. &amp;nbsp;I&amp;rsquo;m probably going to add this to all my production repos, even the ones that aren&amp;rsquo;t Windows-only, to ensure my code works well on Windows as well as Linux.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Intro to BoltDB: Painless Performant Persistence</title>
      <link>https://npf.io/2014/07/intro-to-boltdb-painless-performant-persistence/</link>
      <pubDate>Mon, 07 Jul 2014 08:25:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>https://npf.io/2014/07/intro-to-boltdb-painless-performant-persistence/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://github.com/boltdb/bolt&#34; target=&#34;_blank&#34;&gt;BoltDB&lt;/a&gt; is a pure Go persistence solution that saves data to a memory mapped file.  I call it a persistence solution and not a database, because the word database has a lot of baggage associated with it that doesn&amp;rsquo;t apply to bolt. And that lack of baggage is what makes bolt so awesome.&lt;br /&gt;&lt;br /&gt;Bolt is just a Go package.  There&amp;rsquo;s nothing you need to install on the system, no configuration to figure out before you can start coding, nothing.  You just go get github.com/boltdb/bolt and then import &amp;ldquo;github.com/boltdb/bolt&amp;rdquo;. &lt;br /&gt;&lt;br /&gt;All you need to fully use bolt as storage is a file name.  This is fantastic from both a developer&amp;rsquo;s point of view, and a user&amp;rsquo;s point of view.  I don&amp;rsquo;t know about you, but I&amp;rsquo;ve spent months of work time over my career configuring and setting up databases and debugging configuration problems, users and permissions and all the other crap you get from more traditional databases like Postgres and Mongo.  There&amp;rsquo;s none of that with bolt.  No users, no setup, just a file name.  This is also a boon for users of your application, because &lt;em&gt;they&lt;/em&gt; don&amp;rsquo;t have to futz with all that crap either.&lt;br /&gt;&lt;br /&gt;Bolt is not a relational database.  It&amp;rsquo;s not even a document store, though you can sort of use it that way.  It&amp;rsquo;s really just a key/value store&amp;hellip; but don&amp;rsquo;t worry if you don&amp;rsquo;t really know what that means or how you&amp;rsquo;d use that for storage.  It&amp;rsquo;s super simple and it&amp;rsquo;s incredibly flexible.  Let&amp;rsquo;s take a look.&lt;br /&gt;&lt;br /&gt;Storage in bolt is divided into buckets.  A bucket is simply a named collection of key/value pairs, just like Go&amp;rsquo;s map.  The name of the bucket, the keys, and the values are all of type []byte.  Buckets can contain other buckets, also keyed by a []byte name. &lt;br /&gt;&lt;br /&gt;&amp;hellip; that&amp;rsquo;s it.  No, really, that&amp;rsquo;s it.  Bolt is basically a bunch of nested maps.  And this simplicity is what makes it so easy to use.  There&amp;rsquo;s no tables to set up, no schemas, no complex querying language to struggle with.  Let&amp;rsquo;s look at a bolt hello world:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;package main&lt;br /&gt;&lt;br /&gt;import (&lt;br /&gt;    &amp;ldquo;fmt&amp;rdquo;&lt;br /&gt;    &amp;ldquo;log&amp;rdquo;&lt;br /&gt;&lt;br /&gt;    &amp;ldquo;github.com/boltdb/bolt&amp;rdquo;&lt;br /&gt;)&lt;br /&gt;&lt;br /&gt;var world = []byte(&amp;ldquo;world&amp;rdquo;)&lt;br /&gt;&lt;br /&gt;func main() {&lt;br /&gt;    db, err := bolt.Open(&amp;ldquo;/home/nate/foo/bolt.db&amp;rdquo;, 0644, nil)&lt;br /&gt;    if err != nil {&lt;br /&gt;        log.Fatal(err)&lt;br /&gt;    }&lt;br /&gt;    defer db.Close()&lt;br /&gt;&lt;br /&gt;    key := []byte(&amp;ldquo;hello&amp;rdquo;)&lt;br /&gt;    value := []byte(&amp;ldquo;Hello World!&amp;rdquo;)&lt;br /&gt;&lt;br /&gt;    // store some data&lt;br /&gt;    err = db.Update(func(tx *bolt.Tx) error {&lt;br /&gt;        bucket, err := tx.CreateBucketIfNotExists(world)&lt;br /&gt;        if err != nil {&lt;br /&gt;            return err&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        err = bucket.Put(key, value)&lt;br /&gt;        if err != nil {&lt;br /&gt;            return err&lt;br /&gt;        }&lt;br /&gt;        return nil&lt;br /&gt;    })&lt;br /&gt;&lt;br /&gt;    if err != nil {&lt;br /&gt;        log.Fatal(err)&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    // retrieve the data&lt;br /&gt;    err = db.View(func(tx *bolt.Tx) error {&lt;br /&gt;        bucket := tx.Bucket(world)&lt;br /&gt;        if bucket == nil {&lt;br /&gt;            return fmt.Errorf(&amp;ldquo;Bucket %q not found!&amp;rdquo;, world)&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        val := bucket.Get(key)&lt;br /&gt;        fmt.Println(string(val))&lt;br /&gt;&lt;br /&gt;        return nil&lt;br /&gt;    })&lt;br /&gt;&lt;br /&gt;    if err != nil {&lt;br /&gt;        log.Fatal(err)&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;// output:&lt;br /&gt;// Hello World!&lt;/pre&gt;&lt;div&gt;&lt;/div&gt;I know what you&amp;rsquo;re thinking - that seems kinda long.  But keep in mind, I fully handled all errors in at least a semi-proper way, and we&amp;rsquo;re doing all this:&lt;br /&gt;&lt;br /&gt;1.) creating a database &lt;br /&gt;2.) creating some structure (the &amp;ldquo;world&amp;rdquo; bucket)&lt;br /&gt;3.) storing data to the structure&lt;br /&gt;4.) retrieving data from the structure.&lt;br /&gt;&lt;br /&gt;I think that&amp;rsquo;s not too bad in 54 lines of code.&lt;br /&gt;&lt;br /&gt;So let&amp;rsquo;s look at what that example is really doing.  First we call bolt.Open to get the database.  This will create the file if necessary, or open it if it exists.&lt;br /&gt;&lt;br /&gt;All reads from or writes to the bolt database must be done within a transaction. You can have as many Readers in read-only transactions at the same time as you want, but only one Writer in a writable transaction at a time (readers maintain a consistent view of the DB while writers are writing).&lt;br /&gt;&lt;br /&gt;To begin, we call db.Update, which takes a function to which it&amp;rsquo;ll pass a bolt.Tx - bolt&amp;rsquo;s transaction object.  We then create a Bucket (since all data in bolt lives in buckets), and add our key/value pair to it.  After the write transaction finishes, we start a read- only transaction with DB.View, and get the values back out.&lt;br /&gt;&lt;br /&gt;What&amp;rsquo;s great about bolt&amp;rsquo;s transaction mechanism is that it&amp;rsquo;s super simple - the scope of the function is the scope of the transaction.  If the function passed to Update returns nil, all updates from the transaction are atomically stored to the database.  If the function passed to Update returns an error, the transaction is rolled back.  This makes bolt&amp;rsquo;s transactions completely intuitive from a Go developer&amp;rsquo;s point of view.  You just exit early out of your function by returning an error as usual, and bolt Does The Right Thing.  No need to worry about manually rolling back updates or anything, just return an error.&lt;br /&gt;&lt;br /&gt;The only other basic thing you may need is to iterate over key/value pairs in a Bucket, in which case, you just call bucket.Cursor(), which returns a Cursor value, which has functions like Next(), Prev() etc that return a key/value pair and work like you&amp;rsquo;d expect.&lt;br /&gt;&lt;br /&gt;There&amp;rsquo;s a lot more to the bolt API, but most of the rest of it is more about database statistics and some stuff for more advanced usage scenarios&amp;hellip; but the above is all you really need to know to start storing data in a bolt database.&lt;br /&gt;&lt;br /&gt;For a more complex application, just storing strings in the database may not be sufficient, but that&amp;rsquo;s ok, Go has your back there, too.  You can easily use encoding/json or encoding/gob to serialize structs into the database, keyed by a unique name or id.  This is what makes it easy for bolt to go from a key/value store to a document store - just have one bucket per document type.  Again, the benefit of bolt is low barrier of entry.  You don&amp;rsquo;t have to figure out a whole database schema or install anything to be able to just start dumping data to disk in a performant and manageable way.&lt;br /&gt;&lt;br /&gt;The main drawback of bolt is that there are no queries.  You can&amp;rsquo;t say &amp;ldquo;give me all foo objects with a name that starts with bar&amp;rdquo;.  You &lt;i&gt;could&lt;/i&gt; make your own index in the database and keep it up to date manually.  This could be as easy as a slice of IDs serialized into an &amp;ldquo;indices&amp;rdquo; bucket for a particular query. Obviously, this is where you start getting into the realm of developing your own relational database, but if you don&amp;rsquo;t go overboard, it can be nice that all this code is just that - code.  It&amp;rsquo;s not queries in some external DSL, it&amp;rsquo;s just code like you&amp;rsquo;d write for an in-memory data store.&lt;br /&gt;&lt;br /&gt;Bolt is not for every application.  You must understand your application&amp;rsquo;s needs and if bolt&amp;rsquo;s key/value style will be sufficient to fulfill those needs.  If it is, I think you&amp;rsquo;ll be very happy to use such a simple data store with so little mental overhead.&lt;br /&gt;&lt;br /&gt;[edited to clarify reader/writer relationship]   Bonus Gob vs. Json benchmark for storing structs in Bolt: &lt;pre&gt;&lt;br /&gt;BenchmarkGobEncode  1000000       2191 ns/op&lt;br /&gt;BenchmarkJsonEncode   500000       4738 ns/op&lt;br /&gt;BenchmarkGobDecode  1000000       2019 ns/op&lt;br /&gt;BenchmarkJsonDecode   200000      12993 ns/op&lt;br /&gt;&lt;/pre&gt;Code: &lt;a href=&#34;http://play.golang.org/p/IvfDUGBpJ6&#34;&gt;http://play.golang.org/p/IvfDUGBpJ6&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Autogenerate docs with this one dumb trick</title>
      <link>https://npf.io/2014/06/autogenerate-docs-with-this-one-dumb-trick/</link>
      <pubDate>Tue, 17 Jun 2014 05:59:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>https://npf.io/2014/06/autogenerate-docs-with-this-one-dumb-trick/</guid>
      <description>&lt;p&gt;Yesterday, I was trying to think of a way of automating some doc generation for my go packages.  The specific task I wanted to automate was updating a badge in my package&amp;rsquo;s README to show the test coverage.  What I wanted was a way to run go test -cover, parse the results, and put the result in the correct spot of my README.  My first thought was to write an application that would do that for me &amp;hellip; but then I&amp;rsquo;d have to run that &lt;i&gt;instead&lt;/i&gt; of go test.  What I realized I wanted was something that was &amp;ldquo;compatible with go test&amp;rdquo; - i.e. I want to run go test and not have to remember to run some special other command.&lt;br /&gt;&lt;br /&gt;And that&amp;rsquo;s when it hit me:  What is a test in Go?  A test is a Go function that gets run when you run &amp;ldquo;go test&amp;rdquo;. &amp;nbsp;Nothing says your test has to actually test anything. &amp;nbsp;And nothing prevents your test from doing something permanent on your machine (in fact we usually have to bend over backwards to make sure our tests &lt;i&gt;don&amp;rsquo;t&lt;/i&gt;&amp;nbsp;do anything permanent. &amp;nbsp;You can just write a test function that updates the docs for you.&lt;br /&gt;&lt;br /&gt;I actually quite like this technique. &amp;nbsp;I often have some manual tasks after updating my code - usually updating the docs in the README with changes to the API, or changing the docs to show new CLI flags, etc. &amp;nbsp;And there&amp;rsquo;s one thing I always do after I update my code - and that&amp;rsquo;s run &amp;ldquo;go test&amp;rdquo;. &amp;nbsp;If that also updates my docs, all the better.&lt;br /&gt;&lt;br /&gt;This is how covergen was born. &amp;nbsp;&lt;a href=&#34;https://github.com/natefinch/covergen&#34;&gt;https://github.com/natefinch/covergen&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;Covergen is a particularly heinous example of a test that updates your docs. &amp;nbsp;The heinous part is that it actually doubles the time it takes to run your tests&amp;hellip; this is because that one test re-runs all the tests with -cover to get the coverage percent. &amp;nbsp;I&amp;rsquo;m not sure I&amp;rsquo;d actually release real code that used such a thing - doubling the time it takes to run your tests just to save a few seconds of copy and paste is pretty terrible.&lt;br /&gt;&lt;br /&gt;However, it&amp;rsquo;s a valid example of what you can do when you throw away testing convention and decide you want to write some code in a test that doesn&amp;rsquo;t actually test anything, and instead just runs some automated tasks that you want run whenever anyone runs go test. &amp;nbsp;Just make sure the result is idempotent so you&amp;rsquo;re not continually causing things to look modified to version control.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Diffing Go with Beyond Compare</title>
      <link>https://npf.io/2014/05/diffing-go-with-beyond-compare/</link>
      <pubDate>Wed, 14 May 2014 13:09:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>https://npf.io/2014/05/diffing-go-with-beyond-compare/</guid>
      <description>&lt;p&gt;I love Beyond Compare, it&amp;rsquo;s an awesome visual diff/merge tool. &amp;nbsp;It&amp;rsquo;s not free, but I don&amp;rsquo;t care, because it&amp;rsquo;s awesome. &amp;nbsp;However, there&amp;rsquo;s no built-in configuration for Go code, so I made one. &amp;nbsp;Not sure what the venn diagram of Beyond Compare users and Go users looks like, it might be that I&amp;rsquo;m the one point of crossover, but just in case I&amp;rsquo;m not, here&amp;rsquo;s the configuration file for Beyond Compare 3 for the Go programming language:&amp;nbsp;&lt;a href=&#34;http://play.golang.org/p/G6NWE0z1GC&#34;&gt;http://play.golang.org/p/G6NWE0z1GC&lt;/a&gt; &amp;nbsp;(please forgive the abuse of the Go playground)&lt;br /&gt;&lt;br /&gt;Just copy the text into a file and in Beyond Compare, go to Tools-&amp;gt;Import Settings&amp;hellip; and choose the file. &amp;nbsp;Please let me know if you have any troubles or suggested improvements.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Intro&#43;&#43; to Go Interfaces</title>
      <link>https://npf.io/2014/05/intro-to-go-interfaces/</link>
      <pubDate>Tue, 13 May 2014 07:08:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>https://npf.io/2014/05/intro-to-go-interfaces/</guid>
      <description>

&lt;h3 id=&#34;standard-interface-intro&#34;&gt;Standard Interface Intro&lt;/h3&gt;

&lt;p&gt;Go’s interfaces are one of it’s best features, but they’re also one of the most confusing for newbies.  This post will try to give you the understanding you need to use Go’s interfaces and not get frustrated when things don’t work the way you expect.  It’s a little long, but a bunch of that is just code examples.&lt;/p&gt;

&lt;p&gt;Go’s interfaces are different than interfaces in other languages, they are implicitly fulfilled.  This means that you never need to mark your type as explicitly implementing the interface (like class CFoo implements IFoo).  Instead, your type just needs to have the methods defined in the interface, and the compiler does the rest.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Walker interface {
    Walk(miles int)
}

type Camel struct {
    Name string
}

func (c Camel) Walk(miles int) {
     fmt.Printf(“%s is walking %v miles\n”, c.Name, miles)
}

func LongWalk(w Walker) {
     w.Walk(500)
     w.Walk(500)
}

func main() {
    c := Camel{“Bill”}
    LongWalk(c)
}

// prints
// Bill is walking 500 miles.
// Bill is walking 500 miles.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/erodX-JplO&#34;&gt;http://play.golang.org/p/erodX-JplO&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Camel implements the Walker interface, because it has a method named Walk that
takes an int and doesn’t return anything.  This means you can pass it into the
LongWalk function, even though you never specified that your Camel is a Walker.
In fact, Camel and Walker can live in totally different packages and never know
about one another, and this will still work if a third package decides to make a
Camel and pass it into LongWalk.&lt;/p&gt;

&lt;h3 id=&#34;non-standard-continuation&#34;&gt;Non-Standard Continuation&lt;/h3&gt;

&lt;p&gt;This is where most tutorials stop, and where most questions and problems begin.
The problem is that you still don’t know how the interfaces actually work, and
since it’s not actually that complicated, let’s talk about that.&lt;/p&gt;

&lt;p&gt;What actually happens when you pass Camel into LongWalk?&lt;/p&gt;

&lt;p&gt;So, first off, you’re not passing Camel into LongWalk.  You’re actually
assigning c, a value of type Camel to a value w of type Walker, and w is what
you operate on in LongWalk.&lt;/p&gt;

&lt;p&gt;Under the covers, the Walker interface (like all interfaces), would look more or
less like this if it were in Go (the actual code is in C, so this is just a
really rough approximation that is easier to read).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Walker struct {
    type InterfaceType
    data *void
}

type InterfaceType struct {
    valtype *gotype
    func0 *func
    func1 *func
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All interfaces values are just two pointers - one pointer to information about
the interface type, and one pointer to the data from the value you passed into
the interface (a void in C-like languages… this should probably be Go’s
unsafe.Pointer, but I liked the explicitness of two actual *’s in the struct to
show it’s just two pointers).&lt;/p&gt;

&lt;p&gt;The InterfaceType contains a pointer to information about the type of the value
that you passed into the interface (valtype).  It also contains pointers to the
methods that are available on the interface.&lt;/p&gt;

&lt;p&gt;When you assign c to w, the compiler generates instructions that looks more or
less like this (it’s not actually generating Go, this is just an easier-to-read
approximation):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data := c
w := Walker{ 
    type: &amp;amp;InterfaceType{ 
              valtype: &amp;amp;typeof(c), 
              func0: &amp;amp;Camel.Walk 
          }
    data: &amp;amp;data
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you assign your Camel value c to the Walker value w, the Camel type is
copied into the interface value’s Type.valtype field.  The actual data in the
value of c is copied into a new place in memory, and w’s Data field points at
that memory location.&lt;/p&gt;

&lt;h3 id=&#34;implications-of-the-implementation&#34;&gt;Implications of the Implementation&lt;/h3&gt;

&lt;p&gt;Now, let’s look at the implications of this code.  First, interface values are
very small - just two pointers.  When you assign a value to an interface, that
value gets copied once, into the interface, but after that, it’s held in a
pointer, so it doesn’t get copied again if you pass the interface around.&lt;/p&gt;

&lt;p&gt;So now you know why you don’t need to pass around pointers to interfaces -
they’re small anyway, so you don’t have to worry about copying the memory, plus
they hold your data in a pointer, so changes to the data will travel with the
interface.&lt;/p&gt;

&lt;h3 id=&#34;interfaces-are-types&#34;&gt;Interfaces Are Types&lt;/h3&gt;

&lt;p&gt;Let’s look at Walker again, this is important:&lt;/p&gt;

&lt;p&gt;type Walker interface&lt;/p&gt;

&lt;p&gt;Note that first word there: type.  Interfaces are types, just like string is a
type or Camel is a type.  They aren’t aliases, they’re not magic hand-waving,
they’re real types and real values which are distinct from the type and value
that gets assigned to them.&lt;/p&gt;

&lt;p&gt;Now, let’s assume you have this function:&lt;/p&gt;

&lt;p&gt;func LongWalkAll(walkers []Walker) {
    for _, w := range walkers {
        LongWalk(w)
    }
}&lt;/p&gt;

&lt;p&gt;And let’s say you have a caravan of Camels that you want to send on a long walk:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;caravan := []Camel{ Camel{“Bill”}, Camel{“Bob”}, Camel{“Steve”}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You want to pass caravan into LongWalkAll, will the compiler let you?  Nope.
Why is that?  Well, []Walker is a specific type, it’s a slice of values of type
Walker.  It’s not shorthand for “a slice of anything that matches the Walker
interface”.  It’s an actual distinct type, the way []string is different from
[]int.  The Go compiler will output code to assign a single value of Camel to a
single value of Walker.  That’s the only place it’ll help you out.  So, with
slices, you have to do it yourself:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;walkers := make([]Walker, len(caravan))
for n, c := range caravan {
    walkers[n] = c
}
LongWalkAll(walkers)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, there’s a better way if you know you’ll just need the caravan for
passing into LongWalkAll:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;caravan := []Walker{ Camel{“Bill”}, Camel{“Bob”}, Camel{“Steve”}}
LongWalkAll(caravan)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this goes for any type which includes an interface as part of its
definition: there’s no automatic conversion of your func(Camel) into
func(Walker) or map[string]Camel into map[string]Walker.  Again, they’re totally
different types, they’re not shorthand, and they’re not aliases, and they’re not
just a pattern for the compiler to match.&lt;/p&gt;

&lt;p&gt;Interfaces and the Pointers That Satisfy Them&lt;/p&gt;

&lt;p&gt;What if Camel’s Walk method had this signature instead?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Camel) Walk(miles int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This line says that the type *Camel has a function called Walk.  This is
important: *Camel is a type.  It’s the “pointer to a Camel” type.  It’s a
distinct type from (non-pointer) Camel.  The part about it being a pointer is
part of its type.  The Walk method is on the type *Camel.  The Walk method (in
this new incarnation) is not on the type Camel. This becomes important when you
try to assign it to an interface.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c := Camel{“Bill”}
LongWalk(c)

// compiler output:
cannot use c (type Camel) as type Walker in function argument:
 Camel does not implement Walker (Walk method has pointer receiver)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To pass a Camel into LongWalk now, you need to pass in a pointer to a Camel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c := &amp;amp;Camel{“Bill”}
LongWalk(c)

or

c := Camel{“Bill”}
LongWalk(&amp;amp;c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this true even though you can still call Walk directly on Camel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c := Camel{“Bill”}
c.Walk(500) // this works
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason you can do that is that the Go compiler automatically converts this
line to (&amp;amp;c).Walk(500) for you.  However, that doesn’t work for passing the
value into an interface.  The reason is that the value in an interface is in a
hidden memory location, and so the compiler can’t automatically get a pointer to
that memory for you (in Go parlance, this is known as being “not addressable”).&lt;/p&gt;

&lt;h3 id=&#34;nil-pointers-and-nil-interfaces&#34;&gt;Nil Pointers and Nil Interfaces&lt;/h3&gt;

&lt;p&gt;The interaction between nil interfaces and nil pointers is where nearly everyone
gets tripped up when they first start with Go.&lt;/p&gt;

&lt;p&gt;Let’s say we have our Camel type with the Walk method defined on *Camel as
above, and we want to make a function that returns a Walker that is actually a
Camel (note that you don’t need a function to do this, you can just assign a
*Camel to a Walker, but the function is a good illustrative example):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func MakeWalker() Walker {
    return &amp;amp;Camel{“Bill”}
}

w := MakeWalker()
if w != nil {
    w.Walk(500)  // we will hit this
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works fine.  But now, what if we do something a little different:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func MakeWalker(c *Camel) Walker {
    return c
}

var c *Camel
w := MakeWalker(c)
if w != nil {
    // we’ll get in here, but why?
    w.Walk(500)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code will also get inside the if statement (and then panic, which we’ll
talk about in a bit) because the returned Walker value is not nil.  How is that
possible, if we returned a nil pointer?  Well, let’s go look back to the
instructions that get generated when we assign a value to an interface.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data := c
w := Walker{ 
    type: &amp;amp;InterfaceType{ 
              valtype: &amp;amp;typeof(c), 
              func0: &amp;amp;Camel.Walk 
          }
    data: &amp;amp;data
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, c is a nil pointer. However, that’s a perfectly valid value to
assign to the Walker’s Data value, so it works just fine.  What you return is a
non-nil Walker value, that has a pointer to a nil *Camel as its data.  So, of
course, if you check w == nil, the answer is false, w is not nil… but then
inside the if statement, we try to call Camel’s walk:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Camel) Walk(miles int) {
     fmt.Printf(“%s is walking %v miles\n”, c.Name, miles)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And when we try to do c.Name, Go automatically turns that into (*c).Name, and
the code panics with a nil pointer dereference error.&lt;/p&gt;

&lt;p&gt;Hopefully this makes sense, given our new understanding of how interfaces wrap
values, but then how do you account for nil pointers?  Assume you want
MakeWalker to return a nil interface if it gets passed a nil Camel.  You have to
explicitly assign nil to the interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func MakeWalker(c *Camel) Walker {
    if c == nil {
        return nil
    }
    return c
}

var c *Camel
w := MakeWalker(c)
if w != nil {
    // Yay, we don’t get here!
    w.Walk(500)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now, finally, the code is doing what we expect.  When you pass in a nil
*Camel, we return a nil interface.  Here’s an alternate way to write the
function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func MakeWalker(c *Camel) Walker {
    var w Walker
    if c != nil {
        w = c
    }
    return w
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is slightly less optimal, but it shows the other way to get a nil
interface, which is to use the zero value for the interface, which is nil.&lt;/p&gt;

&lt;p&gt;Note that you can have a nil pointer value that satisfies an interface.  You
just need to be careful not to dereference the pointer in your methods.  For
example, if *Camel’s Walk method looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Camel) Walk(miles int) {
    fmt.Printf(“I’m walking %d miles!”, miles)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this method does not dereference c, and therefore you can call it even
if c is nil:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var c *Camel
c.Walk(500)
// prints “I’m walking 500 miles!”
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/4EfyV21at9&#34;&gt;http://play.golang.org/p/4EfyV21at9&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;outro&#34;&gt;Outro&lt;/h3&gt;

&lt;p&gt;I hope this article helps you better understand how interfaces works, and helps
you avoid some of the common pitfalls and misconceptions newbies have about how
interfaces work.  If you want more information about the internals of interfaces
and some of the optimizations that I didn’t cover here, read Russ Cox’s article
on Go interfaces, I highly recommend it.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Mocking functions in Go</title>
      <link>https://npf.io/2014/04/mocking-functions-in-go/</link>
      <pubDate>Thu, 10 Apr 2014 11:35:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>https://npf.io/2014/04/mocking-functions-in-go/</guid>
      <description>&lt;p&gt;Functions in Go are first class citizens, that means you can have a variable that contains a function value, and call it like a regular function.&lt;br /&gt;&lt;pre style=&#34;tab-size: 4;&#34;&gt;printf := fmt.Printf&lt;br /&gt;printf(&amp;ldquo;This will output %d line.\n&amp;rdquo;, 1)&lt;/pre&gt;This ability can come in very handy for testing code that calls a function which is hard to properly test while testing the surrounding code. &amp;nbsp;In &lt;a href=&#34;http://juju.ubuntu.com/&#34; target=&#34;_blank&#34;&gt;Juju&lt;/a&gt;, we occasionally use function variables to allow us to stub out a difficult function during tests, in order to more easily test the code that calls it. &amp;nbsp;Here&amp;rsquo;s a simplified example:&lt;br /&gt;
&lt;pre style=&#34;tab-size: 4;&#34;&gt;// in install/mongodb.go&lt;br /&gt;package install&lt;br /&gt;&lt;br /&gt;func SetupMongodb(path string) error {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;// suppose the code in this method modifies files in root&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;// directories, mucks with the environment, etc&amp;hellip; &lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;// Actions you actively don&amp;rsquo;t want to do during most tests.&lt;br /&gt;}&lt;/pre&gt;&lt;/span&gt;&lt;pre style=&#34;tab-size: 4;&#34;&gt;&lt;br /&gt;// in startup/bootstrap.go&lt;br /&gt;package startup&lt;br /&gt;&lt;br /&gt;func Bootstrap() error {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;hellip;&lt;br /&gt;&amp;nbsp; &amp;nbsp; path := getPath()&lt;br /&gt;&amp;nbsp; &amp;nbsp; if err := install.SetupMongodb(path); err != nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;return err&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;hellip;&lt;br /&gt;}&lt;/pre&gt;&lt;/span&gt;So, suppose you want to write a test for Bootstrap, but you know SetupMongodb won&amp;rsquo;t work, because the tests don&amp;rsquo;t run with root privileges (and you don&amp;rsquo;t want to setup mongodb on the dev&amp;rsquo;s machine anyway). &amp;nbsp;What can you do? &amp;nbsp;This is where mocking comes in.&lt;br /&gt;&lt;br /&gt;We just make a little tweak to Bootstrap:&lt;br /&gt;&lt;pre style=&#34;tab-size: 4;&#34;&gt;package startup&lt;br /&gt;&lt;br /&gt;var setupMongo = install.SetupMongodb&lt;br /&gt;&lt;br /&gt;func Bootstrap() error {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;hellip;&lt;br /&gt;&amp;nbsp; &amp;nbsp; path := getRootDirPath()&lt;br /&gt;&amp;nbsp; &amp;nbsp; if err := setupMongo(path); err != nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;return err&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;hellip;&lt;br /&gt;}&lt;/pre&gt;&lt;/span&gt;Now if we want to test Bootstrap, we can mock out the setupMongo function thusly:&lt;br /&gt;&lt;pre style=&#34;tab-size: 4;&#34;&gt;&lt;span style=&#34;TRACE&#34;&gt;// in startup/bootstrap_test.go&lt;br /&gt;package startup&lt;br /&gt;&lt;br /&gt;type fakeSetup struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; path string&lt;br /&gt;&amp;nbsp; &amp;nbsp; err error&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;func (f *fakeSetup) setup(path string) error {&lt;br /&gt;&amp;nbsp; &amp;nbsp; f.path = path&lt;br /&gt;&amp;nbsp; &amp;nbsp; return f.err&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;TestBootstrap(t *testing.T) {&lt;br /&gt;&amp;nbsp; &amp;nbsp; f := &amp;amp;fakeSetup{ err: errors.New(&amp;ldquo;Failed!&amp;rdquo;) }&lt;br /&gt;&amp;nbsp; &amp;nbsp; // this mocks out the function that Bootstrap() calls&lt;br /&gt;&amp;nbsp; &amp;nbsp; setupMongo = f.setup&lt;br /&gt;&amp;nbsp; &amp;nbsp; err := Bootstrap()&lt;br /&gt;&amp;nbsp; &amp;nbsp; if err != f.err {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; t.Fail(&amp;ldquo;Error from setupMongo not returned.  Expected %v, got %v&amp;rdquo;, f.err, err)&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; expPath := getPath()&lt;br /&gt;&amp;nbsp; &amp;nbsp; if f.path != expPath {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; t.Fail(&amp;ldquo;Path not correctly passed into setupMongo. Expected %q, got %q&amp;rdquo;, expPath, f.path)&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; // and then try again with f.err == nil, you get the idea&lt;br /&gt;}&lt;/pre&gt;&lt;/span&gt;Now we have full control over what happens in the setupMongo function, we can record the parameters that are passed into it, what it returns, and test that Bootstrap is at least using the API of the function correctly.&lt;br /&gt;&lt;br /&gt;Obviously, we need tests elsewhere for install.SetupMongodb to make sure it does the right thing, but those can be tests internal to the install package, which can use non-exported fields and functions to effectively test the logic that would be impossible from an external package (like the setup package).  Using this mocking means that we don&amp;rsquo;t have to worry about setting up an environment that allows us to test SetupMongodb when we really only want to test Bootstrap. &amp;nbsp;We can just stub out the function and test that Bootstrap does everything correctly, and trust that SetupMongodb works because it&amp;rsquo;s tested in its own package.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Effective Godoc</title>
      <link>https://npf.io/2014/04/effective-godoc/</link>
      <pubDate>Tue, 01 Apr 2014 06:43:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>https://npf.io/2014/04/effective-godoc/</guid>
      <description>&lt;p&gt;I started to write a blog post about how to get the most out of godoc, with examples in a repo, and then realized I could just write the whole post as godoc on the repo, so that&amp;rsquo;s what I did. &amp;nbsp;Feel free to send pull requests if there&amp;rsquo;s anything you see that could be improved.&lt;br /&gt;&lt;br /&gt;I actually learned quite a lot writing this article, by exploring all the nooks and crannies of Go&amp;rsquo;s documentation generation. &amp;nbsp;Hopefully you&amp;rsquo;ll learn something too.&lt;br /&gt;&lt;br /&gt;Either view the documentation on godoc.org:&lt;br /&gt;&lt;br /&gt;&lt;a href=&#34;https://godoc.org/github.com/natefinch/godocgo&#34;&gt;https://godoc.org/github.com/natefinch/godocgo&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;or view it locally using the godoc tool:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&#34;background-color: whitesmoke; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px; border-top-left-radius: 4px; border-top-right-radius: 4px; border: 1px solid rgb(204, 204, 204); box-sizing: border-box; color: #333333; font-family: Monaco, Menlo, Consolas, &#39;Courier New&#39;, monospace; font-size: 13px; line-height: 1.428571429; margin-bottom: 10px; overflow: auto; padding: 9.5px; word-break: normal; word-wrap: normal;&#34;&gt;go get code.google.com/p/go.tools/cmd/godoc&lt;br /&gt;go get github.com/natefinch/godocgo&lt;br /&gt;godoc -http=:8080&lt;/pre&gt;&lt;br /&gt;Then open a browser to &lt;a href=&#34;http://localhost:8080/pkg/github.com/natefinch/godocgo&#34;&gt;http://localhost:8080/pkg/github.com/natefinch/godocgo&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;Enjoy!&lt;/p&gt;
</description>
    </item>
    
    
  </channel>
</rss>