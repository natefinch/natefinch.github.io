<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>npf.io</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://npf.io/tags/programming/index.xml/</link>
    <language>en-us</language>
    <author>Nate Finch</author>
    <copyright>2014 Nate Finch</copyright>
    <updated>Tue, 14 Oct 2014 10:46:28 EDT</updated>
    
    
    <item>
      <title>Why Everyone Hates Go</title>
      <link>http://npf.io/2014/10/why-everyone-hates-go/</link>
      <pubDate>Tue, 14 Oct 2014 10:46:28 EDT</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/10/why-everyone-hates-go/</guid>
      <description>&lt;p&gt;Obviously, not &lt;em&gt;everyone&lt;/em&gt; hates Go.  But there was a &lt;a href=&#34;https://www.quora.com/Why-does-Go-seem-to-be-the- most-heavily-
criticised-among-the-newer-programming-languages?srid=uCiY&amp;amp;share=1&#34;&gt;quora
question&lt;/a&gt; recently
about why everyone critizes Go so much. (sorry, I don&amp;rsquo;t normally post links to
Quora, but it was the motivator for this post) Even before I saw the answers to
the question, I knew what they&amp;rsquo;d consist of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Go is a language stuck in the 70&amp;rsquo;s.&lt;/li&gt;
&lt;li&gt;Go ignores 40 years of programming language research.&lt;/li&gt;
&lt;li&gt;Go is a language for blue collar (mediocre) developers.&lt;/li&gt;
&lt;li&gt;Gophers are ok with working in Java 1.0.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unfortunately, the answers to the questions were more concerned with explaining
why Go is &amp;ldquo;bad&amp;rdquo;, rather than why this gets under so many people&amp;rsquo;s skin.&lt;/p&gt;

&lt;p&gt;When reading the answers I had a eureka moment, and I realized why it is. So
here&amp;rsquo;s my answer to the same question. This is why Go is so heavily criticized,
not why Go is &amp;ldquo;bad&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s two awesome posts that inform my answer: Paul Graham&amp;rsquo;s
&lt;a href=&#34;http://www.paulgraham.com/identity.html&#34;&gt;post&lt;/a&gt; about keeping your identity
small, and Kathy Sierra&amp;rsquo;s &lt;a href=&#34;http://seriouspony.com/trouble-at-the-koolaid-
point&#34;&gt;post&lt;/a&gt; about the Koolaid point. I encourage you to read those two posts, as
they&amp;rsquo;re both very informative.  I hesitate to compare the horrific things that
happen to women online with the pedantry of flamewars about programming
languages, but the Koolaid Point is such a valid metaphor that I wanted to link
to the article.&lt;/p&gt;

&lt;p&gt;Paul says&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;people can never have a fruitful argument about
something that&amp;rsquo;s part of their identity&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;i.e.&lt;/em&gt; the subject hits too close to home,
and their response becomes emotional rather than logical.&lt;/p&gt;

&lt;p&gt;Kathy says&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;the hate wasn’t so much about the product/brand but that &lt;em&gt;other people were falling for it&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;i.e.&lt;/em&gt; they&amp;rsquo;d drunk the kool-aid.&lt;/p&gt;

&lt;p&gt;Go is the only recent language that takes the aforementioned 40 years of
programming language research and tosses it out the window. Other new languages
at least try to keep up with the Jones - Clojure, Scala, Rust - all try to
incorporate &amp;ldquo;modern programming theory&amp;rdquo; into their design. Go actively tries
not to. There is no pattern matching, there&amp;rsquo;s no borrowing, there&amp;rsquo;s no pure
functional programming, there&amp;rsquo;s no immutable variables, there&amp;rsquo;s no option types,
there&amp;rsquo;s no exceptions, there&amp;rsquo;s no classes, there&amp;rsquo;s no generics&amp;hellip;. there&amp;rsquo;s a lot
Go doesn&amp;rsquo;t have. And in the beginning this was enough to merely earn it scorn.
Even I am guilty of this. When I first heard about Go, I thought &amp;ldquo;What? No
exceptions? Pass.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;But then something happened - people started &lt;em&gt;using&lt;/em&gt; it. And liking it. And
building big projects with it. This is the Koolaid-point - where people have
started to drink the Koolaid and get fooled into thinking Go is a good
language. And this is where the scorn turns into derision and attacks on the
character of the people using it.&lt;/p&gt;

&lt;p&gt;The most vocal Go detractors are those developers who write in ML-derived
languages (Haskel, Rust, Scala, &lt;em&gt;et al&lt;/em&gt;) who have tied their preferred
programming language into their identity. The mere existence of Go says
&amp;ldquo;your views on what makes a good programming language are wrong&amp;rdquo;. And the more
people that use and like Go, the more strongly they feel that they&amp;rsquo;re being told
their choice of programming language - and therefore their identity - is wrong.&lt;/p&gt;

&lt;p&gt;Note that basically no one in the Go community actually says this. But the Go
philosophy of simplicity and pragmatism above all else is the polar opposite of
what those languages espouse (in which complexity in the language is ok because
it enforces correctness in the code). This is insulting to the people who tie
their identity to that language. Whenever a post on Go makes it to the front
page of Hacker News, it is an affront to everything they hold dear, and so you
get comments like Go developers are stuck in the 70&amp;rsquo;s, or is only for blue-collar devs.&lt;/p&gt;

&lt;p&gt;So, this is why I think people are so much more vocal about their dislike of Go:
because it challenges their identity, and other people are falling for it. This
is also why these posts so often mention Google and how the language would have
died without them. Google is now the koolaid dispenser. The fact that they
are otherwise generally thought of as a very talented pool of developers means
that it is simultaneously more outrageous that they are fooling people and more
insulting that their language flies in the face of ML-derived languages.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt;  I removed the &amp;ldquo;panties in a bunch&amp;rdquo; comment, since I was (correctly)
scolded for being sexist, not to mention unprofessional.  My apologies to
anyone I offended.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Intro to TOML</title>
      <link>http://npf.io/2014/08/intro-to-toml/</link>
      <pubDate>Sat, 16 Aug 2014 07:31:51 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/08/intro-to-toml/</guid>
      <description>

&lt;p&gt;TOML stands for Tom&amp;rsquo;s Own Minimal Language.  It is a configuration language
vaguely similar to YAML or property lists, but far, far better.  But before we
get into it in detail, let&amp;rsquo;s look back at what came before.&lt;/p&gt;

&lt;h3 id=&#34;toc_0&#34;&gt;Long Ago, In A Galaxy Far, Far Away&lt;/h3&gt;

&lt;p&gt;Since the beginning of computing, people have needed a way to configure
their software.  On Linux, this generally is done in text files.  For simple
configurations, good old foo = bar works pretty well.  One setting per line,
name on the left, value on the right, separated by an equals.  Great.  But when
your configuration gets more complicated, this quickly breaks down.  What if you
need a value that is more than one line?  How do you indicate a value should be
parsed as a number instead of a string?  How do you namespace related
configuration values so you don&amp;rsquo;t need ridiculously long names to prevent
collisions?&lt;/p&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;The Dark Ages&lt;/h3&gt;

&lt;p&gt;In the 90&amp;rsquo;s, we used XML.  And it sucked.  XML is verbose, it&amp;rsquo;s hard for humans
to read and write, and it still doesn&amp;rsquo;t solve a lot of the problems above (like
how to specify the type of a value).  In addition, the XML spec is huge,
processing is very complicated, and all the extra features invite abuse and
overcomplication.&lt;/p&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;Enlightenment&lt;/h3&gt;

&lt;p&gt;In the mid 2000&amp;rsquo;s, JSON came to popularity as a data exchange format, and it was
so much better than XML.  It had real types, it was easy for programs to
process, and you didn&amp;rsquo;t have to write a spec on what values should get processed
in what way (well, mostly).  It was sigificantly less verbose than XML.  But it
is a format intended for computers to read and write, not humans.  It is a pain
to write by hand, and even pretty-printed, it can be hard to read and the
compact data format turns into a nested mess of curly braces.  Also, JSON is not
without its problems&amp;hellip; for example, there&amp;rsquo;s no date type, there&amp;rsquo;s no support
for comments, and all numbers are floats.&lt;/p&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;A False Start&lt;/h3&gt;

&lt;p&gt;YAML came to popularity some time after JSON as a more human-readable format,
and its &lt;code&gt;key: value&lt;/code&gt; syntax and pretty indentation is definitely a lot easier on
the eyes than JSON&amp;rsquo;s nested curly-braces.  However, YAML trades ease of reading
for difficulty in writing.  Indentation as delimiters is fraught with error&amp;hellip;
figuring out how to get multiple lines of data into any random value is an
exercise in googling and trial &amp;amp; error.&lt;/p&gt;

&lt;p&gt;The YAML spec is also ridiculously long.  100% compatible parsers are very
difficult to write.  Writing YAML by hand is a ridden with landmines of corner
cases where your choice of names or values happens to hit a reserved word or
special marker.  It does support comments, though.&lt;/p&gt;

&lt;h3 id=&#34;toc_4&#34;&gt;The Savior&lt;/h3&gt;

&lt;p&gt;On February 23, 2013, Tom Preston-Werner (former CEO of GitHub) made his first
commit to &lt;a href=&#34;https://github.com/toml-lang/toml&#34;&gt;https://github.com/toml-lang/toml&lt;/a&gt;.  TOML stands for Tom&amp;rsquo;s Obvious,
Minimal Language.  It is a language designed for configuring software.  Finally.&lt;/p&gt;

&lt;p&gt;TOML takes inspiration from all of the above (well, except XML) and even gets
some of its syntax from Microsoft&amp;rsquo;s INI files.  It is easy to write by hand and
easy to read.  The spec is short and understandable by mere humans, and it&amp;rsquo;s
fairly easy for computers to parse.  It supports comments, has first class
dates, and supports both integers and floats.  It is generally insensitive to
whitespace, without requiring a ton of delimiters.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s dive in.&lt;/p&gt;

&lt;h3 id=&#34;toc_5&#34;&gt;The Basics&lt;/h3&gt;

&lt;p&gt;The basic form is key = value&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Comments start with hash
foo = &amp;quot;strings are in quotes and are always UTF8 with escape codes: \n \u00E9&amp;quot;

bar = &amp;quot;&amp;quot;&amp;quot;multi-line strings
use three quotes&amp;quot;&amp;quot;&amp;quot;

baz = &#39;literal\strings\use\single\quotes&#39;

bat = &#39;&#39;&#39;multiline\literals\use
three\quotes&#39;&#39;&#39;

int = 5 # integers are just numbers
float = 5.0 # floats have a decimal point with numbers on both sides

date = 2006-05-27T07:32:00Z # dates are ISO 8601 full zulu form

bool = true # good old true and false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One cool point:  If the first line of a multiline string (either literal or not)
is a line return, it will be trimmed.  So you can make your big blocks of text
start on the line after the name of the value and not need to worry about the
extraneous newline at the beginning of your text:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;preabmle = &amp;quot;&amp;quot;&amp;quot;
We the people of the United States, in order to form a more perfect union,
establish justice, insure domestic tranquility, provide for the common defense,
promote the general welfare, and secure the blessings of liberty to ourselves
and our posterity, do ordain and establish this Constitution for the United
States of America.&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_6&#34;&gt;Lists&lt;/h3&gt;

&lt;p&gt;Lists (arrays) are signified with brackets and delimited with commas.  Only
primitives are allowed in this form, though you may have nested lists.  The
format is forgiving, ignoring whitespace and newlines, and yes, the last comma
is optional (thank you!):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo = [ &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot;
        &amp;quot;bat&amp;quot;
]

nums = [ 1, 2, ]

nested = [[ &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;], [1, 2]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I love that the format is forgiving of whitespace and that last comma.  I like
that the arrays are all of a single type, but allowing mixed types of sub-arrays
bugs the heck out of me.&lt;/p&gt;

&lt;h3 id=&#34;toc_7&#34;&gt;Now we get crazy&lt;/h3&gt;

&lt;p&gt;What&amp;rsquo;s left?  In JSON there are objects, in YAML there are associative arrays&amp;hellip;
in common parlance they are maps or dictionaries or hash tables.  Named
collections of key/value pairs.&lt;/p&gt;

&lt;p&gt;In TOML they are called tables and look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# some config above
[table_name]
foo = 1
bar = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Foo and bar are keys in the table called table_name.  Tables have to be at the
end of the config file. Why?  because there&amp;rsquo;s no end delimiter.  All keys under
a table declaration are associated with that table, until a new table is
declared or the end of the file.  So declaring two tables looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# some config above
[table1]
foo = 1
bar = 2

[table2]
	foo = 1
	baz = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The declaration of table2 defines where table1 ends.  Note that you can indent
the values if you want, or not.  TOML doesn&amp;rsquo;t care.&lt;/p&gt;

&lt;p&gt;If you want nested tables, you can do that, too.  It looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[table1]
	foo = &amp;quot;bar&amp;quot;

[table1.nested_table]
	baz = &amp;quot;bat&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;nested_table&lt;/code&gt; is defined as a value in &lt;code&gt;table1&lt;/code&gt; because its name starts with
&lt;code&gt;table1.&lt;/code&gt;.  Again, the table goes until the next table definition, so &lt;code&gt;baz=&amp;quot;bat&amp;quot;&lt;/code&gt;
is a value in &lt;code&gt;table1.nested_table&lt;/code&gt;.  You can indent the nested table to make it
more obvious, but again, all whitespace is optional:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[table1]
	foo = &amp;quot;bar&amp;quot;

	[table1.nested_table]
		baz = &amp;quot;bat&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is equivalent to the JSON:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ 
	&amp;quot;table1&amp;quot; : {
		&amp;quot;foo&amp;quot; : &amp;quot;bar&amp;quot;,
		&amp;quot;nested_table&amp;quot; : {
			&amp;quot;baz&amp;quot; : &amp;quot;bat&amp;quot;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having to retype the parent table name for each sub-table is kind of annoying,
but I do like that it is very explicit.  It also means that ordering and
indenting and delimiters don&amp;rsquo;t matter.  You don&amp;rsquo;t have to declare parent tables
if they&amp;rsquo;re empty, so you can do something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[foo.bar.baz]
bat = &amp;quot;hi&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which is the equivalent to this JSON:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
	&amp;quot;foo&amp;quot; : {
		&amp;quot;bar&amp;quot; : {
			&amp;quot;baz&amp;quot; : {
				&amp;quot;bat&amp;quot; : &amp;quot;hi&amp;quot;
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_8&#34;&gt;Last but not least&lt;/h3&gt;

&lt;p&gt;The last thing is arrays of tables, which are declared with double brackets
thusly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[[comments]]
author = &amp;quot;Nate&amp;quot;
text = &amp;quot;Great Article!&amp;quot;

[[comments]]
author = &amp;quot;Anonymous&amp;quot;
text = &amp;quot;Love it!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is equivalent to the JSON:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
	&amp;quot;comments&amp;quot; : [
		{
			&amp;quot;author&amp;quot; : &amp;quot;Nate&amp;quot;,
			&amp;quot;text&amp;quot; : Great Article!&amp;quot;
		},
		{
			&amp;quot;author&amp;quot; : &amp;quot;Anonymous&amp;quot;,
			&amp;quot;text&amp;quot; : Love It!&amp;quot;
		}
	]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arrays of tables inside another table get combined in the way you&amp;rsquo;d expect, like
[[table1.array]].&lt;/p&gt;

&lt;p&gt;TOML is very permissive here. Because all tables have very explicitly defined
parentage, the order they&amp;rsquo;re defined in doesn&amp;rsquo;t matter. You can have tables (and
entries in an array of tables) in whatever order you want.  This is totally
acceptable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[[comments]]
author = &amp;quot;Anonymous&amp;quot;
text = &amp;quot;Love it!&amp;quot;

[foo.bar.baz]
bat = &amp;quot;hi&amp;quot;

[foo.bar]
howdy = &amp;quot;neighbor&amp;quot;

[[comments]]
author = &amp;quot;Anonymous&amp;quot;
text = &amp;quot;Love it!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, it generally makes sense to actually order things in a more organized
fashion, but it&amp;rsquo;s nice that you can&amp;rsquo;t shoot yourself in the foot if you reorder
things &amp;ldquo;incorrectly&amp;rdquo;.&lt;/p&gt;

&lt;h3 id=&#34;toc_9&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;That&amp;rsquo;s TOML.  It&amp;rsquo;s pretty awesome.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a &lt;a href=&#34;https://github.com/toml-lang/toml#implementations&#34;&gt;list of parsers&lt;/a&gt;
on the TOML page on github for pretty much whatever language you want.  I
recommend &lt;a href=&#34;http://github.com/BurntSushi/toml&#34;&gt;BurntSushi&lt;/a&gt;&amp;rsquo;s for Go, since it
works just like the built-in parsers.&lt;/p&gt;

&lt;p&gt;It is now my default configuration language for all the applications I write.&lt;/p&gt;

&lt;p&gt;The next time you write an application that needs some configuration, take a
look at TOML.  I think your users will thank you.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>CI for Windows Go Packages with AppVeyor</title>
      <link>http://npf.io/2014/07/ci-for-windows-go-packages-with-appveyor/</link>
      <pubDate>Wed, 09 Jul 2014 17:43:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/07/ci-for-windows-go-packages-with-appveyor/</guid>
      <description>&lt;p&gt;I recently needed to update my &lt;a href=&#34;https://github.com/natefinch/npipe&#34; target=&#34;_blank&#34;&gt;npipe&lt;/a&gt; package, and since I want it to be production quality, that means setting up CI, so that people using my package can know it&amp;rsquo;s passing tests. &amp;nbsp;Normally I&amp;rsquo;d use Travis CI or Drone.io for that, but npipe is a Windows-only Go package, and neither of the aforementioned services support running tests on Windows.&lt;br /&gt;&lt;br /&gt;With some googling, I saw that &lt;a href=&#34;https://twitter.com/nathany&#34; target=&#34;_blank&#34;&gt;Nathan Youngman&lt;/a&gt;&amp;nbsp;had worked with&amp;nbsp;&lt;a href=&#34;http://www.appveyor.com/&#34; target=&#34;_blank&#34;&gt;AppVeyor&lt;/a&gt;&amp;nbsp;to add Go support to their CI system. &amp;nbsp;The example on the blog talks about making a build.cmd file in your repo to enable Go builds, but I found that you can easily set up a Go build without having to put CI-specific files in your repo.&lt;br /&gt;&lt;br /&gt;To get started with AppVeyor, just log into their site and tell it where to get your code (I logged in with Github, and it was easy to specify what repo of mine to test). &amp;nbsp;Once you choose the repo, go to the Settings page on AppVeyor for that repo. &amp;nbsp;Under the Environment tab on the left, set the clone directory to C:\GOPATH\src&amp;amp;lt;your import path&amp;gt; and set an environment variable called GOPATH to C:\GOPATH. &amp;nbsp;Under the build tab, set the build type to &amp;ldquo;SCRIPT&amp;rdquo; and the script type to &amp;ldquo;CMD&amp;rdquo;, and make the contents of the script &lt;pre style=&#34;tab-size: 4;&#34;&gt;go get -v -d -t &amp;lt;your import path&amp;gt;/&amp;hellip;&lt;/pre&gt; (this will download the dependencies for your package). &amp;nbsp;In the test tab, set the test type to &amp;ldquo;SCRIPT&amp;rdquo;, the script type to &amp;ldquo;CMD&amp;rdquo; and the script contents to &lt;pre style=&#34;tab-size: 4;&#34;&gt;go test -v -cover ./&amp;hellip;&lt;/pre&gt; &amp;nbsp;(this will run all the tests in verbose mode and also output the test coverage).&lt;br /&gt;&lt;br /&gt;That&amp;rsquo;s pretty much it. &amp;nbsp;AppVeyor will automatically run a build on commits, like you&amp;rsquo;d expect. &amp;nbsp;You can watch the progress on a console output on their page, and get a pretty little badge from the badges page. &amp;nbsp;It&amp;rsquo;s free for open source projects, and seems relatively responsive from my admittedly limited experience.&lt;br /&gt;&lt;br /&gt;This is a great boon for Go developers, so you can be sure your code builds and passes tests on Windows, with very little work to set it up. &amp;nbsp;I&amp;rsquo;m probably going to add this to all my production repos, even the ones that aren&amp;rsquo;t Windows-only, to ensure my code works well on Windows as well as Linux.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Intro to BoltDB: Painless Performant Persistence</title>
      <link>http://npf.io/2014/07/intro-to-boltdb-painless-performant-persistence/</link>
      <pubDate>Mon, 07 Jul 2014 08:25:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/07/intro-to-boltdb-painless-performant-persistence/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://github.com/boltdb/bolt&#34; target=&#34;_blank&#34;&gt;BoltDB&lt;/a&gt; is a pure Go persistence solution that saves data to a memory mapped file.  I call it a persistence solution and not a database, because the word database has a lot of baggage associated with it that doesn&amp;rsquo;t apply to bolt. And that lack of baggage is what makes bolt so awesome.&lt;br /&gt;&lt;br /&gt;Bolt is just a Go package.  There&amp;rsquo;s nothing you need to install on the system, no configuration to figure out before you can start coding, nothing.  You just go get github.com/boltdb/bolt and then import &amp;ldquo;github.com/boltdb/bolt&amp;rdquo;. &lt;br /&gt;&lt;br /&gt;All you need to fully use bolt as storage is a file name.  This is fantastic from both a developer&amp;rsquo;s point of view, and a user&amp;rsquo;s point of view.  I don&amp;rsquo;t know about you, but I&amp;rsquo;ve spent months of work time over my career configuring and setting up databases and debugging configuration problems, users and permissions and all the other crap you get from more traditional databases like Postgres and Mongo.  There&amp;rsquo;s none of that with bolt.  No users, no setup, just a file name.  This is also a boon for users of your application, because &lt;em&gt;they&lt;/em&gt; don&amp;rsquo;t have to futz with all that crap either.&lt;br /&gt;&lt;br /&gt;Bolt is not a relational database.  It&amp;rsquo;s not even a document store, though you can sort of use it that way.  It&amp;rsquo;s really just a key/value store&amp;hellip; but don&amp;rsquo;t worry if you don&amp;rsquo;t really know what that means or how you&amp;rsquo;d use that for storage.  It&amp;rsquo;s super simple and it&amp;rsquo;s incredibly flexible.  Let&amp;rsquo;s take a look.&lt;br /&gt;&lt;br /&gt;Storage in bolt is divided into buckets.  A bucket is simply a named collection of key/value pairs, just like Go&amp;rsquo;s map.  The name of the bucket, the keys, and the values are all of type []byte.  Buckets can contain other buckets, also keyed by a []byte name. &lt;br /&gt;&lt;br /&gt;&amp;hellip; that&amp;rsquo;s it.  No, really, that&amp;rsquo;s it.  Bolt is basically a bunch of nested maps.  And this simplicity is what makes it so easy to use.  There&amp;rsquo;s no tables to set up, no schemas, no complex querying language to struggle with.  Let&amp;rsquo;s look at a bolt hello world:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;package main&lt;br /&gt;&lt;br /&gt;import (&lt;br /&gt;    &amp;ldquo;fmt&amp;rdquo;&lt;br /&gt;    &amp;ldquo;log&amp;rdquo;&lt;br /&gt;&lt;br /&gt;    &amp;ldquo;github.com/boltdb/bolt&amp;rdquo;&lt;br /&gt;)&lt;br /&gt;&lt;br /&gt;var world = []byte(&amp;ldquo;world&amp;rdquo;)&lt;br /&gt;&lt;br /&gt;func main() {&lt;br /&gt;    db, err := bolt.Open(&amp;ldquo;/home/nate/foo/bolt.db&amp;rdquo;, 0644, nil)&lt;br /&gt;    if err != nil {&lt;br /&gt;        log.Fatal(err)&lt;br /&gt;    }&lt;br /&gt;    defer db.Close()&lt;br /&gt;&lt;br /&gt;    key := []byte(&amp;ldquo;hello&amp;rdquo;)&lt;br /&gt;    value := []byte(&amp;ldquo;Hello World!&amp;rdquo;)&lt;br /&gt;&lt;br /&gt;    // store some data&lt;br /&gt;    err = db.Update(func(tx *bolt.Tx) error {&lt;br /&gt;        bucket, err := tx.CreateBucketIfNotExists(world)&lt;br /&gt;        if err != nil {&lt;br /&gt;            return err&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        err = bucket.Put(key, value)&lt;br /&gt;        if err != nil {&lt;br /&gt;            return err&lt;br /&gt;        }&lt;br /&gt;        return nil&lt;br /&gt;    })&lt;br /&gt;&lt;br /&gt;    if err != nil {&lt;br /&gt;        log.Fatal(err)&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    // retrieve the data&lt;br /&gt;    err = db.View(func(tx *bolt.Tx) error {&lt;br /&gt;        bucket := tx.Bucket(world)&lt;br /&gt;        if bucket == nil {&lt;br /&gt;            return fmt.Errorf(&amp;ldquo;Bucket %q not found!&amp;rdquo;, world)&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        val := bucket.Get(key)&lt;br /&gt;        fmt.Println(string(val))&lt;br /&gt;&lt;br /&gt;        return nil&lt;br /&gt;    })&lt;br /&gt;&lt;br /&gt;    if err != nil {&lt;br /&gt;        log.Fatal(err)&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;// output:&lt;br /&gt;// Hello World!&lt;/pre&gt;&lt;div&gt;&lt;/div&gt;I know what you&amp;rsquo;re thinking - that seems kinda long.  But keep in mind, I fully handled all errors in at least a semi-proper way, and we&amp;rsquo;re doing all this:&lt;br /&gt;&lt;br /&gt;1.) creating a database &lt;br /&gt;2.) creating some structure (the &amp;ldquo;world&amp;rdquo; bucket)&lt;br /&gt;3.) storing data to the structure&lt;br /&gt;4.) retrieving data from the structure.&lt;br /&gt;&lt;br /&gt;I think that&amp;rsquo;s not too bad in 54 lines of code.&lt;br /&gt;&lt;br /&gt;So let&amp;rsquo;s look at what that example is really doing.  First we call bolt.Open to get the database.  This will create the file if necessary, or open it if it exists.&lt;br /&gt;&lt;br /&gt;All reads from or writes to the bolt database must be done within a transaction. You can have as many Readers in read-only transactions at the same time as you want, but only one Writer in a writable transaction at a time (readers maintain a consistent view of the DB while writers are writing).&lt;br /&gt;&lt;br /&gt;To begin, we call db.Update, which takes a function to which it&amp;rsquo;ll pass a bolt.Tx - bolt&amp;rsquo;s transaction object.  We then create a Bucket (since all data in bolt lives in buckets), and add our key/value pair to it.  After the write transaction finishes, we start a read- only transaction with DB.View, and get the values back out.&lt;br /&gt;&lt;br /&gt;What&amp;rsquo;s great about bolt&amp;rsquo;s transaction mechanism is that it&amp;rsquo;s super simple - the scope of the function is the scope of the transaction.  If the function passed to Update returns nil, all updates from the transaction are atomically stored to the database.  If the function passed to Update returns an error, the transaction is rolled back.  This makes bolt&amp;rsquo;s transactions completely intuitive from a Go developer&amp;rsquo;s point of view.  You just exit early out of your function by returning an error as usual, and bolt Does The Right Thing.  No need to worry about manually rolling back updates or anything, just return an error.&lt;br /&gt;&lt;br /&gt;The only other basic thing you may need is to iterate over key/value pairs in a Bucket, in which case, you just call bucket.Cursor(), which returns a Cursor value, which has functions like Next(), Prev() etc that return a key/value pair and work like you&amp;rsquo;d expect.&lt;br /&gt;&lt;br /&gt;There&amp;rsquo;s a lot more to the bolt API, but most of the rest of it is more about database statistics and some stuff for more advanced usage scenarios&amp;hellip; but the above is all you really need to know to start storing data in a bolt database.&lt;br /&gt;&lt;br /&gt;For a more complex application, just storing strings in the database may not be sufficient, but that&amp;rsquo;s ok, Go has your back there, too.  You can easily use encoding/json or encoding/gob to serialize structs into the database, keyed by a unique name or id.  This is what makes it easy for bolt to go from a key/value store to a document store - just have one bucket per document type.  Again, the benefit of bolt is low barrier of entry.  You don&amp;rsquo;t have to figure out a whole database schema or install anything to be able to just start dumping data to disk in a performant and manageable way.&lt;br /&gt;&lt;br /&gt;The main drawback of bolt is that there are no queries.  You can&amp;rsquo;t say &amp;ldquo;give me all foo objects with a name that starts with bar&amp;rdquo;.  You &lt;i&gt;could&lt;/i&gt; make your own index in the database and keep it up to date manually.  This could be as easy as a slice of IDs serialized into an &amp;ldquo;indices&amp;rdquo; bucket for a particular query. Obviously, this is where you start getting into the realm of developing your own relational database, but if you don&amp;rsquo;t go overboard, it can be nice that all this code is just that - code.  It&amp;rsquo;s not queries in some external DSL, it&amp;rsquo;s just code like you&amp;rsquo;d write for an in-memory data store.&lt;br /&gt;&lt;br /&gt;Bolt is not for every application.  You must understand your application&amp;rsquo;s needs and if bolt&amp;rsquo;s key/value style will be sufficient to fulfill those needs.  If it is, I think you&amp;rsquo;ll be very happy to use such a simple data store with so little mental overhead.&lt;br /&gt;&lt;br /&gt;[edited to clarify reader/writer relationship]   Bonus Gob vs. Json benchmark for storing structs in Bolt: &lt;pre&gt;&lt;br /&gt;BenchmarkGobEncode  1000000       2191 ns/op&lt;br /&gt;BenchmarkJsonEncode   500000       4738 ns/op&lt;br /&gt;BenchmarkGobDecode  1000000       2019 ns/op&lt;br /&gt;BenchmarkJsonDecode   200000      12993 ns/op&lt;br /&gt;&lt;/pre&gt;Code: &lt;a href=&#34;http://play.golang.org/p/IvfDUGBpJ6&#34;&gt;http://play.golang.org/p/IvfDUGBpJ6&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Autogenerate docs with this one dumb trick</title>
      <link>http://npf.io/2014/06/autogenerate-docs-with-this-one-dumb-trick/</link>
      <pubDate>Tue, 17 Jun 2014 05:59:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/06/autogenerate-docs-with-this-one-dumb-trick/</guid>
      <description>&lt;p&gt;Yesterday, I was trying to think of a way of automating some doc generation for my go packages.  The specific task I wanted to automate was updating a badge in my package&amp;rsquo;s README to show the test coverage.  What I wanted was a way to run go test -cover, parse the results, and put the result in the correct spot of my README.  My first thought was to write an application that would do that for me &amp;hellip; but then I&amp;rsquo;d have to run that &lt;i&gt;instead&lt;/i&gt; of go test.  What I realized I wanted was something that was &amp;ldquo;compatible with go test&amp;rdquo; - i.e. I want to run go test and not have to remember to run some special other command.&lt;br /&gt;&lt;br /&gt;And that&amp;rsquo;s when it hit me:  What is a test in Go?  A test is a Go function that gets run when you run &amp;ldquo;go test&amp;rdquo;. &amp;nbsp;Nothing says your test has to actually test anything. &amp;nbsp;And nothing prevents your test from doing something permanent on your machine (in fact we usually have to bend over backwards to make sure our tests &lt;i&gt;don&amp;rsquo;t&lt;/i&gt;&amp;nbsp;do anything permanent. &amp;nbsp;You can just write a test function that updates the docs for you.&lt;br /&gt;&lt;br /&gt;I actually quite like this technique. &amp;nbsp;I often have some manual tasks after updating my code - usually updating the docs in the README with changes to the API, or changing the docs to show new CLI flags, etc. &amp;nbsp;And there&amp;rsquo;s one thing I always do after I update my code - and that&amp;rsquo;s run &amp;ldquo;go test&amp;rdquo;. &amp;nbsp;If that also updates my docs, all the better.&lt;br /&gt;&lt;br /&gt;This is how covergen was born. &amp;nbsp;&lt;a href=&#34;https://github.com/natefinch/covergen&#34;&gt;https://github.com/natefinch/covergen&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;Covergen is a particularly heinous example of a test that updates your docs. &amp;nbsp;The heinous part is that it actually doubles the time it takes to run your tests&amp;hellip; this is because that one test re-runs all the tests with -cover to get the coverage percent. &amp;nbsp;I&amp;rsquo;m not sure I&amp;rsquo;d actually release real code that used such a thing - doubling the time it takes to run your tests just to save a few seconds of copy and paste is pretty terrible.&lt;br /&gt;&lt;br /&gt;However, it&amp;rsquo;s a valid example of what you can do when you throw away testing convention and decide you want to write some code in a test that doesn&amp;rsquo;t actually test anything, and instead just runs some automated tasks that you want run whenever anyone runs go test. &amp;nbsp;Just make sure the result is idempotent so you&amp;rsquo;re not continually causing things to look modified to version control.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Diffing Go with Beyond Compare</title>
      <link>http://npf.io/2014/05/diffing-go-with-beyond-compare/</link>
      <pubDate>Wed, 14 May 2014 13:09:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/05/diffing-go-with-beyond-compare/</guid>
      <description>&lt;p&gt;I love Beyond Compare, it&amp;rsquo;s an awesome visual diff/merge tool. &amp;nbsp;It&amp;rsquo;s not free, but I don&amp;rsquo;t care, because it&amp;rsquo;s awesome. &amp;nbsp;However, there&amp;rsquo;s no built-in configuration for Go code, so I made one. &amp;nbsp;Not sure what the venn diagram of Beyond Compare users and Go users looks like, it might be that I&amp;rsquo;m the one point of crossover, but just in case I&amp;rsquo;m not, here&amp;rsquo;s the configuration file for Beyond Compare 3 for the Go programming language:&amp;nbsp;&lt;a href=&#34;http://play.golang.org/p/G6NWE0z1GC&#34;&gt;http://play.golang.org/p/G6NWE0z1GC&lt;/a&gt; &amp;nbsp;(please forgive the abuse of the Go playground)&lt;br /&gt;&lt;br /&gt;Just copy the text into a file and in Beyond Compare, go to Tools-&amp;gt;Import Settings&amp;hellip; and choose the file. &amp;nbsp;Please let me know if you have any troubles or suggested improvements.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Intro&#43;&#43; to Go Interfaces</title>
      <link>http://npf.io/2014/05/intro-to-go-interfaces/</link>
      <pubDate>Tue, 13 May 2014 07:08:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/05/intro-to-go-interfaces/</guid>
      <description>

&lt;h3 id=&#34;toc_0&#34;&gt;Standard Interface Intro&lt;/h3&gt;

&lt;p&gt;Go’s interfaces are one of it’s best features, but they’re also one of the most confusing for newbies.  This post will try to give you the understanding you need to use Go’s interfaces and not get frustrated when things don’t work the way you expect.  It’s a little long, but a bunch of that is just code examples.&lt;/p&gt;

&lt;p&gt;Go’s interfaces are different than interfaces in other languages, they are implicitly fulfilled.  This means that you never need to mark your type as explicitly implementing the interface (like class CFoo implements IFoo).  Instead, your type just needs to have the methods defined in the interface, and the compiler does the rest.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Walker interface {
    Walk(miles int)
}

type Camel struct {
    Name string
}

func (c Camel) Walk(miles int) {
     fmt.Printf(“%s is walking %v miles\n”, c.Name, miles)
}

func LongWalk(w Walker) {
     w.Walk(500)
     w.Walk(500)
}

func main() {
    c := Camel{“Bill”}
    LongWalk(c)
}

// prints
// Bill is walking 500 miles.
// Bill is walking 500 miles.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/erodX-JplO&#34;&gt;http://play.golang.org/p/erodX-JplO&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Camel implements the Walker interface, because it has a method named Walk that
takes an int and doesn’t return anything.  This means you can pass it into the
LongWalk function, even though you never specified that your Camel is a Walker.
In fact, Camel and Walker can live in totally different packages and never know
about one another, and this will still work if a third package decides to make a
Camel and pass it into LongWalk.&lt;/p&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;Non-Standard Continuation&lt;/h3&gt;

&lt;p&gt;This is where most tutorials stop, and where most questions and problems begin.
The problem is that you still don’t know how the interfaces actually work, and
since it’s not actually that complicated, let’s talk about that.&lt;/p&gt;

&lt;p&gt;What actually happens when you pass Camel into LongWalk?&lt;/p&gt;

&lt;p&gt;So, first off, you’re not passing Camel into LongWalk.  You’re actually
assigning c, a value of type Camel to a value w of type Walker, and w is what
you operate on in LongWalk.&lt;/p&gt;

&lt;p&gt;Under the covers, the Walker interface (like all interfaces), would look more or
less like this if it were in Go (the actual code is in C, so this is just a
really rough approximation that is easier to read).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Walker struct {
    type InterfaceType
    data *void
}

type InterfaceType struct {
    valtype *gotype
    func0 *func
    func1 *func
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All interfaces values are just two pointers - one pointer to information about
the interface type, and one pointer to the data from the value you passed into
the interface (a void in C-like languages… this should probably be Go’s
unsafe.Pointer, but I liked the explicitness of two actual *’s in the struct to
show it’s just two pointers).&lt;/p&gt;

&lt;p&gt;The InterfaceType contains a pointer to information about the type of the value
that you passed into the interface (valtype).  It also contains pointers to the
methods that are available on the interface.&lt;/p&gt;

&lt;p&gt;When you assign c to w, the compiler generates instructions that looks more or
less like this (it’s not actually generating Go, this is just an easier-to-read
approximation):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data := c
w := Walker{ 
    type: &amp;amp;InterfaceType{ 
              valtype: &amp;amp;typeof(c), 
              func0: &amp;amp;Camel.Walk 
          }
    data: &amp;amp;data
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you assign your Camel value c to the Walker value w, the Camel type is
copied into the interface value’s Type.valtype field.  The actual data in the
value of c is copied into a new place in memory, and w’s Data field points at
that memory location.&lt;/p&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;Implications of the Implementation&lt;/h3&gt;

&lt;p&gt;Now, let’s look at the implications of this code.  First, interface values are
very small - just two pointers.  When you assign a value to an interface, that
value gets copied once, into the interface, but after that, it’s held in a
pointer, so it doesn’t get copied again if you pass the interface around.&lt;/p&gt;

&lt;p&gt;So now you know why you don’t need to pass around pointers to interfaces -
they’re small anyway, so you don’t have to worry about copying the memory, plus
they hold your data in a pointer, so changes to the data will travel with the
interface.&lt;/p&gt;

&lt;h3 id=&#34;toc_3&#34;&gt;Interfaces Are Types&lt;/h3&gt;

&lt;p&gt;Let’s look at Walker again, this is important:&lt;/p&gt;

&lt;p&gt;type Walker interface&lt;/p&gt;

&lt;p&gt;Note that first word there: type.  Interfaces are types, just like string is a
type or Camel is a type.  They aren’t aliases, they’re not magic hand-waving,
they’re real types and real values which are distinct from the type and value
that gets assigned to them.&lt;/p&gt;

&lt;p&gt;Now, let’s assume you have this function:&lt;/p&gt;

&lt;p&gt;func LongWalkAll(walkers []Walker) {
    for _, w := range walkers {
        LongWalk(w)
    }
}&lt;/p&gt;

&lt;p&gt;And let’s say you have a caravan of Camels that you want to send on a long walk:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;caravan := []Camel{ Camel{“Bill”}, Camel{“Bob”}, Camel{“Steve”}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You want to pass caravan into LongWalkAll, will the compiler let you?  Nope.
Why is that?  Well, []Walker is a specific type, it’s a slice of values of type
Walker.  It’s not shorthand for “a slice of anything that matches the Walker
interface”.  It’s an actual distinct type, the way []string is different from
[]int.  The Go compiler will output code to assign a single value of Camel to a
single value of Walker.  That’s the only place it’ll help you out.  So, with
slices, you have to do it yourself:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;walkers := make([]Walker, len(caravan))
for n, c := range caravan {
    walkers[n] = c
}
LongWalkAll(walkers)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, there’s a better way if you know you’ll just need the caravan for
passing into LongWalkAll:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;caravan := []Walker{ Camel{“Bill”}, Camel{“Bob”}, Camel{“Steve”}}
LongWalkAll(caravan)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this goes for any type which includes an interface as part of its
definition: there’s no automatic conversion of your func(Camel) into
func(Walker) or map[string]Camel into map[string]Walker.  Again, they’re totally
different types, they’re not shorthand, and they’re not aliases, and they’re not
just a pattern for the compiler to match.&lt;/p&gt;

&lt;p&gt;Interfaces and the Pointers That Satisfy Them&lt;/p&gt;

&lt;p&gt;What if Camel’s Walk method had this signature instead?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Camel) Walk(miles int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This line says that the type *Camel has a function called Walk.  This is
important: *Camel is a type.  It’s the “pointer to a Camel” type.  It’s a
distinct type from (non-pointer) Camel.  The part about it being a pointer is
part of its type.  The Walk method is on the type *Camel.  The Walk method (in
this new incarnation) is not on the type Camel. This becomes important when you
try to assign it to an interface.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c := Camel{“Bill”}
LongWalk(c)

// compiler output:
cannot use c (type Camel) as type Walker in function argument:
 Camel does not implement Walker (Walk method has pointer receiver)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To pass a Camel into LongWalk now, you need to pass in a pointer to a Camel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c := &amp;amp;Camel{“Bill”}
LongWalk(c)

or

c := Camel{“Bill”}
LongWalk(&amp;amp;c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this true even though you can still call Walk directly on Camel:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c := Camel{“Bill”}
c.Walk(500) // this works
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason you can do that is that the Go compiler automatically converts this
line to (&amp;amp;c).Walk(500) for you.  However, that doesn’t work for passing the
value into an interface.  The reason is that the value in an interface is in a
hidden memory location, and so the compiler can’t automatically get a pointer to
that memory for you (in Go parlance, this is known as being “not addressable”).&lt;/p&gt;

&lt;h3 id=&#34;toc_4&#34;&gt;Nil Pointers and Nil Interfaces&lt;/h3&gt;

&lt;p&gt;The interaction between nil interfaces and nil pointers is where nearly everyone
gets tripped up when they first start with Go.&lt;/p&gt;

&lt;p&gt;Let’s say we have our Camel type with the Walk method defined on *Camel as
above, and we want to make a function that returns a Walker that is actually a
Camel (note that you don’t need a function to do this, you can just assign a
*Camel to a Walker, but the function is a good illustrative example):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func MakeWalker() Walker {
    return &amp;amp;Camel{“Bill”}
}

w := MakeWalker()
if w != nil {
    w.Walk(500)  // we will hit this
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works fine.  But now, what if we do something a little different:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func MakeWalker(c *Camel) Walker {
    return c
}

var c *Camel
w := MakeWalker(c)
if w != nil {
    // we’ll get in here, but why?
    w.Walk(500)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code will also get inside the if statement (and then panic, which we’ll
talk about in a bit) because the returned Walker value is not nil.  How is that
possible, if we returned a nil pointer?  Well, let’s go look back to the
instructions that get generated when we assign a value to an interface.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data := c
w := Walker{ 
    type: &amp;amp;InterfaceType{ 
              valtype: &amp;amp;typeof(c), 
              func0: &amp;amp;Camel.Walk 
          }
    data: &amp;amp;data
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, c is a nil pointer. However, that’s a perfectly valid value to
assign to the Walker’s Data value, so it works just fine.  What you return is a
non-nil Walker value, that has a pointer to a nil *Camel as its data.  So, of
course, if you check w == nil, the answer is false, w is not nil… but then
inside the if statement, we try to call Camel’s walk:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Camel) Walk(miles int) {
     fmt.Printf(“%s is walking %v miles\n”, c.Name, miles)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And when we try to do c.Name, Go automatically turns that into (*c).Name, and
the code panics with a nil pointer dereference error.&lt;/p&gt;

&lt;p&gt;Hopefully this makes sense, given our new understanding of how interfaces wrap
values, but then how do you account for nil pointers?  Assume you want
MakeWalker to return a nil interface if it gets passed a nil Camel.  You have to
explicitly assign nil to the interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func MakeWalker(c *Camel) Walker {
    if c == nil {
        return nil
    }
    return c
}

var c *Camel
w := MakeWalker(c)
if w != nil {
    // Yay, we don’t get here!
    w.Walk(500)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now, finally, the code is doing what we expect.  When you pass in a nil
*Camel, we return a nil interface.  Here’s an alternate way to write the
function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func MakeWalker(c *Camel) Walker {
    var w Walker
    if c != nil {
        w = c
    }
    return w
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is slightly less optimal, but it shows the other way to get a nil
interface, which is to use the zero value for the interface, which is nil.&lt;/p&gt;

&lt;p&gt;Note that you can have a nil pointer value that satisfies an interface.  You
just need to be careful not to dereference the pointer in your methods.  For
example, if *Camel’s Walk method looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (c *Camel) Walk(miles int) {
    fmt.Printf(“I’m walking %d miles!”, miles)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this method does not dereference c, and therefore you can call it even
if c is nil:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var c *Camel
c.Walk(500)
// prints “I’m walking 500 miles!”
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://play.golang.org/p/4EfyV21at9&#34;&gt;http://play.golang.org/p/4EfyV21at9&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;toc_5&#34;&gt;Outro&lt;/h3&gt;

&lt;p&gt;I hope this article helps you better understand how interfaces works, and helps
you avoid some of the common pitfalls and misconceptions newbies have about how
interfaces work.  If you want more information about the internals of interfaces
and some of the optimizations that I didn’t cover here, read Russ Cox’s article
on Go interfaces, I highly recommend it.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Mocking functions in Go</title>
      <link>http://npf.io/2014/04/mocking-functions-in-go/</link>
      <pubDate>Thu, 10 Apr 2014 11:35:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/04/mocking-functions-in-go/</guid>
      <description>&lt;p&gt;Functions in Go are first class citizens, that means you can have a variable that contains a function value, and call it like a regular function.&lt;br /&gt;&lt;pre style=&#34;tab-size: 4;&#34;&gt;printf := fmt.Printf&lt;br /&gt;printf(&amp;ldquo;This will output %d line.\n&amp;rdquo;, 1)&lt;/pre&gt;This ability can come in very handy for testing code that calls a function which is hard to properly test while testing the surrounding code. &amp;nbsp;In &lt;a href=&#34;http://juju.ubuntu.com/&#34; target=&#34;_blank&#34;&gt;Juju&lt;/a&gt;, we occasionally use function variables to allow us to stub out a difficult function during tests, in order to more easily test the code that calls it. &amp;nbsp;Here&amp;rsquo;s a simplified example:&lt;br /&gt;
&lt;pre style=&#34;tab-size: 4;&#34;&gt;// in install/mongodb.go&lt;br /&gt;package install&lt;br /&gt;&lt;br /&gt;func SetupMongodb(path string) error {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;// suppose the code in this method modifies files in root&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;// directories, mucks with the environment, etc&amp;hellip; &lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;// Actions you actively don&amp;rsquo;t want to do during most tests.&lt;br /&gt;}&lt;/pre&gt;&lt;/span&gt;&lt;pre style=&#34;tab-size: 4;&#34;&gt;&lt;br /&gt;// in startup/bootstrap.go&lt;br /&gt;package startup&lt;br /&gt;&lt;br /&gt;func Bootstrap() error {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;hellip;&lt;br /&gt;&amp;nbsp; &amp;nbsp; path := getPath()&lt;br /&gt;&amp;nbsp; &amp;nbsp; if err := install.SetupMongodb(path); err != nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;return err&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;hellip;&lt;br /&gt;}&lt;/pre&gt;&lt;/span&gt;So, suppose you want to write a test for Bootstrap, but you know SetupMongodb won&amp;rsquo;t work, because the tests don&amp;rsquo;t run with root privileges (and you don&amp;rsquo;t want to setup mongodb on the dev&amp;rsquo;s machine anyway). &amp;nbsp;What can you do? &amp;nbsp;This is where mocking comes in.&lt;br /&gt;&lt;br /&gt;We just make a little tweak to Bootstrap:&lt;br /&gt;&lt;pre style=&#34;tab-size: 4;&#34;&gt;package startup&lt;br /&gt;&lt;br /&gt;var setupMongo = install.SetupMongodb&lt;br /&gt;&lt;br /&gt;func Bootstrap() error {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;hellip;&lt;br /&gt;&amp;nbsp; &amp;nbsp; path := getRootDirPath()&lt;br /&gt;&amp;nbsp; &amp;nbsp; if err := setupMongo(path); err != nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;return err&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;hellip;&lt;br /&gt;}&lt;/pre&gt;&lt;/span&gt;Now if we want to test Bootstrap, we can mock out the setupMongo function thusly:&lt;br /&gt;&lt;pre style=&#34;tab-size: 4;&#34;&gt;&lt;span style=&#34;TRACE&#34;&gt;// in startup/bootstrap_test.go&lt;br /&gt;package startup&lt;br /&gt;&lt;br /&gt;type fakeSetup struct {&lt;br /&gt;&amp;nbsp; &amp;nbsp; path string&lt;br /&gt;&amp;nbsp; &amp;nbsp; err error&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;func (f *fakeSetup) setup(path string) error {&lt;br /&gt;&amp;nbsp; &amp;nbsp; f.path = path&lt;br /&gt;&amp;nbsp; &amp;nbsp; return f.err&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;TestBootstrap(t *testing.T) {&lt;br /&gt;&amp;nbsp; &amp;nbsp; f := &amp;amp;fakeSetup{ err: errors.New(&amp;ldquo;Failed!&amp;rdquo;) }&lt;br /&gt;&amp;nbsp; &amp;nbsp; // this mocks out the function that Bootstrap() calls&lt;br /&gt;&amp;nbsp; &amp;nbsp; setupMongo = f.setup&lt;br /&gt;&amp;nbsp; &amp;nbsp; err := Bootstrap()&lt;br /&gt;&amp;nbsp; &amp;nbsp; if err != f.err {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; t.Fail(&amp;ldquo;Error from setupMongo not returned.  Expected %v, got %v&amp;rdquo;, f.err, err)&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&amp;nbsp; &amp;nbsp; expPath := getPath()&lt;br /&gt;&amp;nbsp; &amp;nbsp; if f.path != expPath {&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; t.Fail(&amp;ldquo;Path not correctly passed into setupMongo. Expected %q, got %q&amp;rdquo;, expPath, f.path)&lt;br /&gt;&amp;nbsp; &amp;nbsp; }&lt;br /&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; // and then try again with f.err == nil, you get the idea&lt;br /&gt;}&lt;/pre&gt;&lt;/span&gt;Now we have full control over what happens in the setupMongo function, we can record the parameters that are passed into it, what it returns, and test that Bootstrap is at least using the API of the function correctly.&lt;br /&gt;&lt;br /&gt;Obviously, we need tests elsewhere for install.SetupMongodb to make sure it does the right thing, but those can be tests internal to the install package, which can use non-exported fields and functions to effectively test the logic that would be impossible from an external package (like the setup package).  Using this mocking means that we don&amp;rsquo;t have to worry about setting up an environment that allows us to test SetupMongodb when we really only want to test Bootstrap. &amp;nbsp;We can just stub out the function and test that Bootstrap does everything correctly, and trust that SetupMongodb works because it&amp;rsquo;s tested in its own package.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Effective Godoc</title>
      <link>http://npf.io/2014/04/effective-godoc/</link>
      <pubDate>Tue, 01 Apr 2014 06:43:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/04/effective-godoc/</guid>
      <description>&lt;p&gt;I started to write a blog post about how to get the most out of godoc, with examples in a repo, and then realized I could just write the whole post as godoc on the repo, so that&amp;rsquo;s what I did. &amp;nbsp;Feel free to send pull requests if there&amp;rsquo;s anything you see that could be improved.&lt;br /&gt;&lt;br /&gt;I actually learned quite a lot writing this article, by exploring all the nooks and crannies of Go&amp;rsquo;s documentation generation. &amp;nbsp;Hopefully you&amp;rsquo;ll learn something too.&lt;br /&gt;&lt;br /&gt;Either view the documentation on godoc.org:&lt;br /&gt;&lt;br /&gt;&lt;a href=&#34;https://godoc.org/github.com/natefinch/godocgo&#34;&gt;https://godoc.org/github.com/natefinch/godocgo&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;or view it locally using the godoc tool:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&#34;background-color: whitesmoke; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px; border-top-left-radius: 4px; border-top-right-radius: 4px; border: 1px solid rgb(204, 204, 204); box-sizing: border-box; color: #333333; font-family: Monaco, Menlo, Consolas, &#39;Courier New&#39;, monospace; font-size: 13px; line-height: 1.428571429; margin-bottom: 10px; overflow: auto; padding: 9.5px; word-break: normal; word-wrap: normal;&#34;&gt;go get code.google.com/p/go.tools/cmd/godoc&lt;br /&gt;go get github.com/natefinch/godocgo&lt;br /&gt;godoc -http=:8080&lt;/pre&gt;&lt;br /&gt;Then open a browser to &lt;a href=&#34;http://localhost:8080/pkg/github.com/natefinch/godocgo&#34;&gt;http://localhost:8080/pkg/github.com/natefinch/godocgo&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;Enjoy!&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Unused Variables in Go</title>
      <link>http://npf.io/2014/03/unused-variables-in-go/</link>
      <pubDate>Fri, 28 Mar 2014 16:13:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/03/unused-variables-in-go/</guid>
      <description>&lt;p&gt;The Go compiler treats unused variables as a compilation error. This causes much
annoyance to some newbie Gophers, especially those used to writing languages
that aren&amp;rsquo;t compiled, and want to be able to be fast and loose with their code
while doing exploratory hacking.&lt;/p&gt;

&lt;p&gt;The thing is, an unused variable is often a bug in your code, so pointing it out
early can save you a lot of heartache.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;50 func Connect(name, port string) error {
51     hostport := &amp;quot;&amp;quot;
52    if port == &amp;quot;&amp;quot; {
53        hostport := makeHost(name)
54        logger.Infof(&amp;quot;No port specified, connecting on port 8080.&amp;quot;)
55    } else {
56        hostport := makeHostPort(name, port)
57        logger.Infof(&amp;quot;Connecting on port %s.&amp;quot;, port)
58    }
59    // ... use hostport down here
60 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where&amp;rsquo;s the bug in the above?  Without the compiler error, you&amp;rsquo;d run the code
and have to figure out why hostport was always an empty string.  Did we pass in
empty strings by accident?  Is there a bug in makeHost and makeHostPort?&lt;/p&gt;

&lt;p&gt;With the compiler error, it will say &amp;ldquo;53, hostport declared and not used&amp;rdquo; and
&amp;ldquo;56, hostport declared and not used&amp;rdquo;&lt;/p&gt;

&lt;p&gt;This makes it a lot more obvious what the problem is&amp;hellip; inside the scope of the
if statement, := declares new variables called hostport.  These hide the
variable from the outer scope, thus, the outer hostport never gets modified,
which is what gets used further on in the function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;50 func Connect(name, port string) error {
51    hostport := &amp;quot;&amp;quot;
52    if port == &amp;quot;&amp;quot; {
53        hostport = makeHost(name)
54        logger.Infof(&amp;quot;No port specified, connecting on port 8080.&amp;quot;)
55    } else {
56        hostport = makeHostPort(name, port)
57        logger.Infof(&amp;quot;Connecting on port %s.&amp;quot;, port)
58    }
59    // ... use hostport down here
60 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above is the corrected code. It took only a few seconds to fix, thanks to
the unused variable error from the compiler.  If you&amp;rsquo;d been testing this by
running it or even with unit tests&amp;hellip; you&amp;rsquo;d probably end up spending a non-
trivial amount of time trying to figure it out.  And this is just a very simple
example.  This kind of problem can be a lot more elaborate and hard to find.&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s why the unused variable declaration error is actually a good thing.
If a value is important enough to be assigned to a variable, it&amp;rsquo;s probably a bug
if you&amp;rsquo;re not actually using that variable.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bonus tip:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Note that if you don&amp;rsquo;t care about the variable, you can just assign it to the
empty identifier directly:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;_, err := computeMyVar()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the normal way to avoid the compiler error in cases where a function
returns more than you need.&lt;/p&gt;

&lt;p&gt;If you &lt;em&gt;really&lt;/em&gt; want to silence the unused variable error and not remove the
variable for some reason, this is the way to do it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;v, err := computeMyVar() 
_ = v  // this counts as using the variable 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just don&amp;rsquo;t forget to clean it up before committing.&lt;/p&gt;

&lt;p&gt;All of the above also goes for unused packages.  And a similar tip for silencing
that error:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;_ = fmt.Printf // this counts as using the package
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Go and Github</title>
      <link>http://npf.io/2014/03/go-and-github/</link>
      <pubDate>Fri, 21 Mar 2014 06:29:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/03/go-and-github/</guid>
      <description>&lt;p&gt;&lt;span class=&#34;fullname js-action-profile-name show-popup-with-id&#34; style=&#34;background-color: white; font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 16px; text-decoration: none;&#34;&gt;Francesc Campoy&amp;nbsp;&lt;span style=&#34;color: #292f33;&#34;&gt;&lt;a href=&#34;http://blog.campoy.cat/2014/03/github-and-go-forking-pull-requests-and.html&#34; target=&#34;_blank&#34;&gt;recently posted&lt;/a&gt; about how to work on someone else&amp;rsquo;s Go repo from github. &amp;nbsp;His description was correct, but I think there&amp;rsquo;s an easier way, and also one that might be slightly less confusing.&lt;/span&gt;&lt;/span&gt;&lt;br /&gt;&lt;span class=&#34;fullname js-action-profile-name show-popup-with-id&#34; style=&#34;background-color: white; font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 16px; text-decoration: none;&#34;&gt;&lt;span style=&#34;color: #292f33;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;color: #292f33; font-family: Helvetica Neue, Helvetica, Arial, sans-serif;&#34;&gt;&lt;span style=&#34;background-color: white; font-size: 14.399999618530273px; line-height: 16px;&#34;&gt;Let&amp;rsquo;s say you want to work on your own branch of github.com/natefinch/gocog - here&amp;rsquo;s the easiest way to do it:&lt;/span&gt;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;ol&gt;&lt;li&gt;&lt;span style=&#34;color: #292f33; font-family: Helvetica Neue, Helvetica, Arial, sans-serif;&#34;&gt;&lt;span style=&#34;font-size: 14.399999618530273px; line-height: 16px;&#34;&gt;Fork&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;background-color: white; color: #292f33; font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 14.399999618530273px; line-height: 16px;&#34;&gt;github.com/natefinch/gocog on github&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&#34;background-color: white; color: #292f33; font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 14.399999618530273px; line-height: 16px;&#34;&gt;mkdir -p $GOPATH/src/github.com/natefinch/gocog&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&#34;background-color: white; color: #292f33; font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 14.399999618530273px; line-height: 16px;&#34;&gt;cd&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;background-color: white; color: #292f33; font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 14.399999618530273px; line-height: 16px;&#34;&gt;$GOPATH/src/github.com/natefinch/gocog&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&#34;background-color: white; color: #292f33; font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 14.399999618530273px; line-height: 16px;&#34;&gt;git clone https://&lt;/span&gt;&lt;span style=&#34;background-color: white; color: #292f33; font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 14.399999618530273px; line-height: 16px;&#34;&gt;github.com/YOURNAME/gocog .&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&#34;background-color: white; color: #292f33; font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 14.399999618530273px; line-height: 16px;&#34;&gt;(optional) go get github.com/natefinch/gocog&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;&lt;div&gt;&lt;span style=&#34;color: #292f33; font-family: Helvetica Neue, Helvetica, Arial, sans-serif;&#34;&gt;&lt;span style=&#34;font-size: 14.399999618530273px; line-height: 16px;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&#34;color: #292f33; font-family: Helvetica Neue, Helvetica, Arial, sans-serif;&#34;&gt;&lt;span style=&#34;font-size: 14.399999618530273px; line-height: 16px;&#34;&gt;That&amp;rsquo;s it. &amp;nbsp;Now you can work on the code, push/pull etc from your github repo as normal, and submit a pull request when you&amp;rsquo;re done.&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&#34;color: #292f33; font-family: Helvetica Neue, Helvetica, Arial, sans-serif;&#34;&gt;&lt;span style=&#34;font-size: 14.399999618530273px; line-height: 16px;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&#34;color: #292f33;&#34;&gt;&lt;span style=&#34;font-size: 14.399999618530273px; line-height: 16px;&#34;&gt;&lt;code&gt;go get&lt;/code&gt;&lt;span style=&#34;font-family: Helvetica Neue, Helvetica, Arial, sans-serif;&#34;&gt; is useful for getting code that you want to &lt;/span&gt;&lt;i style=&#34;font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif;&#34;&gt;use,&lt;/i&gt;&lt;span style=&#34;font-family: Helvetica Neue, Helvetica, Arial, sans-serif;&#34;&gt;&amp;nbsp;but it&amp;rsquo;s not very useful for getting code that you want to &lt;i&gt;work on&lt;/i&gt;. &amp;nbsp;It doesn&amp;rsquo;t set up source control. &amp;nbsp;&lt;/span&gt;&lt;code&gt;git clone&lt;/code&gt;&lt;span style=&#34;font-family: Helvetica Neue, Helvetica, Arial, sans-serif;&#34;&gt; does. &amp;nbsp;What go get is handy for is getting the dependencies of a project, which is what step 5 does (only needed if the project relies on outside repos you don&amp;rsquo;t already have). &amp;nbsp;(thanks to a post on G+ for reminding me that git clone won&amp;rsquo;t get the dependencies)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&#34;color: #292f33;&#34;&gt;&lt;span style=&#34;font-size: 14.399999618530273px; line-height: 16px;&#34;&gt;&lt;span style=&#34;font-family: Helvetica Neue, Helvetica, Arial, sans-serif;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;color: #292f33; font-family: Helvetica Neue, Helvetica, Arial, sans-serif; font-size: 14.399999618530273px; line-height: 16px;&#34;&gt;Also note,&lt;b&gt; the path on disk is the same as the original repo&amp;rsquo;s URL, not your branch&amp;rsquo;s URL&lt;/b&gt;. &amp;nbsp;That&amp;rsquo;s intentional, and it&amp;rsquo;s the key to making this work. &amp;nbsp;&lt;/span&gt;&lt;span style=&#34;color: #292f33; font-family: Courier New, Courier, monospace; font-size: 14.399999618530273px; line-height: 16px;&#34;&gt;go get&lt;/span&gt;&lt;span style=&#34;color: #292f33; font-family: Helvetica Neue, Helvetica, Arial, sans-serif; font-size: 14.399999618530273px; line-height: 16px;&#34;&gt; is the only thing that actually cares if the repo URL is the same as the path on disk. &amp;nbsp;Once the code is on disk, &lt;/span&gt;&lt;span style=&#34;color: #292f33; font-family: Courier New, Courier, monospace; font-size: 14.399999618530273px; line-height: 16px;&#34;&gt;go build&lt;/span&gt;&lt;span style=&#34;color: #292f33; font-family: Helvetica Neue, Helvetica, Arial, sans-serif; font-size: 14.399999618530273px; line-height: 16px;&#34;&gt; etc just expects import paths to be directories under $GOPATH. &amp;nbsp;The code expects to be under $GOPATH/src/github.com/natefinch/gocog because that&amp;rsquo;s what the import statements say it should be. &amp;nbsp;There&amp;rsquo;s no need to change import paths or anything wacky like that (though it does mean that you can&amp;rsquo;t have both the original version of the code and your branch coexisting in the same $GOPATH).&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&#34;color: #292f33;&#34;&gt;&lt;span style=&#34;font-size: 14.399999618530273px; line-height: 16px;&#34;&gt;&lt;span style=&#34;font-family: Helvetica Neue, Helvetica, Arial, sans-serif;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&#34;color: #292f33;&#34;&gt;&lt;span style=&#34;font-size: 14.399999618530273px; line-height: 16px;&#34;&gt;&lt;span style=&#34;font-family: Helvetica Neue, Helvetica, Arial, sans-serif;&#34;&gt;Note that this is actually &lt;i&gt;the same procedure&amp;nbsp;&lt;/i&gt;that you&amp;rsquo;d use to work on your own code from github, you just change step 1 to &amp;ldquo;create the repo in github&amp;rdquo;. &amp;nbsp;I prefer making the repo in github first because it lets me set up the license, the readme, and the .gitignore with just a few checkboxes, though obviously that&amp;rsquo;s optional if you want to hack locally first. &amp;nbsp;In that case, just make sure to set up the path under gopath where it &lt;i&gt;would go&lt;/i&gt; if you used &lt;/span&gt;&lt;code&gt;go get&lt;/code&gt;&lt;span style=&#34;font-family: Helvetica Neue, Helvetica, Arial, sans-serif;&#34;&gt;, so that &lt;/span&gt;&lt;code&gt;go get&lt;/code&gt;&lt;span style=&#34;font-family: Helvetica Neue, Helvetica, Arial, sans-serif;&#34;&gt; will work correctly when you decide to push up to github.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=&#34;color: #292f33;&#34;&gt;&lt;span style=&#34;font-size: 14.399999618530273px; line-height: 16px;&#34;&gt;&lt;span style=&#34;font-family: Helvetica Neue, Helvetica, Arial, sans-serif;&#34;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;font-family: Helvetica Neue, Arial, Helvetica, sans-serif; TRACE&#34;&gt;(updated to mention using go get after git clone)&lt;/span&gt;&lt;br /&gt;&lt;span style=&#34;color: #292f33;&#34;&gt;&lt;span style=&#34;line-height: 17.804800033569336px;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Go Tips for Newbie Gophers</title>
      <link>http://npf.io/2014/03/go-tips-for-newbie-gophers/</link>
      <pubDate>Sat, 15 Mar 2014 09:00:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/03/go-tips-for-newbie-gophers/</guid>
      <description>&lt;p&gt;This is just a collection of tips that would have saved me a lot of time if I had known about them when I was a newbie:&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Build or test everything under the current directory and subdirectories:&lt;/b&gt;&lt;br /&gt;&lt;b&gt;&lt;br /&gt;&lt;/b&gt;&lt;pre style=&#34;tab-size: 4;&#34;&gt;go build ./&amp;hellip;&lt;br /&gt;go test ./&amp;hellip;&lt;/pre&gt;&lt;span style=&#34;font-family: inherit;&#34;&gt;Technically, both commands take a pattern to match the name of one or more packages, and the &amp;hellip; specifier is a wildcard, so you could do &amp;hellip;/foo/&amp;hellip; to match all packages under GOPATH with foo in their path.&amp;nbsp;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Have an io.Writer that writes to an in-memory data structure:&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;div&gt;&lt;pre style=&#34;tab-size: 4;&#34;&gt;b := &amp;amp;bytes.Buffer{}&lt;br /&gt;thing.WriteTo(b)&lt;/pre&gt;&lt;b&gt;Have an io.Reader read from a string (useful when you want to use a string as the input data for something):&lt;/b&gt;&lt;br /&gt;&lt;pre style=&#34;tab-size: 4;&#34;&gt;r := strings.NewReader(myString)&lt;br /&gt;thing.ReadFrom(r)&lt;/pre&gt;&lt;b&gt;Copy data from a reader to a writer:&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;pre style=&#34;tab-size: 4;&#34;&gt;io.Copy(toWriter, fromReader)&lt;/pre&gt;&lt;b&gt;Timeout waiting on a channel:&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;&lt;pre style=&#34;tab-size: 4;&#34;&gt;select {&lt;br/&gt;&amp;nbsp; &amp;nbsp;case val := &amp;lt;- ch&lt;br/&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// use val&lt;br/&gt;&amp;nbsp; &amp;nbsp;case &amp;lt;-time.After(time.Second*5)&lt;br /&gt;}&lt;/pre&gt;&lt;b&gt;Convert a slice of bytes to a string:&lt;/b&gt;&lt;pre style=&#34;tab-size: 4;&#34;&gt;var b []byte = getData()&lt;br/&gt;s := string(b)&lt;/pre&gt;&lt;b&gt;Passing a nil pointer into an interface does not result in a nil interface:&lt;/b&gt;&lt;pre style=&#34;tab-size: 4;&#34;&gt;func isNil(i interface{}) bool {&lt;br/&gt;&amp;nbsp; &amp;nbsp; return i == nil&lt;br/&gt;}&lt;br/&gt;var f *foo = nil&lt;br /&gt;fmt.Println(isNil(f)) &amp;nbsp;// prints false&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;The only way to get a nil interface is to pass the keyword nil:&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;pre style=&#34;tab-size: 4;&#34;&gt;var f *foo = nil&lt;br/&gt;if f == nil {&lt;br /&gt;&amp;nbsp; &amp;nbsp; fmt.Println(isNil(nil)) &amp;nbsp;// prints true&lt;br/&gt;}&lt;/pre&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;How to remember where the arrow goes for channels:&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;The arrow points in the direction of data flow, either into or out of the channel, and always points left.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;The above is generalizable to anything where you have a source and destination, or reading and writing, or assigning.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br /&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;Data is taken from the right and assigned to the left, just as it is with a := b. &amp;nbsp;So, like io.Copy, you know that the reader (source) is on the right, the writer (destination) is on the left: &amp;nbsp;io.Copy(dest, src).&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;If you ever think &amp;ldquo;man, someone should have made a helper function to do this!&amp;rdquo;, chances are they have, and it&amp;rsquo;s in the std lib somewhere.&lt;/b&gt;&lt;/div&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Statically typed generic data structures in Go</title>
      <link>http://npf.io/2013/04/statically-typed-generic-data-structures-in-go/</link>
      <pubDate>Wed, 17 Apr 2013 08:01:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2013/04/statically-typed-generic-data-structures-in-go/</guid>
      <description>&lt;p&gt;&lt;br /&gt;I gave a talk at the &lt;a href=&#34;https://plus.google.com/u/0/communities/103337146295481792015&#34; target=&#34;_blank&#34;&gt;Go Boston&lt;/a&gt; meetup last night and figured I should write it up and put it here.&lt;br /&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;br /&gt;The second thing everyone says when they read up on Go is &amp;ldquo;There are no generics!&amp;rdquo;. &lt;br /&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;(The first thing people say is &amp;ldquo;There are no exceptions!&amp;rdquo;)&lt;br /&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;Both are only mostly true, &amp;nbsp;but we&amp;rsquo;re only going to talk about generics today.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;Go has generic built-in data structures - arrays, slices, maps, and channels. You just can&amp;rsquo;t create your own new type, and you can&amp;rsquo;t create generic functions. So, what&amp;rsquo;s a programmer to do? Find another language?&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;No. Many, possibly even most, problems can be solved with the built-in data structures. You can write pretty huge applications just using maps and slices and the occasional channel. There may be a tiny bit of code duplication, but probably not much, and certainly not any tricky code.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;However, there definitely are times when you need more complicated data structures. Most people writing Go solve this problem by using Interface{}, the empty interface, which is basically like Object in C# or Java or void * in C/C++. &amp;nbsp;It&amp;rsquo;s a thing that can hold any type&amp;hellip; but then you need to type cast it to get at the actual type. This breaks static typing, since the compiler can&amp;rsquo;t tell if you make a mistake and pass the wrong type into something that takes an Interface{}, and it can&amp;rsquo;t tell until runtime if a cast will succeed or not.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;So, is there any solution? Yes. The inspiration comes from the standard library&amp;rsquo;s&lt;a href=&#34;http://golang.org/pkg/sort/#Interface&#34; target=&#34;_blank&#34;&gt; sort package&lt;/a&gt;. Package sort can sort a slice of any type, it can even sort things that aren&amp;rsquo;t slices, if you&amp;rsquo;ve made your own custom data structure. How does it do that? To sort something, it must support the methods on sort.Interface. Most interesting is Less(i, j int). Less returns true if the item at index i in your data structure is Less than the object at index j in your data structure. Your code has to implement what &amp;ldquo;Less&amp;rdquo; means&amp;hellip; and by only using indices, sort doesn&amp;rsquo;t need to know the types of objects held in your data structure.&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;This use of indices to blindly access data in a separate data structure is how we&amp;rsquo;ll implement our strongly typed tree. The tree structure will hold an index as its data value in each node, and the indices will index into a data structure that holds the actual objects. To make a tree of a new type, you simply implement a Compare function that the tree can use to compare the values at two indices in your data structure. You can use whatever data structure you like, probably a slice or a map, as long as you can use integers to reference values in the data structure.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;In this way we separate the organization of the data from the storage of the data. The tree structure holds the organization, a slice or map (or something custom) stores the data. The indices are the generic pointers into the storage that holds the actual strongly typed values.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;This does require a little code for each new tree type, just as using package sort requires a little code for each type. However, it&amp;rsquo;s only a few lines for a few functions, wrapping a tree and your data.&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;You can check out an example binary search tree I wrote that uses this technique in my github account&lt;br /&gt;&lt;br /&gt;&lt;a href=&#34;https://github.com/natefinch/tree&#34;&gt;https://github.com/natefinch/tree&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;or go get the runnable sample tree:&lt;br /&gt;&lt;br /&gt;go get github.com/natefinch/treesample&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;This required only 36 lines of code to make the actual tree structure (including empty lines and comments).&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;In some simple benchmarks, this implementation of a tree is about 25% faster than using the same code with Interface{} as the values and casting at runtime&amp;hellip;. plus it&amp;rsquo;s strongly typed.&lt;/div&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Go is for Open Source</title>
      <link>http://npf.io/2013/01/go-is-for-open-source/</link>
      <pubDate>Tue, 29 Jan 2013 07:45:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2013/01/go-is-for-open-source/</guid>
      <description>&lt;p&gt;The Go programming language is built from the ground up to implicitly encourage Go projects to be open source. If you want your project not only to contribute to open source, but to encourage other people to write open source code, Go is a great language to choose.&lt;br /&gt;&lt;br /&gt;Let&amp;rsquo;s look at how Go does this. These first two points are overly obvious, but we should get them out of the way.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;The language is open source&lt;/h3&gt;You can go look at the &lt;a href=&#34;https://code.google.com/p/go/source/browse/&#34; target=&#34;_blank&#34;&gt;source code&lt;/a&gt;&amp;nbsp;for the language, the compilers, and the build tools for the language. It&amp;rsquo;s a fully open source project. Even though a lot of the work is being done by Google engineers, there are hundreds of names on the &lt;a href=&#34;https://code.google.com/p/go/source/browse/CONTRIBUTORS&#34; target=&#34;_blank&#34;&gt;list of contributors&lt;/a&gt; of people who are not Google employees.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;The standard library is open source&lt;/h3&gt;&lt;div&gt;Want to see high quality example code? Look at the code in the standard library. It has been carefully reviewed to be of the best quality, and in canonical Go style. Reading the standard library is a great way to learn the best ways to use and write Go.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;span style=&#34;color: red;&#34;&gt;Ok, that&amp;rsquo;s great, but what about all the code that isn&amp;rsquo;t part of Go itself?&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;The design of Go really shows its embrace of open source in how third party code is used in day to day projects.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;h3&gt;Go makes it trivial to use someone&amp;nbsp;else&amp;rsquo;s code in your project&lt;/h3&gt;&lt;div&gt;Go has distributed version control built-in from the ground up. If you want to use a package from github, for example, you just specify the URL in the imports, as if it were a local package:&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;pre class=&#34;brush: go; gutter: false&#34;&gt;import (&lt;br /&gt;    &amp;ldquo;bytes&amp;rdquo; // std lib package&lt;br /&gt;    &amp;ldquo;github.com/fake/foo&amp;rdquo; // 3rd party package&lt;br /&gt;)&lt;/pre&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;You don&amp;rsquo;t have to go find and download fake/foo from github and put it in a special directory or anything. Just run &amp;ldquo;go get github.com/fake/foo&amp;rdquo;. Go will then download, build, and install the code, so that you can reference it&amp;hellip; nicely stored in a directory defined by the URL, in this case $GOPATH/src/github.com/fake/foo. Go will even figure out what source control system is used on the other side so you don&amp;rsquo;t have to (support for git, svn, mercurial, and bazaar).&lt;br /&gt;&lt;br /&gt;What&amp;rsquo;s even better is that the auto-download happens for anyone who calls &amp;ldquo;go get&amp;rdquo; on&amp;nbsp;&lt;i&gt;your&lt;/i&gt;&amp;nbsp;code repository. No more giving long drawn-out installation instructions about getting half a dozen 3rd party libraries first. If someone wants your code, they type &amp;ldquo;go get path.to/your/code&amp;rdquo;, and Go will download your code, and any remote imports you have (like the one for github above), any remote imports &lt;i&gt;that&lt;/i&gt; code has, etc, and then builds everything.&lt;br /&gt;&lt;br /&gt;The fact that this is available from the command line tools that come with the language makes it the de facto standard for how all Go code is written. There&amp;rsquo;s no fragmentation in the community about how packages are stored, accessed, used, etc. This means zero overhead for using third party code, it&amp;rsquo;s as easy to use as if it were built into the Go standard library.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;Sharing code is the default&lt;/h3&gt;&lt;/div&gt;&lt;div&gt;Like most scripting languages (and unlike many compiled languages), using source code from another project is the default way to use third party code in Go. Go creates a monolithic executable during its build, so there are no DLLs to create and distribute in the way you often see with other compiled languages. In theory you could distribute the compiled .a files from your project for other people to link to in their project, but this is not encouraged by the tooling, and I&amp;rsquo;ve personally never seen anyone do it.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;h3&gt;All Go code uses the same style&lt;/h3&gt;&lt;div&gt;Have you ever gone to read the source for a project you&amp;rsquo;d like to contribute to, and had your eyes cross over at the bizarre formatting the authors used? That almost never happens with Go. Go comes with a code formatting tool called gofmt that automatically formats Go code to the same style. The use of gofmt is strongly encouraged in the Go community, and nearly everyone uses it. Most text editors have an extension to automatically format your code with gofmt on save, so you don&amp;rsquo;t even have to think about it. You never have to worry about having a poorly formatted library to work with&amp;hellip; and in the very rare situation where you do, you can just run it through gofmt and you&amp;rsquo;re good to go.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;h3&gt;Easy cross platform support&lt;/h3&gt;&lt;div&gt;Go makes it easy to support multiple platforms. The tooling &lt;a href=&#34;http://dave.cheney.net/2012/09/08/an-introduction-to-cross-compilation-with-go&#34; target=&#34;_blank&#34;&gt;can create native binaries&lt;/a&gt; for any popular operating system from the same source on a single machine. If you need platform-specific code, it&amp;rsquo;s easy to specify code that only gets compiled for a single platform, by simply appending _&amp;lt;os&amp;gt; to a file name &lt;i&gt;.e.g&lt;/i&gt;&amp;nbsp;path_windows.go will only be compiled for builds targeting Windows.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;h3&gt;Built-in documentation and testing&lt;/h3&gt;&lt;div&gt;Go comes with a documentation generator that spits generates HTML or plain text from minimally formatted comments in the code. It also comes with a standard testing package that can run unit tests, performance benchmarks, and runnable example code. Because this is all available in the standard library and with the standard tools, nearly everyone uses it&amp;hellip; which means it&amp;rsquo;s easy to look at the documentation for any random Go package, and easy check if the tests pass, without having to go install some third party support tool. Because it&amp;rsquo;s all standardized, several popular websites have popped up to &lt;a href=&#34;http://godoc.org/&#34; target=&#34;_blank&#34;&gt;automate generating&lt;/a&gt;&amp;nbsp;(and hosting) the documentation for your project, and you can easily run &lt;a href=&#34;http://about.travis-ci.org/docs/user/languages/go/&#34; target=&#34;_blank&#34;&gt;continuous integration&lt;/a&gt; on your package, with only a single line in the setup script - &amp;ldquo;language: go&amp;rdquo;.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;h3&gt;Conclusion&lt;/h3&gt;&lt;div&gt;Everything about Go encourages standardization and openness&amp;hellip; which not only makes it &lt;i&gt;possible &lt;/i&gt;to use other people&amp;rsquo;s code, it makes it &lt;b&gt;easy&lt;/b&gt;&lt;i&gt;&amp;nbsp;&lt;/i&gt;to use other people&amp;rsquo;s code. I hope to see Go blossom as a language embraced by the open source community, as they discover the strengths that make it uniquely qualified for open source projects.&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>What I love about Go</title>
      <link>http://npf.io/2013/01/what-i-love-about-go/</link>
      <pubDate>Fri, 25 Jan 2013 08:49:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2013/01/what-i-love-about-go/</guid>
      <description>&lt;p&gt;&lt;h2&gt;&lt;span style=&#34;font-weight: normal;&#34;&gt;The best things about Go have nothing to do with the language.&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;Single Executable Output&lt;/h3&gt;Go compiles into a single executable that runs natively on the target OS. No more needing to install java, .net, mono, python, ruby, whatever. Here&amp;rsquo;s your executable, feel free to run it like a normal person. &amp;nbsp;And you can target builds for any major OS (windows, linux, OSX, BSD).&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;One True Coding Style&lt;/h3&gt;GoFmt is a build tool that formats your source code in the standard Go format. No more arguing about spacing or brace matching or whatever. There is one true format, and now we can all move on&amp;hellip; and even better, many editors integrate GoFmt so that your code can be automatically formatted whenever you save.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;Integrated Testing&lt;/h3&gt;Testing is integrated into the language. Name a file with the suffix _test.go and it&amp;rsquo;ll only build under test. You run tests simply by running &amp;ldquo;go test&amp;rdquo; in the directory. You can also define runnable example code with output that is checked at test time. &amp;nbsp;This example code is then included in the documentation (see below)&amp;hellip; now you&amp;rsquo;ll never have examples in documentation with errors in them. &amp;nbsp;Finally, you can have built-in benchmarks that are controlled by the go tool to automatically run enough iterations to get a significant result, displayed in number of operations per second.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;Integrated Documentation&lt;/h3&gt;HTML documentation is built into the language. No need for ugly HTML in your source or weirdly formatted comments. Plaintext comments are turned into very legible documentation, and see above for examples that actually run and can have their output tested as a part of the tests.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;DVCS&lt;/h3&gt;Support for distributed version control is built into the language. Want to reference code from a project on github? &amp;nbsp;Just use the url of the project as the import path in your code, &lt;i&gt;e.g.&lt;/i&gt; import &amp;ldquo;github.com/jsmith/foo&amp;rdquo; &amp;nbsp; When you build your code it&amp;rsquo;ll get downloaded and built automatically.&lt;br /&gt;&lt;br /&gt;Want to get a tool written in go? &amp;nbsp;From the command line type &amp;ldquo;go get github.com/jsmith/bar&amp;rdquo; - go will download the source, build it, and install the executable in your path. &amp;nbsp;Now you can run bar.&lt;br /&gt;&lt;br /&gt;Any git, SVN, mercurial, or bazaar repository will work, but all the major public source code sites are supported out of the box - github, bitbucket, google code, and launchpad.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;Other Cool Stuff&lt;/h3&gt;&lt;div&gt;Debugging with gdb&lt;br /&gt;Integrated profiling tools&lt;br /&gt;Easy to define custom includes per targeted OS/architecture (simple _windows will only build if targetting windows)&lt;br /&gt;Integrated code parsers and lexers.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;h4&gt;Do you even care about the actual language anymore? &amp;nbsp;I wouldn&amp;rsquo;t. &amp;nbsp;But just in case:&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;C-like&lt;/li&gt;&lt;li&gt;Garbage Collected&lt;/li&gt;&lt;li&gt;Statically typed&lt;/li&gt;&lt;li&gt;&amp;hellip;but with type inference so you&amp;rsquo;re not typing boilerplate all the time: a := &amp;ldquo;my string&amp;rdquo;&lt;/li&gt;&lt;li&gt;Implicit interfaces - if a type has the methods of an interface, it implements the interface&lt;/li&gt;&lt;li&gt;Pointers but no pointer arithmetic (thank god)&lt;/li&gt;&lt;li&gt;First class functions&lt;/li&gt;&lt;li&gt;No exceptions&lt;/li&gt;&lt;li&gt;&amp;hellip;but multiple returns from a single function so you don&amp;rsquo;t have to overload return types&lt;/li&gt;&lt;li&gt;Everything is UTF8 (both strings and source code.. yes you can have Θ as a variable name now)&lt;/li&gt;&lt;li&gt;Highly performant asynchronous code that is trivial to write&lt;/li&gt;&lt;li&gt;A deep standard library that does most of the boring stuff for you&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    
  </channel>
</rss>