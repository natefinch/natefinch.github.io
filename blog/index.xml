<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>npf.io</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://npf.io/blog/</link>
    <language>en-us</language>
    <author>Nate Finch</author>
    <copyright>2015 Nate Finch</copyright>
    <updated>Tue, 30 Jun 2015 12:44:29 EDT</updated>
    
    
    <item>
      <title>Take control of your command with Deputy</title>
      <link>http://npf.io/2015/06/deputy/</link>
      <pubDate>Tue, 30 Jun 2015 12:44:29 EDT</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2015/06/deputy/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/3185864/8237448/6bc30102-15bd-11e5-9e87-6423197a73d6.jpg&#34; alt=&#34;deputy-sm&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;&lt;sub&gt;image: creative commons, &amp;copy; &lt;a href=&#34;http://matsurd.deviantart.com/art/Paper53-Deputy-Stubbs-342123485&#34;&gt;MatsuRD&lt;/a&gt;&lt;/sub&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;As a part of my work on &lt;a href=&#34;https://github.com/juju/juju&#34;&gt;Juju&lt;/a&gt;, I have published a
new package at &lt;a href=&#34;http://github.com/juju/deputy&#34;&gt;http://github.com/juju/deputy&lt;/a&gt;.  I think it&amp;rsquo;ll be of general use
to a lot of people.&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;en&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;I want to name a package &amp;quot;lieutenant&amp;quot;, but it&amp;#39;s too hard to spell.&lt;/p&gt;&amp;mdash; Nate Finch (@NateTheFinch) &lt;a href=&#34;https://twitter.com/NateTheFinch/status/610481962311131136&#34;&gt;June 15, 2015&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;True story.  The idea was this package would be a lieutenant commander (get
it?)&amp;hellip; but I also knew I didn&amp;rsquo;t want to have to try to spell lieutenant
correctly every time I used the package.  So that&amp;rsquo;s why it&amp;rsquo;s called deputy.
He&amp;rsquo;s the guy who&amp;rsquo;s not in charge, but does all the work.&lt;/p&gt;

&lt;h3 id=&#34;errors:c6ab1c3501e7e929f514472ad514e06f&#34;&gt;Errors&lt;/h3&gt;

&lt;p&gt;At &lt;a href=&#34;https://github.com/juju/juju&#34;&gt;Juju&lt;/a&gt;, we run a lot of external processes
using os/exec. However, the default functionality of an exec.Cmd object is kind
of lacking. The most obvious one is those error returns &amp;ldquo;exit status 1&amp;rdquo;.
Fantastic.  Have you ever wished you could just have the stderr from the command
as the error text?  Well, now you can, with deputy.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    d := deputy.Deputy{
        Errors:    deputy.FromStderr,
    }
    cmd := exec.Command(&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot;)
    err := d.Run(cmd)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above code, if the command run by Deputy exits with a non-zero exit
status, deputy will capture the text output to stderr and convert that into the
error text.  &lt;em&gt;e.g.&lt;/em&gt; if the command returned exit status 1 and output &amp;ldquo;Error: No
such image or container: bar&amp;rdquo; to stderr, then the error&amp;rsquo;s Error() text would
look like &amp;ldquo;exit status 1: Error: No such image or container: bar&amp;rdquo;.  Bam, the
errors from commands you run are infinitely more useful.&lt;/p&gt;

&lt;h3 id=&#34;logging:c6ab1c3501e7e929f514472ad514e06f&#34;&gt;Logging&lt;/h3&gt;

&lt;p&gt;Another idiom we use is to pipe some of the output from a command to our logs. This can be super useful for debugging purposes.  With deputy, this is again easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    d := deputy.Deputy{
        Errors:    deputy.FromStderr,
        StdoutLog: func(b []byte) { log.Print(string(b)) },
    }
    cmd := exec.Command(&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot;)
    err := d.Run(cmd)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it.  Now every line written to stdout by the process will be piped as a
log message to your log.&lt;/p&gt;

&lt;h3 id=&#34;timeouts:c6ab1c3501e7e929f514472ad514e06f&#34;&gt;Timeouts&lt;/h3&gt;

&lt;p&gt;Finally, an idiom we don&amp;rsquo;t use often enough, but should, is to add a timeout to
command execution.  What happens if you run a command as part of your pipeline
and that command hangs for 30 seconds, or 30 minutes, or forever?  Do you just
assume it&amp;rsquo;ll always finish in a reasonable time?  Adding a timeout to running
commands requires some tricky coding with goroutines, channels, selects, and
killing the process&amp;hellip; and deputy wraps all that up for you in a simple API:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    d := deputy.Deputy{
        Errors:    deputy.FromStderr,
        StdoutLog: func(b []byte) { log.Print(string(b)) },
        Timeout:   time.Second * 10,
    }
    cmd := exec.Command(&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot;)
    err := d.Run(cmd)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code adds a 10 second timeout.  After that time, if the process has
not finished, it will be killed and an error returned.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it.  Give deputy a spin and let me know what you think.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Testing os/exec.Command</title>
      <link>http://npf.io/2015/06/testing-exec-command/</link>
      <pubDate>Fri, 26 Jun 2015 06:41:56 EDT</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2015/06/testing-exec-command/</guid>
      <description>&lt;p&gt;In &lt;a href=&#34;https://github.com/juju/juju&#34;&gt;Juju&lt;/a&gt;, we often have code that needs to run external
executables.  Testing this code is a nightmare&amp;hellip; because you really don&amp;rsquo;t want
to run those files on the dev&amp;rsquo;s machine or the CI machine.  But mocking out
os/exec is really hard.  There&amp;rsquo;s no interface to replace, there&amp;rsquo;s no function to
mock out and replace.  In the end, your code calls the Run method on the
exec.Cmd struct.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a bunch of bad ways you can mock this out - you can write out scripts to
disk with the right name and structure their contents to write out the correct
data to stdout, stderr and return the right return code&amp;hellip; but then you&amp;rsquo;re
writing platform-specific code in your tests, which means you need a Windows
version and a Linux version&amp;hellip; It also means you&amp;rsquo;re writing shell scripts or
Windows batch files or whatever, instead of writing Go.  And we all know that we
want our tests to be in Go, not shell scripts.&lt;/p&gt;

&lt;p&gt;So what&amp;rsquo;s the answer?  Well, it turns out, if you want to mock out exec.Command,
the best place to look is in the exec package&amp;rsquo;s tests themselves.  Lo and
behold, it&amp;rsquo;s right there in the first function of &lt;a href=&#34;https://github.com/golang/go/blob/master/src/os/exec/exec_test.go#L31&#34;&gt;exec_test.go&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func helperCommand(t *testing.T, s ...string) *exec.Cmd {
    cs := []string{&amp;quot;-test.run=TestHelperProcess&amp;quot;, &amp;quot;--&amp;quot;}
    cs = append(cs, s...)
    cmd := exec.Command(os.Args[0], cs...)
    cmd.Env = []string{&amp;quot;GO_WANT_HELPER_PROCESS=1&amp;quot;}
    return cmd
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;sub&gt;&lt;sup&gt;(one line elided for clarity) &lt;/sup&gt;&lt;/sub&gt;&lt;/p&gt;

&lt;p&gt;What the heck is that doing?  It&amp;rsquo;s pretty slick, so I&amp;rsquo;ll explain it.&lt;/p&gt;

&lt;p&gt;First off, you have to understand how tests in Go work.  When running &lt;code&gt;go test&lt;/code&gt;,
the go tool compiles an executable from your code, runs it, and passes it the
flags you passed to &lt;code&gt;go test&lt;/code&gt;.  It&amp;rsquo;s that executable which actually handles the
flags and runs the tests.  Thus, while your tests are running, os.Args[0] is the
name of the test executable.&lt;/p&gt;

&lt;p&gt;This function is making an exec.Command that runs the test executable, and
passes it the flag to tell the executable just to run a single test.  It then
terminates the argument list with &lt;code&gt;--&lt;/code&gt; and appends the command and arguments
that would have been given to exec.Command to run &lt;em&gt;your&lt;/em&gt; command.&lt;/p&gt;

&lt;p&gt;The end result is that when you run the exec.Cmd that is returned, it will run
the single test from this package called &amp;ldquo;TestHelperProcess&amp;rdquo; and os.Args will
contain (after the &lt;code&gt;--&lt;/code&gt;) the command and arguments from the original call.&lt;/p&gt;

&lt;p&gt;The environment variable is there so that the test can know to do nothing unless
that environment variable is set.&lt;/p&gt;

&lt;p&gt;This is awesome for a few reasons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It&amp;rsquo;s all Go code. No more needing to write shell scripts.&lt;/li&gt;
&lt;li&gt;The code run in the excutable is compiled with the rest of your test code.  No more needing to worry about typos in the strings you&amp;rsquo;re writing to disk.&lt;/li&gt;
&lt;li&gt;No need to create new files on disk - the executable is already there and runnable, by definition.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So, let&amp;rsquo;s use this in a real example to make it more clear.&lt;/p&gt;

&lt;p&gt;In your production code, you can do something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var execCommand = exec.Command
func RunDocker(container string) ([]byte, error) {
    cmd := execCommand(&amp;quot;docker&amp;quot;, &amp;quot;run&amp;quot;, &amp;quot;-d&amp;quot;, container)
    out, err := cmd.CombinedOutput()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mocking this out in test code is now super easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func fakeExecCommand(command string, args...string) *exec.Cmd {
    cs := []string{&amp;quot;-test.run=TestHelperProcess&amp;quot;, &amp;quot;--&amp;quot;, command}
    cs = append(cs, args...)
    cmd := exec.Command(os.Args[0], cs...)
    cmd.Env = []string{&amp;quot;GO_WANT_HELPER_PROCESS=1&amp;quot;}
    return cmd
}

const dockerRunResult = &amp;quot;foo!&amp;quot;
func TestRunDocker(t *testing.T) {
    execCommand = fakeExecCommand
    defer func(){ execCommand = exec.Command }()
    out, err := RunDocker(&amp;quot;docker/whalesay&amp;quot;)
    if err != nil {
        t.Errorf(&amp;quot;Expected nil error, got %#v&amp;quot;, err)
    }
    if string(out) != dockerRunResult {
        t.Errorf(&amp;quot;Expected %q, got %q&amp;quot;, dockerRunResult, out)
    }
}

func TestHelperProcess(t *testing.T){
    if os.GetEnv(&amp;quot;GO_WANT_HELPER_PROCESS&amp;quot;) != &amp;quot;1&amp;quot; {
        return
    }
    // some code here to check arguments perhaps?
    fmt.Fprintf(os.Stdout, dockerRunResult)
    os.Exit(0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, you can do a lot more interesting things. The environment variables
on the command that fakeExecCommand returns make a nice side channel for telling
the executable what you want it to do.  I use one to tell the process to exit
with a non-zero error code, which is great for testing your error handling code.
You can see how the standard library uses its TestHelperProcess test
&lt;a href=&#34;https://github.com/golang/go/blob/master/src/os/exec/exec_test.go#L559&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Hopefully this will help you avoid writing really gnarly testing code (or even worse,
not testing your code at all).&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Sharing Godoc of a WIP Branch</title>
      <link>http://npf.io/2015/06/wip-godoc/</link>
      <pubDate>Thu, 11 Jun 2015 07:37:00 EDT</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2015/06/wip-godoc/</guid>
      <description>&lt;p&gt;I had a problem yesterday - I wanted to use the excellent godoc.org to show
coworkers the godoc for the feature I was working on.  However, the feature was
on a branch of the main code in Github, and &lt;code&gt;go get&lt;/code&gt; Does Not Work That Way™.
So, what to do?  Well, I figured out a hack to make it work.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gopkg.in&#34;&gt;https://gopkg.in&lt;/a&gt; is a super handy service that lets you point &lt;code&gt;go get&lt;/code&gt; at
branches of your repo named vN (e.g. v0, v1, etc).  It also happens to work on
tags.  So, we can leverage this to get godoc.org to render the godoc for our WIP
branch.&lt;/p&gt;

&lt;p&gt;From your WIP branch, simply do&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git tag v0
git push myremote v0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates a lightweight tag that only affects your repo (not upstream from
whence you forked).&lt;/p&gt;

&lt;p&gt;You now can point godoc at your branch by way of gopkg.in:
&lt;a href=&#34;https://godoc.org/gopkg.in/GithubUser/repo.v0&#34;&gt;https://godoc.org/gopkg.in/GithubUser/repo.v0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This will tell godoc to &amp;lsquo;go get&amp;rsquo; your code from gopkg.in, and gopkg.in will
redirect the command to your v0 tag, which is currently on your branch.  Bam,
now you have godoc for your WIP branch on godoc.org.&lt;/p&gt;

&lt;p&gt;Later, the tag can easily be removed (and reused if needed) thusly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git tag -d v0
git push myremote :refs/tags/v0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, there you go, go forth and share your godoc.  I find it&amp;rsquo;s a great way to get
feedback on architecture before I dive into the reeds of the implementation.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Go Plugins are as Easy as Pie</title>
      <link>http://npf.io/2015/05/pie/</link>
      <pubDate>Mon, 25 May 2015 22:44:32 EDT</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2015/05/pie/</guid>
      <description>

&lt;p&gt;When people hear that Go only supports static linking, one of the things they
eventually realize is that they can&amp;rsquo;t have traditional plugins via dlls/libs (in
compiled languages) or scripts (in interpreted languages).  However, that
doesn&amp;rsquo;t mean that you can&amp;rsquo;t have plugins.  Some people suggest doing &amp;ldquo;compiled-
in&amp;rdquo; plugins - but to me, that&amp;rsquo;s not a plugin, that&amp;rsquo;s just code.  Some people
suggest just running sub processes and sending messages via their CLI, but that
runs into CLI parsing issues and requires runnnig a new process for every
request.  The last option people think of is using RPC to an external process,
which may also seem cumbersome, but it doesn&amp;rsquo;t have to be.&lt;/p&gt;

&lt;h3 id=&#34;serving-up-some-pie:786534216edb3831c5addeda1aa68cd4&#34;&gt;Serving up some pie&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;d like to introduce you to &lt;a href=&#34;https://github.com/natefinch/pie&#34;&gt;https://github.com/natefinch/pie&lt;/a&gt; - this is a Go
package which contains a toolkit for writing plugins in Go.  It uses processes
external to the main program as the plugins, and communicates with them via RPC
over the plugin&amp;rsquo;s stdin and stout.  Having the plugin as an external process can
actually has several benefits:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If the plugin crashes, it won&amp;rsquo;t crash your process.&lt;/li&gt;
&lt;li&gt;The plugin is not in your process&amp;rsquo; memory space, so it can&amp;rsquo;t do anything nasty.&lt;/li&gt;
&lt;li&gt;The plugin can be written in any language, not just Go.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I think this last point is actually the most valuable.  One of the nicest things
about Go applications is that they&amp;rsquo;re just copy-and-run.  No one even needs to
know they were written in Go.  With plugins as external processes, this remains
true.  People wanting to extend your application can do so in the language of
their choice, so long as it supports the codec your application has chosen for
RPC.&lt;/p&gt;

&lt;p&gt;The fact that the communication occurs over stdin and stdout means that there is
no need to worry about negotiating ports, it&amp;rsquo;s easily cross platform compatible,
and it&amp;rsquo;s very secure.&lt;/p&gt;

&lt;h3 id=&#34;orthogonality:786534216edb3831c5addeda1aa68cd4&#34;&gt;Orthogonality&lt;/h3&gt;

&lt;p&gt;Pie is written to be a very simple set of functions that help you set up
communication between your process and a plugin process.  Once you make a couple
calls to pie, you then need to work out your own way to use the RPC connection
created.  Pie does not attempt to be an all-in-one plugin framework, though you
could certainly use it as the basis for one.&lt;/p&gt;

&lt;h3 id=&#34;why-is-it-called-pie:786534216edb3831c5addeda1aa68cd4&#34;&gt;Why is it called pie?&lt;/h3&gt;

&lt;p&gt;Because if you pronounce API like &amp;ldquo;a pie&amp;rdquo;, then all this consuming and serving
of APIs becomes a lot more palatable.  Also, pies are the ultimate pluggable
interface - depending on what&amp;rsquo;s inside, you can get dinner, dessert, a snack, or
even breakfast.  Plus, then I get to say that plugins in Go are as easy as&amp;hellip;
well, you know.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:786534216edb3831c5addeda1aa68cd4&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;I plan to be using pie in one of my own side projects.  Take it out for a spin
in one of your projects and let me know what you think.  Happy eating!&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Go Nitpicks</title>
      <link>http://npf.io/2014/10/go-nitpicks/</link>
      <pubDate>Tue, 28 Oct 2014 06:17:21 EDT</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/10/go-nitpicks/</guid>
      <description>

&lt;p&gt;I saw this tweet last night:&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;en&#34;&gt;&lt;p&gt;A code interview I like to ask:&amp;#10;&amp;#10;&amp;quot;What would you change about &amp;lt;your favourite language&amp;gt;?&amp;quot;&amp;#10;&amp;#10;Having nothing to say to that is a big strike.&lt;/p&gt;&amp;mdash; karlseguin (@karlseguin) &lt;a href=&#34;https://twitter.com/karlseguin/status/526860386704695296&#34;&gt;October 27, 2014&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;I figured I&amp;rsquo;d answer it here about Go.  Luckily, Go is a very small language, so there&amp;rsquo;s not a lot of surface area to dislike. However, there&amp;rsquo;s definitely some things I wish were different. Most of these are nitpicks, thus the title.&lt;/p&gt;

&lt;h4 id=&#34;1-bare-returns:07e255e65a16527c982a11975fdc6037&#34;&gt;#1 Bare Returns&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;func foo() (i int, err error) {
    i, err = strconv.ParseInt(&amp;quot;5&amp;quot;) 
    return // wha??
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For all that Go promotes readable and immediately understandable code, this seems like a ridiculous outlier. The way it works is that if you don&amp;rsquo;t declare what the function is returning, it&amp;rsquo;ll return the values stored in the named return variables.  Which seems logical and handy, until you see a 100 line function with multiple branches and a single bare return at the bottom, with no idea what is actually getting returned.&lt;/p&gt;

&lt;p&gt;To all gophers out there: don&amp;rsquo;t use bare returns.  Ever.&lt;/p&gt;

&lt;h4 id=&#34;2-new:07e255e65a16527c982a11975fdc6037&#34;&gt;#2 New&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;a := new(MyStruct)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;New means &amp;ldquo;Create a zero value of the given type and return a pointer to it&amp;rdquo;.  It&amp;rsquo;s sorta like the C++ &lt;code&gt;new&lt;/code&gt;, which is probably why it exists.  The problem is that it&amp;rsquo;s nearly useless.  It&amp;rsquo;s mostly redundant with simply returning the address of a value thusly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a := &amp;amp;MyStruct{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above is a lot easier to read, it also gives you the ability to populate the value you&amp;rsquo;re constructing (if you wish).  The only time new is &amp;ldquo;useful&amp;rdquo; is if you want to initialize a pointer to a builtin (like a string or an int), because you can&amp;rsquo;t do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a := &amp;amp;int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but you can do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a := new(int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, you could always just do it in (&lt;em&gt;gasp&lt;/em&gt;) two lines:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a := 0
b := &amp;amp;a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To all the gophers out there: don&amp;rsquo;t use new. Always use &amp;amp;Foo{} with structs, maps, and slices. Use the two line version for numbers and strings.&lt;/p&gt;

&lt;h4 id=&#34;3-close:07e255e65a16527c982a11975fdc6037&#34;&gt;#3 Close&lt;/h4&gt;

&lt;p&gt;The close built-in function closes a channel. If the channel is already closed, close will panic.  This pisses me off, because most of the time when I call close, I don&amp;rsquo;t actually care if it&amp;rsquo;s already closed.  I just want to ensure that it&amp;rsquo;s closed.  I&amp;rsquo;d much prefer if close returned a boolean that said whether or not it did anything, and then if &lt;strong&gt;I&lt;/strong&gt; choose to panic, I can.  Or, you know, not.&lt;/p&gt;

&lt;h4 id=&#34;4-there-is-no-4:07e255e65a16527c982a11975fdc6037&#34;&gt;#4 There is no 4&lt;/h4&gt;

&lt;p&gt;That&amp;rsquo;s basically it.  There&amp;rsquo;s some things I think are necessary evils, like &lt;code&gt;goto&lt;/code&gt; and &lt;code&gt;panic&lt;/code&gt;.  There&amp;rsquo;s some things that are necessary ugliness, like the built-in functions &lt;code&gt;append&lt;/code&gt;, &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, etc.  I sorta wish &lt;code&gt;x := range foo&lt;/code&gt; returned the value in x and not the index, but I get that it&amp;rsquo;s to be consistent between maps and slices, and returning the value in maps would be odd, I think.&lt;/p&gt;

&lt;p&gt;All these are even below the level of nitpicks, though.  They don&amp;rsquo;t bug me, really.  I understand that everything in programming is a tradeoff, and I think the decisions made for Go were the right ones in these cases.  Sometimes you need goto.  Sometimes you need to panic.  Making those functions built-ins rather than methods on the types means you don&amp;rsquo;t need any methods on the types, which keeps them simpler, and means they&amp;rsquo;re &amp;ldquo;just data&amp;rdquo;.  It also means you don&amp;rsquo;t lose any functionality if you make new named types based on them.&lt;/p&gt;

&lt;p&gt;So that&amp;rsquo;s my list for Go.&lt;/p&gt;

&lt;h4 id=&#34;postscript:07e255e65a16527c982a11975fdc6037&#34;&gt;Postscript&lt;/h4&gt;

&lt;p&gt;Someone on the twitter discussion mentioned he couldn&amp;rsquo;t think of anything he disliked about C#, which just about made me spit my coffee across the room.  I programmed in C# for ~9 years, starting out porting some 1.1 code to 2.0, and leaving as 5.0 came out.  The list of features in C# as of 5.0 is gigantic.  Even being a developer writing in it 40+ hours a week for 9 years, there was still stuff I had to look up to remember how it worked.&lt;/p&gt;

&lt;p&gt;I feel like my mastery of Go after a year of side projects was about equivalent to my mastery of C# after 9 years of full time development.  If we assume 1:1 correlation between time to master and size of the language, an order of magnitude sounds about right.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Why Everyone Hates Go</title>
      <link>http://npf.io/2014/10/why-everyone-hates-go/</link>
      <pubDate>Tue, 14 Oct 2014 10:46:28 EDT</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/10/why-everyone-hates-go/</guid>
      <description>&lt;p&gt;Obviously, not &lt;em&gt;everyone&lt;/em&gt; hates Go.  But there was a &lt;a href=&#34;https://www.quora.com/Why-does-Go-seem-to-be-the-most-heavily-
criticised-among-the-newer-programming-languages?srid=uCiY&amp;amp;share=1&#34;&gt;quora
question&lt;/a&gt; recently
about why everyone criticizes Go so much. (sorry, I don&amp;rsquo;t normally post links to
Quora, but it was the motivator for this post) Even before I saw the answers to
the question, I knew what they&amp;rsquo;d consist of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Go is a language stuck in the 70&amp;rsquo;s.&lt;/li&gt;
&lt;li&gt;Go ignores 40 years of programming language research.&lt;/li&gt;
&lt;li&gt;Go is a language for blue collar (mediocre) developers.&lt;/li&gt;
&lt;li&gt;Gophers are ok with working in Java 1.0.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unfortunately, the answers to the questions were more concerned with explaining
why Go is &amp;ldquo;bad&amp;rdquo;, rather than why this gets under so many people&amp;rsquo;s skin.&lt;/p&gt;

&lt;p&gt;When reading the answers I had a eureka moment, and I realized why it is. So
here&amp;rsquo;s my answer to the same question. This is why Go is so heavily criticized,
not why Go is &amp;ldquo;bad&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s two awesome posts that inform my answer: Paul Graham&amp;rsquo;s
&lt;a href=&#34;http://www.paulgraham.com/identity.html&#34;&gt;post&lt;/a&gt; about keeping your identity
small, and Kathy Sierra&amp;rsquo;s &lt;a href=&#34;http://seriouspony.com/trouble-at-the-koolaid-
point&#34;&gt;post&lt;/a&gt; about the Koolaid point. I encourage you to read those two posts, as
they&amp;rsquo;re both very informative.  I hesitate to compare the horrific things that
happen to women online with the pedantry of flamewars about programming
languages, but the Koolaid Point is such a valid metaphor that I wanted to link
to the article.&lt;/p&gt;

&lt;p&gt;Paul says&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;people can never have a fruitful argument about
something that&amp;rsquo;s part of their identity&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;i.e.&lt;/em&gt; the subject hits too close to home,
and their response becomes emotional rather than logical.&lt;/p&gt;

&lt;p&gt;Kathy says&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;the hate wasn’t so much about the product/brand but that &lt;em&gt;other people were falling for it&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;i.e.&lt;/em&gt; they&amp;rsquo;d drunk the kool-aid.&lt;/p&gt;

&lt;p&gt;Go is the only recent language that takes the aforementioned 40 years of
programming language research and tosses it out the window. Other new languages
at least try to keep up with the Jones - Clojure, Scala, Rust - all try to
incorporate &amp;ldquo;modern programming theory&amp;rdquo; into their design. Go actively tries
not to. There is no pattern matching, there&amp;rsquo;s no borrowing, there&amp;rsquo;s no pure
functional programming, there&amp;rsquo;s no immutable variables, there&amp;rsquo;s no option types,
there&amp;rsquo;s no exceptions, there&amp;rsquo;s no classes, there&amp;rsquo;s no generics&amp;hellip;. there&amp;rsquo;s a lot
Go doesn&amp;rsquo;t have. And in the beginning this was enough to merely earn it scorn.
Even I am guilty of this. When I first heard about Go, I thought &amp;ldquo;What? No
exceptions? Pass.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;But then something happened - people started &lt;em&gt;using&lt;/em&gt; it. And liking it. And
building big projects with it. This is the Koolaid-point - where people have
started to drink the Koolaid and get fooled into thinking Go is a good
language. And this is where the scorn turns into derision and attacks on the
character of the people using it.&lt;/p&gt;

&lt;p&gt;The most vocal Go detractors are those developers who write in ML-derived
languages (Haskell, Rust, Scala, &lt;em&gt;et al&lt;/em&gt;) who have tied their preferred
programming language into their identity. The mere existence of Go says
&amp;ldquo;your views on what makes a good programming language are wrong&amp;rdquo;. And the more
people that use and like Go, the more strongly they feel that they&amp;rsquo;re being told
their choice of programming language - and therefore their identity - is wrong.&lt;/p&gt;

&lt;p&gt;Note that basically no one in the Go community actually says this. But the Go
philosophy of simplicity and pragmatism above all else is the polar opposite of
what those languages espouse (in which complexity in the language is ok because
it enforces correctness in the code). This is insulting to the people who tie
their identity to that language. Whenever a post on Go makes it to the front
page of Hacker News, it is an affront to everything they hold dear, and so you
get comments like Go developers are stuck in the 70&amp;rsquo;s, or is only for blue-collar devs.&lt;/p&gt;

&lt;p&gt;So, this is why I think people are so much more vocal about their dislike of Go:
because it challenges their identity, and other people are falling for it. This
is also why these posts so often mention Google and how the language would have
died without them. Google is now the koolaid dispenser. The fact that they
are otherwise generally thought of as a very talented pool of developers means
that it is simultaneously more outrageous that they are fooling people and more
insulting that their language flies in the face of ML-derived languages.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt;  I removed the &amp;ldquo;panties in a bunch&amp;rdquo; comment, since I was (correctly)
scolded for being sexist, not to mention unprofessional.  My apologies to
anyone I offended.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Deploy Discourse with Juju in 8 minutes</title>
      <link>http://npf.io/2014/10/deploy-discourse-juju/</link>
      <pubDate>Wed, 01 Oct 2014 06:31:49 EDT</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/10/deploy-discourse-juju/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://stevefrancia.com/&#34;&gt;Steve Francia&lt;/a&gt; asked me to help him get
&lt;a href=&#34;https://discourse.org&#34;&gt;Discourse&lt;/a&gt; deployed as a place for people to discuss
&lt;a href=&#34;http://gohugo.io&#34;&gt;Hugo&lt;/a&gt;, his static site generator (which is what I use to
build this blog).  If you don&amp;rsquo;t know Discourse, it&amp;rsquo;s pretty amazing forum
software with community-driven moderation, all the modern features you expect
(@mentions, SSO integration, deep email integration, realtime async updates, and
a whole lot more).  What I ended up deploying is now at
&lt;a href=&#34;http://discuss.gohugo.io&#34;&gt;discuss.gohugo.io&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;d already played around with deploying Discourse about six months ago, so I
already had an idea of what was involved.  Given that I work on
&lt;a href=&#34;http://juju.ubuntu.com&#34;&gt;Juju&lt;/a&gt; as my day job, of course I decided to use Juju to
deploy Discourse for Steve.  This involved writing a Juju &lt;em&gt;charm&lt;/em&gt; which is sort
of like an install script, but with hooks for updating configuration and hooks
for interacting with other services. I&amp;rsquo;ll talk about the process of writing the
charm in a later post, but for now, all you need to know is that it follows the
official &lt;a href=&#34;https://github.com/discourse/discourse/blob/master/docs/INSTALL-digital-ocean.md&#34;&gt;install guide&lt;/a&gt; for installing Discourse.&lt;/p&gt;

&lt;p&gt;The install guide says that you can install Discourse in 30 minutes.  Following
it took me a &lt;strong&gt;lot&lt;/strong&gt; longer than that, due to some confusion about what the
install guide really wanted you to do, and what the install really required.
But you don&amp;rsquo;t need to know any of that to use Juju to install Discourse, and you
can get it done in 8 minutes, not 30.  Here&amp;rsquo;s how:&lt;/p&gt;

&lt;p&gt;First, install Juju:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo add-apt-repository -y ppa:juju/stable
sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install -y juju-core
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, Juju does not yet have a provider for Digital Ocean, so we have to use a
plugin to get the machine created.  We&amp;rsquo;re in the process of writing a provider
for Digital Ocean, so soon the plugin won&amp;rsquo;t be necessary.  If you use another
cloud provider, such as AWS, Azure, HP Cloud, Joyent, or run your own Openstack
or MAAS, you can easily &lt;a href=&#34;https://juju.ubuntu.com/docs/getting-a
started.html#configuring&#34;&gt;configure Juju&lt;/a&gt; to use that service, and a couple of these steps will
not be necessary.  I&amp;rsquo;ll post separate steps for that later.  But for now, let&amp;rsquo;s
assume you&amp;rsquo;re using Digital Ocean.&lt;/p&gt;

&lt;p&gt;Install the juju &lt;a href=&#34;https://github.com/kapilt/juju-digitalocean&#34;&gt;Digital Ocean plugin&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install -y python-pip
pip install -U juju-docean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Get your Digital Ocean &lt;a href=&#34;https://cloud.digitalocean.com/api_access&#34;&gt;access info&lt;/a&gt;
and set the client id in an environment variable called DO_CLIENT_ID and the API
key in an environment variable called DO_API_KEY.&lt;/p&gt;

&lt;p&gt;Juju requires access with an SSH key to the machines, so make sure you have one
set up in your Digital Ocean account.&lt;/p&gt;

&lt;p&gt;Now, let&amp;rsquo;s create a simple configuration so juju knows where you want to deploy
your new environment.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;juju init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running juju init will create a boilerplate configuration file at
~/.juju/environments.yaml.  We&amp;rsquo;ll append our digital ocean config at the bottom:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;quot;    digitalocean:
        type: manual
        bootstrap-host: null
        bootstrap-user: root
&amp;quot; &amp;gt;&amp;gt; ~/.juju/environments.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this is yaml, so the spaces at the beginning of each line are
important.  Copy and paste should do the right thing, though.&lt;/p&gt;

&lt;p&gt;Now we can start the real fun, let&amp;rsquo;s switch to the digitalocean environment we
just configured, and create the first Juju machine in Digital Ocean:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;juju switch digitalocean
juju docean bootstrap --constraints=&amp;quot;mem=2g, region=nyc2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(obviously replace the region with whatever one you want)&lt;/p&gt;

&lt;p&gt;Now, it&amp;rsquo;ll take about a minute for the machine to come up.&lt;/p&gt;

&lt;p&gt;Discourse &lt;em&gt;requires&lt;/em&gt; email to function, so you need an account at
&lt;a href=&#34;http://mandrill.com&#34;&gt;mandrill&lt;/a&gt;, &lt;a href=&#34;http://mailgun.com&#34;&gt;mailgun&lt;/a&gt;, etc.  They&amp;rsquo;re free, so
don&amp;rsquo;t worry.  From that account you need to get some information to properly set
up Discourse.  You can do this after installing discourse, but it&amp;rsquo;s faster if
you do it before and give the configuration at deploy time. (changing settings
later will take a couple minutes while discourse reconfigures itself)&lt;/p&gt;

&lt;p&gt;When you deploy discourse, you&amp;rsquo;re going to give it a configuration file, which
will look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;discourse:
  DISCOURSE_HOSTNAME: discuss.example.com
  DISCOURSE_DEVELOPER_EMAILS: foo@example.com,bar@example.com
  DISCOURSE_SMTP_ADDRESS: smtp.mailservice.com
  DISCOURSE_SMTP_PORT: 587
  DISCOURSE_SMTP_USER_NAME: postmaster@example.com
  DISCOURSE_SMTP_PASSWORD: supersecretpassword
  UNICORN_WORKERS: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first line must be the same as the name of the service you&amp;rsquo;re deploying.  By
default it&amp;rsquo;s &amp;ldquo;discourse&amp;rdquo;, so you don&amp;rsquo;t need to change it unless you&amp;rsquo;re deploying
multiple copies of discourse to the same Juju environment.  And remember, this
is yaml, so those spaces at the beginning of the rest of the lines are
important.&lt;/p&gt;

&lt;p&gt;The rest should be pretty obvious.  Hostname is the domain name where your site
will be hosted.  This is important, because discourse will send account
activation emails, and the links will use that hostname.  Developer emails are
the email addresses of accounts that should get automatically promoted to admin
when created.  The rest is email-related stuff from your mail service account.
Finally, unicorn workers should just stay 3 unless you&amp;rsquo;re deploying to a machine
with less than 2GB of RAM, in which case set it to 2.&lt;/p&gt;

&lt;p&gt;Ok, so now that you have this file somewhere on disk, we can deploy discourse.
Don&amp;rsquo;t worry, it&amp;rsquo;s really easy.  Just do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;juju deploy cs:~natefinch/trusty/discourse --config path/to/configfile --to 0
juju expose discourse
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it. If you&amp;rsquo;re deploying to a 2GB Digital Ocean droplet, it&amp;rsquo;ll take about
7 minutes.&lt;/p&gt;

&lt;p&gt;To check on the status of the charm deployment, you can do &lt;code&gt;juju status&lt;/code&gt;, which
will show, among other things &amp;ldquo;agent-state: pending&amp;rdquo; while the charm is being
deployed.  Or, if you want to watch the logs roll by, you can do &lt;code&gt;juju debug-
log&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Eventually juju status will show &lt;code&gt;agent-state: started&lt;/code&gt;.  Now grab the ip
address listed at &lt;code&gt;public address:&lt;/code&gt; in the same output and drop that into your
browser.  Bam!  Welcome to Discourse.&lt;/p&gt;

&lt;p&gt;If you ever need to change the configuration you set in the config file above,
you can do that by editing the file and doing&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;juju set discourse --config=/path/to/config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, if you just want to tweak a few values, you can do&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;juju set discourse foo=bar baz=bat ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that every time you call juju set, it&amp;rsquo;ll take a couple minutes for
Discourse to reconfigure itself, so you don&amp;rsquo;t want to be doing this over and
over if you can hep it.&lt;/p&gt;

&lt;p&gt;Now you&amp;rsquo;re on your own, and will have to consult the gurus at
&lt;a href=&#34;discourse.org&#34;&gt;discourse.org&lt;/a&gt; if you have any problems.  But don&amp;rsquo;t worry, since
you deployed using Juju, which uses their official install instructions, your
discourse install is just like the ones people deploy manually (albeit with a
lot less time and trouble).&lt;/p&gt;

&lt;p&gt;Good Luck!&lt;/p&gt;

&lt;p&gt;Please let me know if you find any errors in this page, and I will fix them
immediately.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Intro to TOML</title>
      <link>http://npf.io/2014/08/intro-to-toml/</link>
      <pubDate>Sat, 16 Aug 2014 07:31:51 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/08/intro-to-toml/</guid>
      <description>

&lt;p&gt;TOML stands for Tom&amp;rsquo;s Own Minimal Language.  It is a configuration language
vaguely similar to YAML or property lists, but far, far better.  But before we
get into it in detail, let&amp;rsquo;s look back at what came before.&lt;/p&gt;

&lt;h3 id=&#34;long-ago-in-a-galaxy-far-far-away:e2600f20c5cda367beec1116d4d8e23c&#34;&gt;Long Ago, In A Galaxy Far, Far Away&lt;/h3&gt;

&lt;p&gt;Since the beginning of computing, people have needed a way to configure
their software.  On Linux, this generally is done in text files.  For simple
configurations, good old foo = bar works pretty well.  One setting per line,
name on the left, value on the right, separated by an equals.  Great.  But when
your configuration gets more complicated, this quickly breaks down.  What if you
need a value that is more than one line?  How do you indicate a value should be
parsed as a number instead of a string?  How do you namespace related
configuration values so you don&amp;rsquo;t need ridiculously long names to prevent
collisions?&lt;/p&gt;

&lt;h3 id=&#34;the-dark-ages:e2600f20c5cda367beec1116d4d8e23c&#34;&gt;The Dark Ages&lt;/h3&gt;

&lt;p&gt;In the 90&amp;rsquo;s, we used XML.  And it sucked.  XML is verbose, it&amp;rsquo;s hard for humans
to read and write, and it still doesn&amp;rsquo;t solve a lot of the problems above (like
how to specify the type of a value).  In addition, the XML spec is huge,
processing is very complicated, and all the extra features invite abuse and
overcomplication.&lt;/p&gt;

&lt;h3 id=&#34;enlightenment:e2600f20c5cda367beec1116d4d8e23c&#34;&gt;Enlightenment&lt;/h3&gt;

&lt;p&gt;In the mid 2000&amp;rsquo;s, JSON came to popularity as a data exchange format, and it was
so much better than XML.  It had real types, it was easy for programs to
process, and you didn&amp;rsquo;t have to write a spec on what values should get processed
in what way (well, mostly).  It was sigificantly less verbose than XML.  But it
is a format intended for computers to read and write, not humans.  It is a pain
to write by hand, and even pretty-printed, it can be hard to read and the
compact data format turns into a nested mess of curly braces.  Also, JSON is not
without its problems&amp;hellip; for example, there&amp;rsquo;s no date type, there&amp;rsquo;s no support
for comments, and all numbers are floats.&lt;/p&gt;

&lt;h3 id=&#34;a-false-start:e2600f20c5cda367beec1116d4d8e23c&#34;&gt;A False Start&lt;/h3&gt;

&lt;p&gt;YAML came to popularity some time after JSON as a more human-readable format,
and its &lt;code&gt;key: value&lt;/code&gt; syntax and pretty indentation is definitely a lot easier on
the eyes than JSON&amp;rsquo;s nested curly-braces.  However, YAML trades ease of reading
for difficulty in writing.  Indentation as delimiters is fraught with error&amp;hellip;
figuring out how to get multiple lines of data into any random value is an
exercise in googling and trial &amp;amp; error.&lt;/p&gt;

&lt;p&gt;The YAML spec is also ridiculously long.  100% compatible parsers are very
difficult to write.  Writing YAML by hand is a ridden with landmines of corner
cases where your choice of names or values happens to hit a reserved word or
special marker.  It does support comments, though.&lt;/p&gt;

&lt;h3 id=&#34;the-savior:e2600f20c5cda367beec1116d4d8e23c&#34;&gt;The Savior&lt;/h3&gt;

&lt;p&gt;On February 23, 2013, Tom Preston-Werner (former CEO of GitHub) made his first
commit to &lt;a href=&#34;https://github.com/toml-lang/toml&#34;&gt;https://github.com/toml-lang/toml&lt;/a&gt;.  TOML stands for Tom&amp;rsquo;s Obvious,
Minimal Language.  It is a language designed for configuring software.  Finally.&lt;/p&gt;

&lt;p&gt;TOML takes inspiration from all of the above (well, except XML) and even gets
some of its syntax from Microsoft&amp;rsquo;s INI files.  It is easy to write by hand and
easy to read.  The spec is short and understandable by mere humans, and it&amp;rsquo;s
fairly easy for computers to parse.  It supports comments, has first class
dates, and supports both integers and floats.  It is generally insensitive to
whitespace, without requiring a ton of delimiters.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s dive in.&lt;/p&gt;

&lt;h3 id=&#34;the-basics:e2600f20c5cda367beec1116d4d8e23c&#34;&gt;The Basics&lt;/h3&gt;

&lt;p&gt;The basic form is key = value&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Comments start with hash
foo = &amp;quot;strings are in quotes and are always UTF8 with escape codes: \n \u00E9&amp;quot;

bar = &amp;quot;&amp;quot;&amp;quot;multi-line strings
use three quotes&amp;quot;&amp;quot;&amp;quot;

baz = &#39;literal\strings\use\single\quotes&#39;

bat = &#39;&#39;&#39;multiline\literals\use
three\quotes&#39;&#39;&#39;

int = 5 # integers are just numbers
float = 5.0 # floats have a decimal point with numbers on both sides

date = 2006-05-27T07:32:00Z # dates are ISO 8601 full zulu form

bool = true # good old true and false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One cool point:  If the first line of a multiline string (either literal or not)
is a line return, it will be trimmed.  So you can make your big blocks of text
start on the line after the name of the value and not need to worry about the
extraneous newline at the beginning of your text:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;preabmle = &amp;quot;&amp;quot;&amp;quot;
We the people of the United States, in order to form a more perfect union,
establish justice, insure domestic tranquility, provide for the common defense,
promote the general welfare, and secure the blessings of liberty to ourselves
and our posterity, do ordain and establish this Constitution for the United
States of America.&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;lists:e2600f20c5cda367beec1116d4d8e23c&#34;&gt;Lists&lt;/h3&gt;

&lt;p&gt;Lists (arrays) are signified with brackets and delimited with commas.  Only
primitives are allowed in this form, though you may have nested lists.  The
format is forgiving, ignoring whitespace and newlines, and yes, the last comma
is optional (thank you!):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo = [ &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot;
        &amp;quot;bat&amp;quot;
]

nums = [ 1, 2, ]

nested = [[ &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;], [1, 2]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I love that the format is forgiving of whitespace and that last comma.  I like
that the arrays are all of a single type, but allowing mixed types of sub-arrays
bugs the heck out of me.&lt;/p&gt;

&lt;h3 id=&#34;now-we-get-crazy:e2600f20c5cda367beec1116d4d8e23c&#34;&gt;Now we get crazy&lt;/h3&gt;

&lt;p&gt;What&amp;rsquo;s left?  In JSON there are objects, in YAML there are associative arrays&amp;hellip;
in common parlance they are maps or dictionaries or hash tables.  Named
collections of key/value pairs.&lt;/p&gt;

&lt;p&gt;In TOML they are called tables and look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# some config above
[table_name]
foo = 1
bar = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Foo and bar are keys in the table called table_name.  Tables have to be at the
end of the config file. Why?  because there&amp;rsquo;s no end delimiter.  All keys under
a table declaration are associated with that table, until a new table is
declared or the end of the file.  So declaring two tables looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# some config above
[table1]
foo = 1
bar = 2

[table2]
	foo = 1
	baz = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The declaration of table2 defines where table1 ends.  Note that you can indent
the values if you want, or not.  TOML doesn&amp;rsquo;t care.&lt;/p&gt;

&lt;p&gt;If you want nested tables, you can do that, too.  It looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[table1]
	foo = &amp;quot;bar&amp;quot;

[table1.nested_table]
	baz = &amp;quot;bat&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;nested_table&lt;/code&gt; is defined as a value in &lt;code&gt;table1&lt;/code&gt; because its name starts with
&lt;code&gt;table1.&lt;/code&gt;.  Again, the table goes until the next table definition, so &lt;code&gt;baz=&amp;quot;bat&amp;quot;&lt;/code&gt;
is a value in &lt;code&gt;table1.nested_table&lt;/code&gt;.  You can indent the nested table to make it
more obvious, but again, all whitespace is optional:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[table1]
	foo = &amp;quot;bar&amp;quot;

	[table1.nested_table]
		baz = &amp;quot;bat&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is equivalent to the JSON:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ 
	&amp;quot;table1&amp;quot; : {
		&amp;quot;foo&amp;quot; : &amp;quot;bar&amp;quot;,
		&amp;quot;nested_table&amp;quot; : {
			&amp;quot;baz&amp;quot; : &amp;quot;bat&amp;quot;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having to retype the parent table name for each sub-table is kind of annoying,
but I do like that it is very explicit.  It also means that ordering and
indenting and delimiters don&amp;rsquo;t matter.  You don&amp;rsquo;t have to declare parent tables
if they&amp;rsquo;re empty, so you can do something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[foo.bar.baz]
bat = &amp;quot;hi&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which is the equivalent to this JSON:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
	&amp;quot;foo&amp;quot; : {
		&amp;quot;bar&amp;quot; : {
			&amp;quot;baz&amp;quot; : {
				&amp;quot;bat&amp;quot; : &amp;quot;hi&amp;quot;
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;last-but-not-least:e2600f20c5cda367beec1116d4d8e23c&#34;&gt;Last but not least&lt;/h3&gt;

&lt;p&gt;The last thing is arrays of tables, which are declared with double brackets
thusly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[[comments]]
author = &amp;quot;Nate&amp;quot;
text = &amp;quot;Great Article!&amp;quot;

[[comments]]
author = &amp;quot;Anonymous&amp;quot;
text = &amp;quot;Love it!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is equivalent to the JSON:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
	&amp;quot;comments&amp;quot; : [
		{
			&amp;quot;author&amp;quot; : &amp;quot;Nate&amp;quot;,
			&amp;quot;text&amp;quot; : Great Article!&amp;quot;
		},
		{
			&amp;quot;author&amp;quot; : &amp;quot;Anonymous&amp;quot;,
			&amp;quot;text&amp;quot; : Love It!&amp;quot;
		}
	]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arrays of tables inside another table get combined in the way you&amp;rsquo;d expect, like
[[table1.array]].&lt;/p&gt;

&lt;p&gt;TOML is very permissive here. Because all tables have very explicitly defined
parentage, the order they&amp;rsquo;re defined in doesn&amp;rsquo;t matter. You can have tables (and
entries in an array of tables) in whatever order you want.  This is totally
acceptable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[[comments]]
author = &amp;quot;Anonymous&amp;quot;
text = &amp;quot;Love it!&amp;quot;

[foo.bar.baz]
bat = &amp;quot;hi&amp;quot;

[foo.bar]
howdy = &amp;quot;neighbor&amp;quot;

[[comments]]
author = &amp;quot;Anonymous&amp;quot;
text = &amp;quot;Love it!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, it generally makes sense to actually order things in a more organized
fashion, but it&amp;rsquo;s nice that you can&amp;rsquo;t shoot yourself in the foot if you reorder
things &amp;ldquo;incorrectly&amp;rdquo;.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:e2600f20c5cda367beec1116d4d8e23c&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;That&amp;rsquo;s TOML.  It&amp;rsquo;s pretty awesome.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a &lt;a href=&#34;https://github.com/toml-lang/toml#implementations&#34;&gt;list of parsers&lt;/a&gt;
on the TOML page on github for pretty much whatever language you want.  I
recommend &lt;a href=&#34;http://github.com/BurntSushi/toml&#34;&gt;BurntSushi&lt;/a&gt;&amp;rsquo;s for Go, since it
works just like the built-in parsers.&lt;/p&gt;

&lt;p&gt;It is now my default configuration language for all the applications I write.&lt;/p&gt;

&lt;p&gt;The next time you write an application that needs some configuration, take a
look at TOML.  I think your users will thank you.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Making It a Series</title>
      <link>http://npf.io/2014/08/making-it-a-series/</link>
      <pubDate>Fri, 08 Aug 2014 11:12:44 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/08/making-it-a-series/</guid>
      <description>&lt;p&gt;I obviously have a lot to talk about with Hugo, so I decided I wanted to make
this into a series of posts, and have links at the bottom of each post
automatically populated with the other posts in the series.  This turned out to
be somewhat of a challenge, but doable with some effort&amp;hellip; hopefully someone
else can learn from my work.&lt;/p&gt;

&lt;p&gt;This now brings us to &lt;a href=&#34;http://hugo.spf13.com/taxonomies/overview&#34;&gt;Taxonomies&lt;/a&gt;.
Taxonomies are basically just like tags, except that you can have any number of
different types of tags.  So you might have &amp;ldquo;Tags&amp;rdquo; as a taxonomy, and thus you
can give a content tags with values of &amp;ldquo;go&amp;rdquo; and &amp;ldquo;programming&amp;rdquo;.  You can also
have a taxonomy of &amp;ldquo;series&amp;rdquo; and give content a series of &amp;ldquo;Hugo 101&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Taxonomy is sort of like relatable metadata to gather multiple pieces of content
together in a structured way&amp;hellip; it&amp;rsquo;s almost like a minimal relational database.
Taxonomies are listed in your site&amp;rsquo;s metadata, and consist of a list of keys.
Each piece of content can specify one or more values for those keys (the Hugo
documentation calls the values &amp;ldquo;Terms&amp;rdquo;).  The values are completely ad-hoc, and
don&amp;rsquo;t need to be pre-defined anywhere.  Hugo automatically creates pages where
you can view all content based on Taxonomies and see how the various values are
cross-referenced against other content.  This is a way to implement tags on
posts, or series of posts.&lt;/p&gt;

&lt;p&gt;So, for my example, we add a Taxonomy to my site config called &amp;ldquo;series&amp;rdquo;.  Then
in this post, the &amp;ldquo;Hugo: Beyond the Defaults&amp;rdquo; post, and the &amp;ldquo;Hugo is Friggin&amp;rsquo;
Awesome&amp;rdquo; post, I just add &lt;code&gt;series = [&amp;quot;Hugo 101&amp;quot;]&lt;/code&gt;  (note the brackets - the
values for the taxonomy are actually a list, even if you only have one value).
Now all these posts are magically related together under a taxonomy called
&amp;ldquo;series&amp;rdquo;.  And Hugo automatically generates a listing for this taxonomy value
at &lt;a href=&#34;http://npf.io/series/hugo-101&#34;&gt;/series/hugo-101&lt;/a&gt; (the taxonomy value gets
url-ized).  Any other series I make will be under a similar directory.&lt;/p&gt;

&lt;p&gt;This is fine and dandy and pretty aweomse out of the box&amp;hellip; but I really want to
automatically generate a list of posts in the series at the bottom of each post
in the series.  This is where things get tricky, but that&amp;rsquo;s also where things
get interesting.&lt;/p&gt;

&lt;p&gt;The examples for &lt;a href=&#34;http://hugo.spf13.com/taxonomies/displaying&#34;&gt;displaying
Taxonomies&lt;/a&gt; all &amp;ldquo;hard code&amp;rdquo; the
taxonomy value in the template&amp;hellip; this works great if you know ahead of time
what value you want to display, like &amp;ldquo;all posts with tag = &amp;lsquo;featured&amp;rsquo;&amp;rdquo;.
However, it doesn&amp;rsquo;t work if you don&amp;rsquo;t know ahead of time what the taxonomy value
will be (like the series on the current post).&lt;/p&gt;

&lt;p&gt;This is doable, but it&amp;rsquo;s a little more complicated.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll give you a dump of the relevant portion of my post template and then talk
about how I got there:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ if .Params.series }}
    {{ $name := index .Params.series 0 }}
    &amp;lt;hr/&amp;gt;
	&amp;lt;p&amp;gt;&amp;lt;a href=&amp;quot;&amp;quot; id=&amp;quot;series&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;This is a post in the 
	&amp;lt;b&amp;gt;{{$name}}&amp;lt;/b&amp;gt; series.&amp;lt;br/&amp;gt;
	Other posts in this series:&amp;lt;/p&amp;gt;

    {{ $name := $name | urlize }}
    {{ $series := index .Site.Taxonomies.series $name }}
    &amp;lt;ul class=&amp;quot;series&amp;quot;&amp;gt;
    {{ range $series.Pages }}
    	&amp;lt;li&amp;gt;{{.Date.Format &amp;quot;Jan 02, 2006&amp;quot;}} -
    	&amp;lt;a href=&amp;quot;{{.Permalink}}&amp;quot;&amp;gt;{{.LinkTitle}}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    {{end}}
    &amp;lt;/ul&amp;gt;
{{end}} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we start off defining this part of the template to only be used if the post
has a series.  Right, sure, move on.&lt;/p&gt;

&lt;p&gt;Now, the tricky part&amp;hellip; the taxonomy values for the current page resides in the
.Params values, just like any other custom metadata you assign to the page.&lt;/p&gt;

&lt;p&gt;Taxonomy values are always a list (so you can give things multiple tags etc),
but I know that I&amp;rsquo;ll never give something more than one series, so I can just
grab the first item from the list.  To do that, I use the index function, which
is just like calling series[0] and assign it to the $name variable.&lt;/p&gt;

&lt;p&gt;Now another tricky part&amp;hellip; the series in the metadata is in the pretty form you
put into the metadata, but the list of Taxonomies in .Site.Taxonomies is in the
urlized form&amp;hellip;  How did I figure that out?  Printf
debugging.  Hugo&amp;rsquo;s auto-reloading makes it really easy to use the template
itself to figure out what&amp;rsquo;s going on with the template and the data.&lt;/p&gt;

&lt;p&gt;When I started writing this template, I just put &lt;code&gt;{{$name}}&lt;/code&gt; in my post template
after the line where I got the name, and I could see it rendered on webpage of
my post that the name was &amp;ldquo;Hugo 101&amp;rdquo;.  Then I put &lt;code&gt;{{.Site.Taxonomies.series}}&lt;/code&gt;
and I saw something like &lt;code&gt;map[hugo-101:[{0 0xc20823e000} {0 0xc208048580} {0
0xc208372000}]]&lt;/code&gt;  which is ugly, but it showed me that the value in the map is
&amp;ldquo;hugo-101&amp;rdquo;&amp;hellip; and I realized it was using the urlized version, so I used the
pre-defined hugo function &lt;code&gt;urlize&lt;/code&gt; to convert the pretty series.&lt;/p&gt;

&lt;p&gt;And from there it&amp;rsquo;s just a matter of using &lt;code&gt;index&lt;/code&gt; again, this time to use
&lt;code&gt;$name&lt;/code&gt; as a key in the map of series&amp;hellip;.  .Site.Taxonomies is a map
(dictionary) of Taxonomy names (like &amp;ldquo;series&amp;rdquo;) to maps of Taxonomy values (like
&amp;ldquo;hugo-101&amp;rdquo;) to lists of pages.  So, .Site.Taxonomies.series reutrns a map of
series names to lists of pages&amp;hellip; index that by the current series names, and
bam, list of pages.&lt;/p&gt;

&lt;p&gt;And then it&amp;rsquo;s just a matter of iterating over the pages and displaying them
nicely. And what&amp;rsquo;s great is that this is now all automatic&amp;hellip; all old posts get
updated with links to the new posts in the series, and any new series I make,
regardless of the name, will get the nice list of posts at the bottom for that
series.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Hugo: Beyond the Defaults</title>
      <link>http://npf.io/2014/08/hugo-beyond-the-defaults/</link>
      <pubDate>Fri, 08 Aug 2014 10:07:46 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/08/hugo-beyond-the-defaults/</guid>
      <description>&lt;p&gt;In my last post, I had deployed what is almost the most basic Hugo site
possible.  The only reason it took more than 10 minutes is because I wanted to
tweak the theme.  However, there were a few things that immediately annoyed me.&lt;/p&gt;

&lt;p&gt;I didn&amp;rsquo;t like having to type &lt;code&gt;hugo -t hyde&lt;/code&gt; all the time.  Well, turns out
that&amp;rsquo;s not necessary.  You can just put  &lt;code&gt;theme = &amp;quot;hyde&amp;quot;&lt;/code&gt; in your site
config, and never need to type it again.  Sweet.  Now to run the local server, I
can just run &lt;code&gt;hugo server -w&lt;/code&gt;, and for final generation, I can just run &lt;code&gt;hugo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Next is that my posts were under npf.io/post/postname &amp;hellip; which is not the end
of the world, but I really like seeing the date in post URLs, so that it&amp;rsquo;s easy
to tell if I&amp;rsquo;m looking at something really, really old.  So, I went about
looking at how to do that.  Turns out, it&amp;rsquo;s trivial.  Hugo has a feature called
&lt;a href=&#34;http://hugo.spf13.com/extras/permalinks&#34;&gt;permalinks&lt;/a&gt;, where you can define the
format of the url for a section (a section is a top level division of your site,
denoted by a top level folder under content/).  So, all you have to do is, in
your site&amp;rsquo;s config file, put some config that looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[permalinks]
    post = &amp;quot;/:year/:month/:filename/&amp;quot;
    code = &amp;quot;/:filename/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While we&amp;rsquo;re at it, I had been putting my code in the top level content
directory, because I wanted it available at npf.io/projectname  &amp;hellip;. however
there&amp;rsquo;s no need to do that, I can put the code under the code directory and just
give it a permalink to show at the top level of the site.  Bam, awesome, done.&lt;/p&gt;

&lt;p&gt;One note: Don&amp;rsquo;t forget the slash at the end of the permalink.&lt;/p&gt;

&lt;p&gt;But wait, this will move my &amp;ldquo;Hugo is Friggin&amp;rsquo; Awesome&amp;rdquo; post to a different URL,
and Steve Francia already tweeted about it with the old URL.  I don&amp;rsquo;t want that
url to send people to a 404 page!
&lt;a href=&#34;http://hugo.spf13.com/extras/aliases&#34;&gt;Aliases&lt;/a&gt; to the rescue.  Aliases are just
a way to make redirects from old URLs to new ones.  So I just put &lt;code&gt;aliases =
[&amp;quot;/post/hugo-is-awesome/&amp;quot;]&lt;/code&gt; in the metadata at the top of that post, and now
links to there will redirect to the new location.  Awesome.&lt;/p&gt;

&lt;p&gt;Ok, so cool&amp;hellip; except that I don&amp;rsquo;t really want the content for my blog posts
under content/post/ &amp;hellip; I&amp;rsquo;d prefer them under content/blog, but still be of type
&amp;ldquo;post&amp;rdquo;.  So let&amp;rsquo;s change that too.  This is pretty easy, just rename the folder
from post to blog, and then set up an
&lt;a href=&#34;http://hugo.spf13.com/content/archetypes&#34;&gt;archetype&lt;/a&gt; to default the metadata
under /blog/ to type = &amp;ldquo;post&amp;rdquo;.  Archetypes are default metadata for a section,
so in this case, I make a file archetypes/blog.md and add type= &amp;ldquo;post&amp;rdquo; to the
archetype&amp;rsquo;s metadata, and now all my content created with &lt;code&gt;hugo new
blog/foo.md&lt;/code&gt; will be prepopulated as type &amp;ldquo;post&amp;rdquo;.  (does it matter if the type
is post vs. blog?  no.  But it matters to me ;)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/mlafeldt&#34;&gt;@mlafeldt&lt;/a&gt; on Twitter pointed out my RSS feed was
wonky&amp;hellip;. wait, I have an RSS feed?  Yes, Hugo &lt;a href=&#34;http://hugo.spf13.com/templates/rss&#34;&gt;has that
too&lt;/a&gt;.  There are feed XML files
automatically output for most listing directories&amp;hellip; and the base feed for the
site is a list of recent content.  So, I looked at what Hugo had made for me
(index.xml in the root output directory)&amp;hellip; this is not too bad, but I don&amp;rsquo;t
really like the title, and it&amp;rsquo;s including my code content in the feed as well as
posts, which I don&amp;rsquo;t really want.  Luckily, this is trivial to fix.  The RSS xml
file is output using a Go template just like everything else in the output.
It&amp;rsquo;s trivial to adjust the template so that it only lists content of type
&amp;ldquo;post&amp;rdquo;, and tweak the feed name, etc.&lt;/p&gt;

&lt;p&gt;I was going to write about how I got the series stuff at the bottom of this
page, but this post is long enough already, so I&amp;rsquo;ll just make that into its own
post, as the next post in the series! :)&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Hugo Is Friggin&#39; Awesome</title>
      <link>http://npf.io/2014/08/hugo-is-awesome/</link>
      <pubDate>Fri, 01 Aug 2014 06:45:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/08/hugo-is-awesome/</guid>
      <description>&lt;p&gt;This blog is powered by &lt;a href=&#34;http://hugo.spf13.com&#34;&gt;Hugo&lt;/a&gt;, a static site generator
written by Steve Francia (aka spf13).  It is, of course, written in Go.  It is
pretty similar to &lt;a href=&#34;jekyllrb.com&#34;&gt;Jekyll&lt;/a&gt;, in that you write markdown, run a
little program (hugo) and html pages come out the other end in the form of a
full static site.  What&amp;rsquo;s different is that Jekyll is written in ruby and is
relatively slow, and Hugo is written in Go and is super fast&amp;hellip; only taking a
few milliseconds to render each page.&lt;/p&gt;

&lt;p&gt;Hugo includes a webserver to serve the content, which will regenerate the site
automatically when you change your content.  Your browser will update with the
changes immediately, making your development cycle for a site a very tight
loop.&lt;/p&gt;

&lt;p&gt;The basic premise of Hugo is that your content is organized in a specific way on
purpose.  Folders of content and the name of the files combine to turn into the
url at which they are hosted. For example, content/foo/bar/baz.md will be hosted
at &amp;lt;site&amp;gt;/foo/bar/baz.&lt;/p&gt;

&lt;p&gt;Every content file has a section of metadata at the top that allows you to
specify information about the content, like the title, date, even arbitrary data
for your specific site (for example, I have lists of badges that are shown on
pages for code projects).&lt;/p&gt;

&lt;p&gt;All the data in a content file is just that - data.  Other than markdown
specifying a rough view of your page, the actual way the content is viewed is
completely separated from the data.  Views are written in Go&amp;rsquo;s templating
language, which is quick to pick up and easy to use if you&amp;rsquo;ve used other
templating languages (or even if, like me, you haven&amp;rsquo;t).  This lets you do
things like iterate over all the entries in a menu and print them out in a ul/li
block, or iterate over all the posts in your blog and display them on the main
page.&lt;/p&gt;

&lt;p&gt;You can learn more about Hugo by going to &lt;a href=&#34;http://hugo.spf13.com&#34;&gt;its site&lt;/a&gt;,
which, of course, is built using Hugo.&lt;/p&gt;

&lt;p&gt;The static content for this site is hosted on github pages at
&lt;a href=&#34;https://github.com/natefinch/natefinch.github.io&#34;&gt;https://github.com/natefinch/natefinch.github.io&lt;/a&gt;. But the static content is
relatively boring&amp;hellip; that&amp;rsquo;s what you&amp;rsquo;re looking at in your browser right now.
What&amp;rsquo;s interesting is the code behind it.  That lives in a separate repo on
github at &lt;a href=&#34;https://github.com/natefinch/npf&#34;&gt;https://github.com/natefinch/npf&lt;/a&gt;.  This is where the markdown content
and templates live.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how I have things set up locally&amp;hellip; all open source code on my machine
lives in my GOPATH (which is set to my HOME).  So, it&amp;rsquo;s easy to find anything I
have ever downloaded. Thus, the static site lives at
$GOPATH/src/github.com/natefinch/natefinch.github.io and the markdown +
templates lives in $GOPATH/src/github.com/natefinch/npf.  I created a symbolic
link under npf called public that points to the natefinch.github.io directory.
This is the directory that hugo outputs the static site to by default&amp;hellip; that
way Hugo dumps the static content right into the correct directory for me to
commit and push to github.  I just had to add public to my .gitignore so
everyone wouldn&amp;rsquo;t get confused.&lt;/p&gt;

&lt;p&gt;Then, all I do is go to the npf directory, and run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo new post/urlofpost.md
hugo server --buildDrafts --watch -t hyde
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That generates a new content item that&amp;rsquo;ll show up on my site under
/post/urlofpost.  Then it runs the local webserver so I can watch the content by
pointing a browser at localhost:1313 on a second monitor as I edit the post in a
text editor. hyde is the name of the theme I&amp;rsquo;m using, though I have modified
it.  Note that hugo will mark the content as a draft by default, so you need
&amp;ndash;buildDrafts for it to get rendered locally, and remember to delete the draft =
true line in the page&amp;rsquo;s metadata when you&amp;rsquo;re ready to publish, or it won&amp;rsquo;t show
up on your site.&lt;/p&gt;

&lt;p&gt;When I&amp;rsquo;m satisfied, kill the server, and run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo -t hyde
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to generate the final site output, switch into the public directory, and&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git commit -am &amp;quot;some new post&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it.  Super easy, super fast, and no muss.  Coming from Blogger, this is
an amazingly better workflow with no wrestling with the WYSIWYG editor to make
it display stuff in a reasonable fashion.  Plus I can write posts 100% offline
and publish them when I get back to civilization.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a lot more to Hugo, and a lot more I want to do with the site, but that
will come in time and with more posts :)&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>First Post</title>
      <link>http://npf.io/2014/08/first/</link>
      <pubDate>Fri, 01 Aug 2014 06:30:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/08/first/</guid>
      <description>&lt;p&gt;This is the first post of my new blog.  You may (eventually) see old posts
showing up behind here, those have been pulled in from my personal blog at
&lt;a href=&#34;http://blog.natefinch.com&#34;&gt;blog.natefinch.com&lt;/a&gt;. I&amp;rsquo;ve decided to split off my
programming posts so that people who only want to see the coding stuff don&amp;rsquo;t
have to see my personal posts, and people that only want to see my personal
stuff don&amp;rsquo;t have to get inundated with programming posts.&lt;/p&gt;

&lt;p&gt;Right now the site is pretty basic, but I will add more features to it, such as post history etc.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>CI for Windows Go Packages with AppVeyor</title>
      <link>http://npf.io/2014/07/ci-for-windows-go-packages-with-appveyor/</link>
      <pubDate>Wed, 09 Jul 2014 17:43:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/07/ci-for-windows-go-packages-with-appveyor/</guid>
      <description>&lt;p&gt;I recently needed to update my &lt;a href=&#34;https://github.com/natefinch/npipe&#34; target=&#34;_blank&#34;&gt;npipe&lt;/a&gt; package, and since I want it to be production quality, that means setting up CI, so that people using my package can know it&amp;rsquo;s passing tests. &amp;nbsp;Normally I&amp;rsquo;d use Travis CI or Drone.io for that, but npipe is a Windows-only Go package, and neither of the aforementioned services support running tests on Windows.&lt;br /&gt;&lt;br /&gt;With some googling, I saw that &lt;a href=&#34;https://twitter.com/nathany&#34; target=&#34;_blank&#34;&gt;Nathan Youngman&lt;/a&gt;&amp;nbsp;had worked with&amp;nbsp;&lt;a href=&#34;http://www.appveyor.com/&#34; target=&#34;_blank&#34;&gt;AppVeyor&lt;/a&gt;&amp;nbsp;to add Go support to their CI system. &amp;nbsp;The example on the blog talks about making a build.cmd file in your repo to enable Go builds, but I found that you can easily set up a Go build without having to put CI-specific files in your repo.&lt;br /&gt;&lt;br /&gt;To get started with AppVeyor, just log into their site and tell it where to get your code (I logged in with Github, and it was easy to specify what repo of mine to test). &amp;nbsp;Once you choose the repo, go to the Settings page on AppVeyor for that repo. &amp;nbsp;Under the Environment tab on the left, set the clone directory to C:\GOPATH\src&amp;amp;lt;your import path&amp;gt; and set an environment variable called GOPATH to C:\GOPATH. &amp;nbsp;Under the build tab, set the build type to &amp;ldquo;SCRIPT&amp;rdquo; and the script type to &amp;ldquo;CMD&amp;rdquo;, and make the contents of the script &lt;pre style=&#34;tab-size: 4;&#34;&gt;go get -v -d -t &amp;lt;your import path&amp;gt;/&amp;hellip;&lt;/pre&gt; (this will download the dependencies for your package). &amp;nbsp;In the test tab, set the test type to &amp;ldquo;SCRIPT&amp;rdquo;, the script type to &amp;ldquo;CMD&amp;rdquo; and the script contents to &lt;pre style=&#34;tab-size: 4;&#34;&gt;go test -v -cover ./&amp;hellip;&lt;/pre&gt; &amp;nbsp;(this will run all the tests in verbose mode and also output the test coverage).&lt;br /&gt;&lt;br /&gt;That&amp;rsquo;s pretty much it. &amp;nbsp;AppVeyor will automatically run a build on commits, like you&amp;rsquo;d expect. &amp;nbsp;You can watch the progress on a console output on their page, and get a pretty little badge from the badges page. &amp;nbsp;It&amp;rsquo;s free for open source projects, and seems relatively responsive from my admittedly limited experience.&lt;br /&gt;&lt;br /&gt;This is a great boon for Go developers, so you can be sure your code builds and passes tests on Windows, with very little work to set it up. &amp;nbsp;I&amp;rsquo;m probably going to add this to all my production repos, even the ones that aren&amp;rsquo;t Windows-only, to ensure my code works well on Windows as well as Linux.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Intro to BoltDB: Painless Performant Persistence</title>
      <link>http://npf.io/2014/07/intro-to-boltdb-painless-performant-persistence/</link>
      <pubDate>Mon, 07 Jul 2014 08:25:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/07/intro-to-boltdb-painless-performant-persistence/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://github.com/boltdb/bolt&#34; target=&#34;_blank&#34;&gt;BoltDB&lt;/a&gt; is a pure Go persistence solution that saves data to a memory mapped file.  I call it a persistence solution and not a database, because the word database has a lot of baggage associated with it that doesn&amp;rsquo;t apply to bolt. And that lack of baggage is what makes bolt so awesome.&lt;br /&gt;&lt;br /&gt;Bolt is just a Go package.  There&amp;rsquo;s nothing you need to install on the system, no configuration to figure out before you can start coding, nothing.  You just go get github.com/boltdb/bolt and then import &amp;ldquo;github.com/boltdb/bolt&amp;rdquo;. &lt;br /&gt;&lt;br /&gt;All you need to fully use bolt as storage is a file name.  This is fantastic from both a developer&amp;rsquo;s point of view, and a user&amp;rsquo;s point of view.  I don&amp;rsquo;t know about you, but I&amp;rsquo;ve spent months of work time over my career configuring and setting up databases and debugging configuration problems, users and permissions and all the other crap you get from more traditional databases like Postgres and Mongo.  There&amp;rsquo;s none of that with bolt.  No users, no setup, just a file name.  This is also a boon for users of your application, because &lt;em&gt;they&lt;/em&gt; don&amp;rsquo;t have to futz with all that crap either.&lt;br /&gt;&lt;br /&gt;Bolt is not a relational database.  It&amp;rsquo;s not even a document store, though you can sort of use it that way.  It&amp;rsquo;s really just a key/value store&amp;hellip; but don&amp;rsquo;t worry if you don&amp;rsquo;t really know what that means or how you&amp;rsquo;d use that for storage.  It&amp;rsquo;s super simple and it&amp;rsquo;s incredibly flexible.  Let&amp;rsquo;s take a look.&lt;br /&gt;&lt;br /&gt;Storage in bolt is divided into buckets.  A bucket is simply a named collection of key/value pairs, just like Go&amp;rsquo;s map.  The name of the bucket, the keys, and the values are all of type []byte.  Buckets can contain other buckets, also keyed by a []byte name. &lt;br /&gt;&lt;br /&gt;&amp;hellip; that&amp;rsquo;s it.  No, really, that&amp;rsquo;s it.  Bolt is basically a bunch of nested maps.  And this simplicity is what makes it so easy to use.  There&amp;rsquo;s no tables to set up, no schemas, no complex querying language to struggle with.  Let&amp;rsquo;s look at a bolt hello world:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;package main&lt;br /&gt;&lt;br /&gt;import (&lt;br /&gt;    &amp;ldquo;fmt&amp;rdquo;&lt;br /&gt;    &amp;ldquo;log&amp;rdquo;&lt;br /&gt;&lt;br /&gt;    &amp;ldquo;github.com/boltdb/bolt&amp;rdquo;&lt;br /&gt;)&lt;br /&gt;&lt;br /&gt;var world = []byte(&amp;ldquo;world&amp;rdquo;)&lt;br /&gt;&lt;br /&gt;func main() {&lt;br /&gt;    db, err := bolt.Open(&amp;ldquo;/home/nate/foo/bolt.db&amp;rdquo;, 0644, nil)&lt;br /&gt;    if err != nil {&lt;br /&gt;        log.Fatal(err)&lt;br /&gt;    }&lt;br /&gt;    defer db.Close()&lt;br /&gt;&lt;br /&gt;    key := []byte(&amp;ldquo;hello&amp;rdquo;)&lt;br /&gt;    value := []byte(&amp;ldquo;Hello World!&amp;rdquo;)&lt;br /&gt;&lt;br /&gt;    // store some data&lt;br /&gt;    err = db.Update(func(tx *bolt.Tx) error {&lt;br /&gt;        bucket, err := tx.CreateBucketIfNotExists(world)&lt;br /&gt;        if err != nil {&lt;br /&gt;            return err&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        err = bucket.Put(key, value)&lt;br /&gt;        if err != nil {&lt;br /&gt;            return err&lt;br /&gt;        }&lt;br /&gt;        return nil&lt;br /&gt;    })&lt;br /&gt;&lt;br /&gt;    if err != nil {&lt;br /&gt;        log.Fatal(err)&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    // retrieve the data&lt;br /&gt;    err = db.View(func(tx *bolt.Tx) error {&lt;br /&gt;        bucket := tx.Bucket(world)&lt;br /&gt;        if bucket == nil {&lt;br /&gt;            return fmt.Errorf(&amp;ldquo;Bucket %q not found!&amp;rdquo;, world)&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        val := bucket.Get(key)&lt;br /&gt;        fmt.Println(string(val))&lt;br /&gt;&lt;br /&gt;        return nil&lt;br /&gt;    })&lt;br /&gt;&lt;br /&gt;    if err != nil {&lt;br /&gt;        log.Fatal(err)&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;// output:&lt;br /&gt;// Hello World!&lt;/pre&gt;&lt;div&gt;&lt;/div&gt;I know what you&amp;rsquo;re thinking - that seems kinda long.  But keep in mind, I fully handled all errors in at least a semi-proper way, and we&amp;rsquo;re doing all this:&lt;br /&gt;&lt;br /&gt;1.) creating a database &lt;br /&gt;2.) creating some structure (the &amp;ldquo;world&amp;rdquo; bucket)&lt;br /&gt;3.) storing data to the structure&lt;br /&gt;4.) retrieving data from the structure.&lt;br /&gt;&lt;br /&gt;I think that&amp;rsquo;s not too bad in 54 lines of code.&lt;br /&gt;&lt;br /&gt;So let&amp;rsquo;s look at what that example is really doing.  First we call bolt.Open to get the database.  This will create the file if necessary, or open it if it exists.&lt;br /&gt;&lt;br /&gt;All reads from or writes to the bolt database must be done within a transaction. You can have as many Readers in read-only transactions at the same time as you want, but only one Writer in a writable transaction at a time (readers maintain a consistent view of the DB while writers are writing).&lt;br /&gt;&lt;br /&gt;To begin, we call db.Update, which takes a function to which it&amp;rsquo;ll pass a bolt.Tx - bolt&amp;rsquo;s transaction object.  We then create a Bucket (since all data in bolt lives in buckets), and add our key/value pair to it.  After the write transaction finishes, we start a read- only transaction with DB.View, and get the values back out.&lt;br /&gt;&lt;br /&gt;What&amp;rsquo;s great about bolt&amp;rsquo;s transaction mechanism is that it&amp;rsquo;s super simple - the scope of the function is the scope of the transaction.  If the function passed to Update returns nil, all updates from the transaction are atomically stored to the database.  If the function passed to Update returns an error, the transaction is rolled back.  This makes bolt&amp;rsquo;s transactions completely intuitive from a Go developer&amp;rsquo;s point of view.  You just exit early out of your function by returning an error as usual, and bolt Does The Right Thing.  No need to worry about manually rolling back updates or anything, just return an error.&lt;br /&gt;&lt;br /&gt;The only other basic thing you may need is to iterate over key/value pairs in a Bucket, in which case, you just call bucket.Cursor(), which returns a Cursor value, which has functions like Next(), Prev() etc that return a key/value pair and work like you&amp;rsquo;d expect.&lt;br /&gt;&lt;br /&gt;There&amp;rsquo;s a lot more to the bolt API, but most of the rest of it is more about database statistics and some stuff for more advanced usage scenarios&amp;hellip; but the above is all you really need to know to start storing data in a bolt database.&lt;br /&gt;&lt;br /&gt;For a more complex application, just storing strings in the database may not be sufficient, but that&amp;rsquo;s ok, Go has your back there, too.  You can easily use encoding/json or encoding/gob to serialize structs into the database, keyed by a unique name or id.  This is what makes it easy for bolt to go from a key/value store to a document store - just have one bucket per document type.  Again, the benefit of bolt is low barrier of entry.  You don&amp;rsquo;t have to figure out a whole database schema or install anything to be able to just start dumping data to disk in a performant and manageable way.&lt;br /&gt;&lt;br /&gt;The main drawback of bolt is that there are no queries.  You can&amp;rsquo;t say &amp;ldquo;give me all foo objects with a name that starts with bar&amp;rdquo;.  You &lt;i&gt;could&lt;/i&gt; make your own index in the database and keep it up to date manually.  This could be as easy as a slice of IDs serialized into an &amp;ldquo;indices&amp;rdquo; bucket for a particular query. Obviously, this is where you start getting into the realm of developing your own relational database, but if you don&amp;rsquo;t go overboard, it can be nice that all this code is just that - code.  It&amp;rsquo;s not queries in some external DSL, it&amp;rsquo;s just code like you&amp;rsquo;d write for an in-memory data store.&lt;br /&gt;&lt;br /&gt;Bolt is not for every application.  You must understand your application&amp;rsquo;s needs and if bolt&amp;rsquo;s key/value style will be sufficient to fulfill those needs.  If it is, I think you&amp;rsquo;ll be very happy to use such a simple data store with so little mental overhead.&lt;br /&gt;&lt;br /&gt;[edited to clarify reader/writer relationship]   Bonus Gob vs. Json benchmark for storing structs in Bolt: &lt;pre&gt;&lt;br /&gt;BenchmarkGobEncode  1000000       2191 ns/op&lt;br /&gt;BenchmarkJsonEncode   500000       4738 ns/op&lt;br /&gt;BenchmarkGobDecode  1000000       2019 ns/op&lt;br /&gt;BenchmarkJsonDecode   200000      12993 ns/op&lt;br /&gt;&lt;/pre&gt;Code: &lt;a href=&#34;http://play.golang.org/p/IvfDUGBpJ6&#34;&gt;http://play.golang.org/p/IvfDUGBpJ6&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Autogenerate docs with this one dumb trick</title>
      <link>http://npf.io/2014/06/autogenerate-docs-with-this-one-dumb-trick/</link>
      <pubDate>Tue, 17 Jun 2014 05:59:00 UTC</pubDate>
      <author>Nate Finch</author>
      <guid>http://npf.io/2014/06/autogenerate-docs-with-this-one-dumb-trick/</guid>
      <description>&lt;p&gt;Yesterday, I was trying to think of a way of automating some doc generation for my go packages.  The specific task I wanted to automate was updating a badge in my package&amp;rsquo;s README to show the test coverage.  What I wanted was a way to run go test -cover, parse the results, and put the result in the correct spot of my README.  My first thought was to write an application that would do that for me &amp;hellip; but then I&amp;rsquo;d have to run that &lt;i&gt;instead&lt;/i&gt; of go test.  What I realized I wanted was something that was &amp;ldquo;compatible with go test&amp;rdquo; - i.e. I want to run go test and not have to remember to run some special other command.&lt;br /&gt;&lt;br /&gt;And that&amp;rsquo;s when it hit me:  What is a test in Go?  A test is a Go function that gets run when you run &amp;ldquo;go test&amp;rdquo;. &amp;nbsp;Nothing says your test has to actually test anything. &amp;nbsp;And nothing prevents your test from doing something permanent on your machine (in fact we usually have to bend over backwards to make sure our tests &lt;i&gt;don&amp;rsquo;t&lt;/i&gt;&amp;nbsp;do anything permanent. &amp;nbsp;You can just write a test function that updates the docs for you.&lt;br /&gt;&lt;br /&gt;I actually quite like this technique. &amp;nbsp;I often have some manual tasks after updating my code - usually updating the docs in the README with changes to the API, or changing the docs to show new CLI flags, etc. &amp;nbsp;And there&amp;rsquo;s one thing I always do after I update my code - and that&amp;rsquo;s run &amp;ldquo;go test&amp;rdquo;. &amp;nbsp;If that also updates my docs, all the better.&lt;br /&gt;&lt;br /&gt;This is how covergen was born. &amp;nbsp;&lt;a href=&#34;https://github.com/natefinch/covergen&#34;&gt;https://github.com/natefinch/covergen&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;Covergen is a particularly heinous example of a test that updates your docs. &amp;nbsp;The heinous part is that it actually doubles the time it takes to run your tests&amp;hellip; this is because that one test re-runs all the tests with -cover to get the coverage percent. &amp;nbsp;I&amp;rsquo;m not sure I&amp;rsquo;d actually release real code that used such a thing - doubling the time it takes to run your tests just to save a few seconds of copy and paste is pretty terrible.&lt;br /&gt;&lt;br /&gt;However, it&amp;rsquo;s a valid example of what you can do when you throw away testing convention and decide you want to write some code in a test that doesn&amp;rsquo;t actually test anything, and instead just runs some automated tasks that you want run whenever anyone runs go test. &amp;nbsp;Just make sure the result is idempotent so you&amp;rsquo;re not continually causing things to look modified to version control.&lt;/p&gt;
</description>
    </item>
    
    
  </channel>
</rss>